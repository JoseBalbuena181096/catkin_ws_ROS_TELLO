// Generated by gencpp from file flock_msgs/FlightData.msg
// DO NOT EDIT!


#ifndef FLOCK_MSGS_MESSAGE_FLIGHTDATA_H
#define FLOCK_MSGS_MESSAGE_FLIGHTDATA_H


#include <string>
#include <vector>
#include <map>

#include <ros/types.h>
#include <ros/serialization.h>
#include <ros/builtin_message_traits.h>
#include <ros/message_operations.h>


namespace flock_msgs
{
template <class ContainerAllocator>
struct FlightData_
{
  typedef FlightData_<ContainerAllocator> Type;

  FlightData_()
    : battery_percent(0)
    , estimated_flight_time_remaining(0.0)
    , flight_mode(0)
    , flight_time(0.0)
    , east_speed(0.0)
    , north_speed(0.0)
    , ground_speed(0.0)
    , altitude(0.0)
    , equipment(0)
    , high_temperature(false)
    , em_ground(false)
    , em_open(false)
    , em_sky(false)  {
    }
  FlightData_(const ContainerAllocator& _alloc)
    : battery_percent(0)
    , estimated_flight_time_remaining(0.0)
    , flight_mode(0)
    , flight_time(0.0)
    , east_speed(0.0)
    , north_speed(0.0)
    , ground_speed(0.0)
    , altitude(0.0)
    , equipment(0)
    , high_temperature(false)
    , em_ground(false)
    , em_open(false)
    , em_sky(false)  {
  (void)_alloc;
    }



   typedef int32_t _battery_percent_type;
  _battery_percent_type battery_percent;

   typedef float _estimated_flight_time_remaining_type;
  _estimated_flight_time_remaining_type estimated_flight_time_remaining;

   typedef uint8_t _flight_mode_type;
  _flight_mode_type flight_mode;

   typedef float _flight_time_type;
  _flight_time_type flight_time;

   typedef float _east_speed_type;
  _east_speed_type east_speed;

   typedef float _north_speed_type;
  _north_speed_type north_speed;

   typedef float _ground_speed_type;
  _ground_speed_type ground_speed;

   typedef float _altitude_type;
  _altitude_type altitude;

   typedef int32_t _equipment_type;
  _equipment_type equipment;

   typedef uint8_t _high_temperature_type;
  _high_temperature_type high_temperature;

   typedef uint8_t _em_ground_type;
  _em_ground_type em_ground;

   typedef uint8_t _em_open_type;
  _em_open_type em_open;

   typedef uint8_t _em_sky_type;
  _em_sky_type em_sky;



// reducing the odds to have name collisions with Windows.h 
#if defined(_WIN32) && defined(flight_mode_ground)
  #undef flight_mode_ground
#endif
#if defined(_WIN32) && defined(flight_mode_hover)
  #undef flight_mode_hover
#endif
#if defined(_WIN32) && defined(flight_mode_taking_off)
  #undef flight_mode_taking_off
#endif
#if defined(_WIN32) && defined(flight_mode_landing)
  #undef flight_mode_landing
#endif
#if defined(_WIN32) && defined(flight_mode_spinning_up)
  #undef flight_mode_spinning_up
#endif
#if defined(_WIN32) && defined(equipment_ok)
  #undef equipment_ok
#endif
#if defined(_WIN32) && defined(equipment_unstable)
  #undef equipment_unstable
#endif
#if defined(_WIN32) && defined(equipment_timer_exceeded)
  #undef equipment_timer_exceeded
#endif

  enum {
    flight_mode_ground = 1u,
    flight_mode_hover = 6u,
    flight_mode_taking_off = 11u,
    flight_mode_landing = 12u,
    flight_mode_spinning_up = 41u,
    equipment_ok = 0,
    equipment_unstable = 21,
    equipment_timer_exceeded = 205,
  };


  typedef boost::shared_ptr< ::flock_msgs::FlightData_<ContainerAllocator> > Ptr;
  typedef boost::shared_ptr< ::flock_msgs::FlightData_<ContainerAllocator> const> ConstPtr;

}; // struct FlightData_

typedef ::flock_msgs::FlightData_<std::allocator<void> > FlightData;

typedef boost::shared_ptr< ::flock_msgs::FlightData > FlightDataPtr;
typedef boost::shared_ptr< ::flock_msgs::FlightData const> FlightDataConstPtr;

// constants requiring out of line definition

   

   

   

   

   

   

   

   



template<typename ContainerAllocator>
std::ostream& operator<<(std::ostream& s, const ::flock_msgs::FlightData_<ContainerAllocator> & v)
{
ros::message_operations::Printer< ::flock_msgs::FlightData_<ContainerAllocator> >::stream(s, "", v);
return s;
}


template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator==(const ::flock_msgs::FlightData_<ContainerAllocator1> & lhs, const ::flock_msgs::FlightData_<ContainerAllocator2> & rhs)
{
  return lhs.battery_percent == rhs.battery_percent &&
    lhs.estimated_flight_time_remaining == rhs.estimated_flight_time_remaining &&
    lhs.flight_mode == rhs.flight_mode &&
    lhs.flight_time == rhs.flight_time &&
    lhs.east_speed == rhs.east_speed &&
    lhs.north_speed == rhs.north_speed &&
    lhs.ground_speed == rhs.ground_speed &&
    lhs.altitude == rhs.altitude &&
    lhs.equipment == rhs.equipment &&
    lhs.high_temperature == rhs.high_temperature &&
    lhs.em_ground == rhs.em_ground &&
    lhs.em_open == rhs.em_open &&
    lhs.em_sky == rhs.em_sky;
}

template<typename ContainerAllocator1, typename ContainerAllocator2>
bool operator!=(const ::flock_msgs::FlightData_<ContainerAllocator1> & lhs, const ::flock_msgs::FlightData_<ContainerAllocator2> & rhs)
{
  return !(lhs == rhs);
}


} // namespace flock_msgs

namespace ros
{
namespace message_traits
{





template <class ContainerAllocator>
struct IsMessage< ::flock_msgs::FlightData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsMessage< ::flock_msgs::FlightData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::flock_msgs::FlightData_<ContainerAllocator> >
  : TrueType
  { };

template <class ContainerAllocator>
struct IsFixedSize< ::flock_msgs::FlightData_<ContainerAllocator> const>
  : TrueType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flock_msgs::FlightData_<ContainerAllocator> >
  : FalseType
  { };

template <class ContainerAllocator>
struct HasHeader< ::flock_msgs::FlightData_<ContainerAllocator> const>
  : FalseType
  { };


template<class ContainerAllocator>
struct MD5Sum< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "aea1f1ee32ab41906cd3b81038074ba3";
  }

  static const char* value(const ::flock_msgs::FlightData_<ContainerAllocator>&) { return value(); }
  static const uint64_t static_value1 = 0xaea1f1ee32ab4190ULL;
  static const uint64_t static_value2 = 0x6cd3b81038074ba3ULL;
};

template<class ContainerAllocator>
struct DataType< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "flock_msgs/FlightData";
  }

  static const char* value(const ::flock_msgs::FlightData_<ContainerAllocator>&) { return value(); }
};

template<class ContainerAllocator>
struct Definition< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  static const char* value()
  {
    return "# Flight data -- experimental -- will change as we learn more\n"
"# Gobot code seems to be the best reference\n"
"\n"
"# Battery state:\n"
"int32 battery_percent                     # Remaining battery, 0-100\n"
"float32 estimated_flight_time_remaining   # Remaining flight time, seconds\n"
"\n"
"# Flight modes:\n"
"uint8 flight_mode_ground=1          # Motors off\n"
"uint8 flight_mode_hover=6           # Hovering\n"
"uint8 flight_mode_taking_off=11     # Taking off\n"
"uint8 flight_mode_landing=12        # Landing\n"
"uint8 flight_mode_spinning_up=41    # Spinning up the props, will take off soon\n"
"uint8 flight_mode\n"
"\n"
"# Flight time:\n"
"float32 flight_time                 # Flight time since power up, in seconds\n"
"\n"
"# Position and velocity, negative numbers mean \"no data\":\n"
"float32 east_speed                  # meters/second\n"
"float32 north_speed                 # meters/second\n"
"float32 ground_speed                # meters/second\n"
"float32 altitude                    # Height off the ground in meters\n"
"\n"
"# Equipment status:\n"
"int32 equipment_ok=0                # Everything is OK\n"
"int32 equipment_unstable=21         # The drone is unstable, tilted at an odd angle or upside down\n"
"int32 equipment_timer_exceeded=205  # No input for 15 seconds, shutting down\n"
"int32 equipment\n"
"\n"
"# Temperature:\n"
"bool high_temperature               # It's getting warm in here\n"
"\n"
"# ???\n"
"bool em_ground                      # ???\n"
"bool em_open                        # ???\n"
"bool em_sky                         # ???\n"
;
  }

  static const char* value(const ::flock_msgs::FlightData_<ContainerAllocator>&) { return value(); }
};

} // namespace message_traits
} // namespace ros

namespace ros
{
namespace serialization
{

  template<class ContainerAllocator> struct Serializer< ::flock_msgs::FlightData_<ContainerAllocator> >
  {
    template<typename Stream, typename T> inline static void allInOne(Stream& stream, T m)
    {
      stream.next(m.battery_percent);
      stream.next(m.estimated_flight_time_remaining);
      stream.next(m.flight_mode);
      stream.next(m.flight_time);
      stream.next(m.east_speed);
      stream.next(m.north_speed);
      stream.next(m.ground_speed);
      stream.next(m.altitude);
      stream.next(m.equipment);
      stream.next(m.high_temperature);
      stream.next(m.em_ground);
      stream.next(m.em_open);
      stream.next(m.em_sky);
    }

    ROS_DECLARE_ALLINONE_SERIALIZER
  }; // struct FlightData_

} // namespace serialization
} // namespace ros

namespace ros
{
namespace message_operations
{

template<class ContainerAllocator>
struct Printer< ::flock_msgs::FlightData_<ContainerAllocator> >
{
  template<typename Stream> static void stream(Stream& s, const std::string& indent, const ::flock_msgs::FlightData_<ContainerAllocator>& v)
  {
    s << indent << "battery_percent: ";
    Printer<int32_t>::stream(s, indent + "  ", v.battery_percent);
    s << indent << "estimated_flight_time_remaining: ";
    Printer<float>::stream(s, indent + "  ", v.estimated_flight_time_remaining);
    s << indent << "flight_mode: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.flight_mode);
    s << indent << "flight_time: ";
    Printer<float>::stream(s, indent + "  ", v.flight_time);
    s << indent << "east_speed: ";
    Printer<float>::stream(s, indent + "  ", v.east_speed);
    s << indent << "north_speed: ";
    Printer<float>::stream(s, indent + "  ", v.north_speed);
    s << indent << "ground_speed: ";
    Printer<float>::stream(s, indent + "  ", v.ground_speed);
    s << indent << "altitude: ";
    Printer<float>::stream(s, indent + "  ", v.altitude);
    s << indent << "equipment: ";
    Printer<int32_t>::stream(s, indent + "  ", v.equipment);
    s << indent << "high_temperature: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.high_temperature);
    s << indent << "em_ground: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.em_ground);
    s << indent << "em_open: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.em_open);
    s << indent << "em_sky: ";
    Printer<uint8_t>::stream(s, indent + "  ", v.em_sky);
  }
};

} // namespace message_operations
} // namespace ros

#endif // FLOCK_MSGS_MESSAGE_FLIGHTDATA_H
