/**********************************************************
 *            AUTOGENERATED FILE                          *
 *             DO NOT MODIFY IT                           *
 *                                                        *
 * To add new commands :                                  *
 *  - Modify ../Xml/commands.xml file                     *
 *  - Re-run generateFeatureControllers.py script         *
 *                                                        *
 **********************************************************/

/**
* @file ARCONTROLLER_Feature.c
* @brief Feature controller allow to send command related of a Feature.
*/

#include <stdio.h>
#include <libARSAL/ARSAL_Mutex.h>
#include <libARCommands/ARCommands.h>
#include <libARController/ARCONTROLLER_Network.h>
#include <libARController/ARCONTROLLER_Feature.h>
#include <libARController/ARCONTROLLER_Stream.h>

#include <ARCONTROLLER_Stream.h>
#include <ARCONTROLLER_StreamSender.h>
#include <ARCONTROLLER_Network.h>
#include <ARCONTROLLER_NAckCbs.h>
#include "ARCONTROLLER_Feature.h"

#define ARCONTROLLER_FEATURE_TAG "ARCONTROLLER_Feature"

void ARCONTROLLER_Feature_DeleteCommandsDictionary (ARCONTROLLER_DICTIONARY_COMMANDS_t **dictionary)
{
    // -- Delete a commands dictionary --
    
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdTmp = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictTmp = NULL;
    
    if (dictionary != NULL)
    {
        if ((*dictionary) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictionary), dictCmdElement, dictCmdTmp)
            {
                // Free the hash table contents
                HASH_ITER(hh, dictCmdElement->elements, dictElement, dictTmp)
                {
                    // for each element
                    
                    if (dictElement->arguments != NULL)
                    {
                        // delete all arguments
                        ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(dictElement->arguments));
                    }
                    
                    if (dictElement->key != NULL)
                    {
                        // free the key of the element
                        free (dictElement->key);
                        dictElement->key = NULL;
                    }
                    
                    HASH_DEL (dictCmdElement->elements, dictElement);
                    free (dictElement);
                    dictElement = NULL;
                }
                
                HASH_DEL ((*dictionary), dictCmdElement);
                free (dictCmdElement);
                dictCmdElement = NULL;
            }
            
            free (*dictionary);
            (*dictionary) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_Feature_NewCommandsElement (int commandKey, eARCONTROLLER_ERROR *error)
{
    // -- New Commands Element --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_COMMANDS_t));
    
    if (dictCmdElement != NULL)
    {
        dictCmdElement->command = commandKey;
        dictCmdElement->elements = NULL;
    }
    else
    {
        localError = ARCONTROLLER_ERROR_ALLOC;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictCmdElement;
}

void ARCONTROLLER_Feature_DeleteCommandsElement (ARCONTROLLER_DICTIONARY_COMMANDS_t **dictCmdElement)
{
    // -- Delete a commands Element --
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictTmp = NULL;
    
    if (dictCmdElement != NULL)
    {
        if ((*dictCmdElement) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictCmdElement)->elements, dictElement, dictTmp)
            {
                // for each element
                
                HASH_DEL ((*dictCmdElement)->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            
            free (*dictCmdElement);
            (*dictCmdElement) = NULL;
        }
    }
}

void ARCONTROLLER_Feature_DeleteElement (ARCONTROLLER_DICTIONARY_ELEMENT_t **element)
{
    // -- Delete an element --
    
    if (element != NULL)
    {
        if ((*element) != NULL)
        {
            if ((*element)->arguments != NULL)
            {
                // delete all arguments
                ARCONTROLLER_Feature_DeleteArgumentsDictionary (&((*element)->arguments));
            }
            
            if ((*element)->key != NULL)
            {
                // free the key of the element
                free ((*element)->key);
                (*element)->key = NULL;
            }
            
            free (*element);
            (*element) = NULL;
        }
    }
}

void ARCONTROLLER_Feature_DeleteArgumentsDictionary (ARCONTROLLER_DICTIONARY_ARG_t **dictionary)
{
    // -- Delete arguments dictionary --
    
    ARCONTROLLER_DICTIONARY_ARG_t *dictElement = NULL;
    ARCONTROLLER_DICTIONARY_ARG_t *dictTmp = NULL;
    
    if (dictionary != NULL)
    {
        if ((*dictionary) != NULL)
        {
            // Free the hash table contents
            HASH_ITER(hh, (*dictionary), dictElement, dictTmp)
            {
                /* for each element of the arguments dictionary */
                if ((dictElement->valueType == ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING) && (dictElement->value.String != NULL))
                {
                    free (dictElement->value.String);
                    dictElement->value.String = NULL;
                }
                
                HASH_DEL((*dictionary), dictElement);
                free(dictElement);
                dictElement = NULL;
            }
            
            free (*dictionary);
            (*dictionary) = NULL;
        }
    }
}

void ARCONTROLLER_Feature_AddElement (ARCONTROLLER_DICTIONARY_ELEMENT_t **elementDict, ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement)
{
    // -- Set new element in CommandElements --
    ARCONTROLLER_DICTIONARY_ELEMENT_t *oldElement = NULL;
    
    // Find if the element already exist
    HASH_FIND_STR ((*elementDict), newElement->key, oldElement);
    if (oldElement != NULL)
    {
        HASH_REPLACE_STR ((*elementDict), key, newElement, oldElement);
        
        ARCONTROLLER_Feature_DeleteArgumentsDictionary (&(oldElement->arguments));
        free (oldElement);
        oldElement = NULL;
    }
    else
    {
        HASH_ADD_KEYPTR (hh, (*elementDict), newElement->key, strlen(newElement->key), newElement);
    }
    
}

/*******************************
 * --- FEATURE generic --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_GENERIC_DRONESETTINGSCHANGED_SETTINGS = "arcontroller_dictionary_key_generic_dronesettingschanged_settings";

ARCONTROLLER_FEATURE_Generic_t *ARCONTROLLER_FEATURE_Generic_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Generic_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Generic_t));
        if (featureController != NULL)
        {
            featureController->sendDefault = ARCONTROLLER_FEATURE_Generic_SendDefault;
            featureController->sendSetDroneSettings = ARCONTROLLER_FEATURE_Generic_SendSetDroneSettings;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Generic_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Generic_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Generic_Delete (ARCONTROLLER_FEATURE_Generic_t **feature)
{
    // -- Delete the generic feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Generic_GetDictionary (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the generic Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_AddCallback (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Generic</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_RemoveCallback (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Generic</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_RegisterARCommands (ARCONTROLLER_FEATURE_Generic_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetGenericDroneSettingsChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Generic_DroneSettingsChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_UnregisterARCommands (ARCONTROLLER_FEATURE_Generic_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetGenericDroneSettingsChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_SendDefault (ARCONTROLLER_FEATURE_Generic_t *feature)
{
    // -- Send a command <code>Default</code> in project <code>Generic</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Default command
        cmdError = ARCOMMANDS_Generator_GenerateGenericDefault(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_SendSetDroneSettings (ARCONTROLLER_FEATURE_Generic_t *feature, ARCOMMANDS_Generic_DroneSettings_t * settings)
{
    // -- Send a command <code>SetDroneSettings</code> in project <code>Generic</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[4096];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetDroneSettings command
        cmdError = ARCOMMANDS_Generator_GenerateGenericSetDroneSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize, settings);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Generic_DroneSettingsChangedCallback (ARCOMMANDS_Generic_DroneSettingsChanged_t * _settings, void *customData)
{
    // -- callback used when the command <code>DroneSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Generic_t *feature = (ARCONTROLLER_FEATURE_Generic_t *)customData;
    ARCOMMANDS_Decoder_DecodeGenericDroneSettingsChanged (feature->privatePart->networkController->decoder, _settings);
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Generic_SetNetworkController (ARCONTROLLER_FEATURE_Generic_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Generic_GetCommandElements (ARCONTROLLER_FEATURE_Generic_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE animation --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_AVAILABILITY_VALUES = "arcontroller_dictionary_key_animation_availability_values";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_STATE_TYPE = "arcontroller_dictionary_key_animation_state_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_STATE_PERCENT = "arcontroller_dictionary_key_animation_state_percent";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_FLIPSTATE_STATE = "arcontroller_dictionary_key_animation_flipstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_FLIPSTATE_TYPE = "arcontroller_dictionary_key_animation_flipstate_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALPANORAMASTATE_STATE = "arcontroller_dictionary_key_animation_horizontalpanoramastate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALPANORAMASTATE_ROTATION_ANGLE = "arcontroller_dictionary_key_animation_horizontalpanoramastate_rotation_angle";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALPANORAMASTATE_ROTATION_SPEED = "arcontroller_dictionary_key_animation_horizontalpanoramastate_rotation_speed";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_STATE = "arcontroller_dictionary_key_animation_droniestate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_SPEED = "arcontroller_dictionary_key_animation_droniestate_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_DISTANCE = "arcontroller_dictionary_key_animation_droniestate_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_PLAY_MODE = "arcontroller_dictionary_key_animation_droniestate_play_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_STATE = "arcontroller_dictionary_key_animation_horizontalrevealstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_SPEED = "arcontroller_dictionary_key_animation_horizontalrevealstate_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_DISTANCE = "arcontroller_dictionary_key_animation_horizontalrevealstate_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_PLAY_MODE = "arcontroller_dictionary_key_animation_horizontalrevealstate_play_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_STATE = "arcontroller_dictionary_key_animation_verticalrevealstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_SPEED = "arcontroller_dictionary_key_animation_verticalrevealstate_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_VERTICAL_DISTANCE = "arcontroller_dictionary_key_animation_verticalrevealstate_vertical_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_ROTATION_ANGLE = "arcontroller_dictionary_key_animation_verticalrevealstate_rotation_angle";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_ROTATION_SPEED = "arcontroller_dictionary_key_animation_verticalrevealstate_rotation_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_PLAY_MODE = "arcontroller_dictionary_key_animation_verticalrevealstate_play_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_STATE = "arcontroller_dictionary_key_animation_spiralstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_SPEED = "arcontroller_dictionary_key_animation_spiralstate_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_RADIUS_VARIATION = "arcontroller_dictionary_key_animation_spiralstate_radius_variation";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_VERTICAL_DISTANCE = "arcontroller_dictionary_key_animation_spiralstate_vertical_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_REVOLUTION_NB = "arcontroller_dictionary_key_animation_spiralstate_revolution_nb";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_PLAY_MODE = "arcontroller_dictionary_key_animation_spiralstate_play_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_STATE = "arcontroller_dictionary_key_animation_parabolastate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_SPEED = "arcontroller_dictionary_key_animation_parabolastate_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_VERTICAL_DISTANCE = "arcontroller_dictionary_key_animation_parabolastate_vertical_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_PLAY_MODE = "arcontroller_dictionary_key_animation_parabolastate_play_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_STATE = "arcontroller_dictionary_key_animation_candlestate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_SPEED = "arcontroller_dictionary_key_animation_candlestate_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_VERTICAL_DISTANCE = "arcontroller_dictionary_key_animation_candlestate_vertical_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_PLAY_MODE = "arcontroller_dictionary_key_animation_candlestate_play_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_STATE = "arcontroller_dictionary_key_animation_dollyslidestate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_SPEED = "arcontroller_dictionary_key_animation_dollyslidestate_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_ANGLE = "arcontroller_dictionary_key_animation_dollyslidestate_angle";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_HORIZONTAL_DISTANCE = "arcontroller_dictionary_key_animation_dollyslidestate_horizontal_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_PLAY_MODE = "arcontroller_dictionary_key_animation_dollyslidestate_play_mode";

ARCONTROLLER_FEATURE_Animation_t *ARCONTROLLER_FEATURE_Animation_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Animation_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Animation_t));
        if (featureController != NULL)
        {
            featureController->sendCancel = ARCONTROLLER_FEATURE_Animation_SendCancel;
            featureController->sendStartFlip = ARCONTROLLER_FEATURE_Animation_SendStartFlip;
            featureController->sendStartHorizontalPanorama = ARCONTROLLER_FEATURE_Animation_SendStartHorizontalPanorama;
            featureController->sendStartDronie = ARCONTROLLER_FEATURE_Animation_SendStartDronie;
            featureController->sendStartHorizontalReveal = ARCONTROLLER_FEATURE_Animation_SendStartHorizontalReveal;
            featureController->sendStartVerticalReveal = ARCONTROLLER_FEATURE_Animation_SendStartVerticalReveal;
            featureController->sendStartSpiral = ARCONTROLLER_FEATURE_Animation_SendStartSpiral;
            featureController->sendStartParabola = ARCONTROLLER_FEATURE_Animation_SendStartParabola;
            featureController->sendStartCandle = ARCONTROLLER_FEATURE_Animation_SendStartCandle;
            featureController->sendStartDollySlide = ARCONTROLLER_FEATURE_Animation_SendStartDollySlide;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Animation_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Animation_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Animation_Delete (ARCONTROLLER_FEATURE_Animation_t **feature)
{
    // -- Delete the animation feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Animation_GetDictionary (ARCONTROLLER_FEATURE_Animation_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the animation Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_AddCallback (ARCONTROLLER_FEATURE_Animation_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Animation</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_RemoveCallback (ARCONTROLLER_FEATURE_Animation_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Animation</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_RegisterARCommands (ARCONTROLLER_FEATURE_Animation_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetAnimationAvailabilityCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_AvailabilityCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_StateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationFlipStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_FlipStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationHorizontalPanoramaStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_HorizontalPanoramaStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationDronieStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_DronieStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationHorizontalRevealStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_HorizontalRevealStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationVerticalRevealStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_VerticalRevealStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationSpiralStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_SpiralStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationParabolaStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_ParabolaStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationCandleStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_CandleStateCallback, feature);
        ARCOMMANDS_Decoder_SetAnimationDollySlideStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Animation_DollySlideStateCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_UnregisterARCommands (ARCONTROLLER_FEATURE_Animation_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetAnimationAvailabilityCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationFlipStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationHorizontalPanoramaStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationDronieStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationHorizontalRevealStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationVerticalRevealStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationSpiralStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationParabolaStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationCandleStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetAnimationDollySlideStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendCancel (ARCONTROLLER_FEATURE_Animation_t *feature)
{
    // -- Send a command <code>Cancel</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Cancel command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationCancel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartFlip (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_FLIP_TYPE type)
{
    // -- Send a command <code>StartFlip</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartFlip command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartFlip(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartHorizontalPanorama (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float rotation_angle, float rotation_speed)
{
    // -- Send a command <code>StartHorizontalPanorama</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartHorizontalPanorama command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartHorizontalPanorama(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, rotation_angle, rotation_speed);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartDronie (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float speed, float distance, eARCOMMANDS_ANIMATION_PLAY_MODE play_mode)
{
    // -- Send a command <code>StartDronie</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartDronie command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartDronie(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, speed, distance, play_mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartHorizontalReveal (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float speed, float distance, eARCOMMANDS_ANIMATION_PLAY_MODE play_mode)
{
    // -- Send a command <code>StartHorizontalReveal</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartHorizontalReveal command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartHorizontalReveal(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, speed, distance, play_mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartVerticalReveal (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float speed, float vertical_distance, float rotation_angle, float rotation_speed, eARCOMMANDS_ANIMATION_PLAY_MODE play_mode)
{
    // -- Send a command <code>StartVerticalReveal</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartVerticalReveal command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartVerticalReveal(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, speed, vertical_distance, rotation_angle, rotation_speed, play_mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartSpiral (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float speed, float radius_variation, float vertical_distance, float revolution_nb, eARCOMMANDS_ANIMATION_PLAY_MODE play_mode)
{
    // -- Send a command <code>StartSpiral</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartSpiral command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartSpiral(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, speed, radius_variation, vertical_distance, revolution_nb, play_mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartParabola (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float speed, float vertical_distance, eARCOMMANDS_ANIMATION_PLAY_MODE play_mode)
{
    // -- Send a command <code>StartParabola</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartParabola command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartParabola(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, speed, vertical_distance, play_mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartCandle (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float speed, float vertical_distance, eARCOMMANDS_ANIMATION_PLAY_MODE play_mode)
{
    // -- Send a command <code>StartCandle</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartCandle command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartCandle(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, speed, vertical_distance, play_mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SendStartDollySlide (ARCONTROLLER_FEATURE_Animation_t *feature, uint8_t provided_params, float speed, float angle, float horizontal_distance, eARCOMMANDS_ANIMATION_PLAY_MODE play_mode)
{
    // -- Send a command <code>StartDollySlide</code> in project <code>Animation</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartDollySlide command
        cmdError = ARCOMMANDS_Generator_GenerateAnimationStartDollySlide(cmdBuffer, sizeof(cmdBuffer), &cmdSize, provided_params, speed, angle, horizontal_distance, play_mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Animation_AvailabilityCallback (uint32_t _values, void *customData)
{
    // -- callback used when the command <code>Availability</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_AVAILABILITY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementAvailability (feature,  _values, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_StateCallback (eARCOMMANDS_ANIMATION_TYPE _type, uint8_t _percent, void *customData)
{
    // -- callback used when the command <code>State</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_STATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementState (feature,  _type,  _percent, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_FlipStateCallback (eARCOMMANDS_ANIMATION_STATE _state, eARCOMMANDS_ANIMATION_FLIP_TYPE _type, void *customData)
{
    // -- callback used when the command <code>FlipState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_FLIPSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementFlipState (feature,  _state,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_HorizontalPanoramaStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _rotation_angle, float _rotation_speed, void *customData)
{
    // -- callback used when the command <code>HorizontalPanoramaState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALPANORAMASTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementHorizontalPanoramaState (feature,  _state,  _rotation_angle,  _rotation_speed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_DronieStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, void *customData)
{
    // -- callback used when the command <code>DronieState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementDronieState (feature,  _state,  _speed,  _distance,  _play_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_HorizontalRevealStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, void *customData)
{
    // -- callback used when the command <code>HorizontalRevealState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementHorizontalRevealState (feature,  _state,  _speed,  _distance,  _play_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_VerticalRevealStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _vertical_distance, float _rotation_angle, float _rotation_speed, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, void *customData)
{
    // -- callback used when the command <code>VerticalRevealState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementVerticalRevealState (feature,  _state,  _speed,  _vertical_distance,  _rotation_angle,  _rotation_speed,  _play_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_SpiralStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _radius_variation, float _vertical_distance, float _revolution_nb, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, void *customData)
{
    // -- callback used when the command <code>SpiralState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementSpiralState (feature,  _state,  _speed,  _radius_variation,  _vertical_distance,  _revolution_nb,  _play_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_ParabolaStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _vertical_distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, void *customData)
{
    // -- callback used when the command <code>ParabolaState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementParabolaState (feature,  _state,  _speed,  _vertical_distance,  _play_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_CandleStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _vertical_distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, void *customData)
{
    // -- callback used when the command <code>CandleState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementCandleState (feature,  _state,  _speed,  _vertical_distance,  _play_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Animation_DollySlideStateCallback (eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _angle, float _horizontal_distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, void *customData)
{
    // -- callback used when the command <code>DollySlideState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Animation_t *feature = (ARCONTROLLER_FEATURE_Animation_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Animation_NewCmdElementDollySlideState (feature,  _state,  _speed,  _angle,  _horizontal_distance,  _play_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementAvailability (ARCONTROLLER_FEATURE_Animation_t *feature, uint32_t _values, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event Availability -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_AVAILABILITY_VALUES;
            argDictNewElement->value.U32 = _values;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_TYPE _type, uint8_t _percent, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event State -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_STATE_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_STATE_PERCENT;
            argDictNewElement->value.U8 = _percent;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementFlipState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, eARCOMMANDS_ANIMATION_FLIP_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlipState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_FLIPSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_FLIPSTATE_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementHorizontalPanoramaState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _rotation_angle, float _rotation_speed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event HorizontalPanoramaState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALPANORAMASTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALPANORAMASTATE_ROTATION_ANGLE;
            argDictNewElement->value.Float = _rotation_angle;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALPANORAMASTATE_ROTATION_SPEED;
            argDictNewElement->value.Float = _rotation_speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementDronieState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DronieState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DRONIESTATE_PLAY_MODE;
            argDictNewElement->value.I32 = _play_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementHorizontalRevealState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event HorizontalRevealState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_HORIZONTALREVEALSTATE_PLAY_MODE;
            argDictNewElement->value.I32 = _play_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementVerticalRevealState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _vertical_distance, float _rotation_angle, float _rotation_speed, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VerticalRevealState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_ROTATION_ANGLE;
            argDictNewElement->value.Float = _rotation_angle;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_ROTATION_SPEED;
            argDictNewElement->value.Float = _rotation_speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_VERTICALREVEALSTATE_PLAY_MODE;
            argDictNewElement->value.I32 = _play_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementSpiralState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _radius_variation, float _vertical_distance, float _revolution_nb, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpiralState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_RADIUS_VARIATION;
            argDictNewElement->value.Float = _radius_variation;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_REVOLUTION_NB;
            argDictNewElement->value.Float = _revolution_nb;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_SPIRALSTATE_PLAY_MODE;
            argDictNewElement->value.I32 = _play_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementParabolaState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _vertical_distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ParabolaState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_PARABOLASTATE_PLAY_MODE;
            argDictNewElement->value.I32 = _play_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementCandleState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _vertical_distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CandleState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_CANDLESTATE_PLAY_MODE;
            argDictNewElement->value.I32 = _play_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_NewCmdElementDollySlideState (ARCONTROLLER_FEATURE_Animation_t *feature, eARCOMMANDS_ANIMATION_STATE _state, float _speed, float _angle, float _horizontal_distance, eARCOMMANDS_ANIMATION_PLAY_MODE _play_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DollySlideState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_ANGLE;
            argDictNewElement->value.Float = _angle;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_HORIZONTAL_DISTANCE;
            argDictNewElement->value.Float = _horizontal_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ANIMATION_DOLLYSLIDESTATE_PLAY_MODE;
            argDictNewElement->value.I32 = _play_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Animation_SetNetworkController (ARCONTROLLER_FEATURE_Animation_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Animation_GetCommandElements (ARCONTROLLER_FEATURE_Animation_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE ARDrone3 --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videostatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videoresolutionstate_streaming";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING = "arcontroller_dictionary_key_ardrone3_mediarecordstate_videoresolutionstate_recording";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_ardrone3_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordevent_pictureeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT = "arcontroller_dictionary_key_ardrone3_mediarecordevent_videoeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR = "arcontroller_dictionary_key_ardrone3_mediarecordevent_videoeventchanged_error";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_flyingstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_alertstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_navigatehomestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON = "arcontroller_dictionary_key_ardrone3_pilotingstate_navigatehomestatechanged_reason";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_positionchanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedx";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedy";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ = "arcontroller_dictionary_key_ardrone3_pilotingstate_speedchanged_speedz";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_roll";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_pitch";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW = "arcontroller_dictionary_key_ardrone3_pilotingstate_attitudechanged_yaw";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_autotakeoffmodechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_altitudechanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_gpslocationchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_gpslocationchanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_gpslocationchanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LATITUDE_ACCURACY = "arcontroller_dictionary_key_ardrone3_pilotingstate_gpslocationchanged_latitude_accuracy";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LONGITUDE_ACCURACY = "arcontroller_dictionary_key_ardrone3_pilotingstate_gpslocationchanged_longitude_accuracy";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_ALTITUDE_ACCURACY = "arcontroller_dictionary_key_ardrone3_pilotingstate_gpslocationchanged_altitude_accuracy";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_landingstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AIRSPEEDCHANGED_AIRSPEED = "arcontroller_dictionary_key_ardrone3_pilotingstate_airspeedchanged_airspeed";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_movetochanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_movetochanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_movetochanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ORIENTATION_MODE = "arcontroller_dictionary_key_ardrone3_pilotingstate_movetochanged_orientation_mode";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_HEADING = "arcontroller_dictionary_key_ardrone3_pilotingstate_movetochanged_heading";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_STATUS = "arcontroller_dictionary_key_ardrone3_pilotingstate_movetochanged_status";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOTIONSTATE_STATE = "arcontroller_dictionary_key_ardrone3_pilotingstate_motionstate_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_LATITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_pilotedpoi_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_LONGITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_pilotedpoi_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_ALTITUDE = "arcontroller_dictionary_key_ardrone3_pilotingstate_pilotedpoi_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_STATUS = "arcontroller_dictionary_key_ardrone3_pilotingstate_pilotedpoi_status";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_RETURNHOMEBATTERYCAPACITY_STATUS = "arcontroller_dictionary_key_ardrone3_pilotingstate_returnhomebatterycapacity_status";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DX = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dx";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DY = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dy";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DZ = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dz";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DPSI = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_dpsi";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR = "arcontroller_dictionary_key_ardrone3_pilotingevent_movebyend_error";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networkstate_wifiscanlistchanged_channel";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_ardrone3_networkstate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxtiltchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_absolutcontrolchanged_on";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_maxdistancechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_noflyovermaxdistancechanged_shouldnotflyover";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxhorizontalspeed_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALSPEED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxverticalspeed_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxhorizontalacceleration_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxverticalacceleration_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXROTATIONSPEED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_autonomousflightmaxrotationspeed_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_STATE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_bankedturnchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_minaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_minaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_minaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingdirectionchanged_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingradiuschanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingradiuschanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingradiuschanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MIN = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MAX = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_circlingaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_pitchmodechanged_value";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MOTIONDETECTION_ENABLED = "arcontroller_dictionary_key_ardrone3_pilotingsettingsstate_motiondetection_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxverticalspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxrotationspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_hullprotectionchanged_present";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_outdoorchanged_outdoor";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxpitchrollrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxpitchrollrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_speedsettingsstate_maxpitchrollrotationspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifiselectionchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecuritychanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecurity_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEY = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecurity_key";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE = "arcontroller_dictionary_key_ardrone3_networksettingsstate_wifisecurity_keytype";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_MOTOR_NUMBER = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_motor_number";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_SOFTWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_HARDWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productmotorversionlistchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productgpsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_ardrone3_settingsstate_productgpsversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORIDS = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorstatechanged_motorids";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorstatechanged_motorerror";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED_VERSION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorsoftwareversionchanged_version";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_NBFLIGHTS = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_nbflights";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_LASTFLIGHTDURATION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_lastflightduration";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_TOTALFLIGHTDURATION = "arcontroller_dictionary_key_ardrone3_settingsstate_motorflightsstatuschanged_totalflightduration";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR = "arcontroller_dictionary_key_ardrone3_settingsstate_motorerrorlasterrorchanged_motorerror";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID_SERIALID = "arcontroller_dictionary_key_ardrone3_settingsstate_p7id_serialid";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_CPUID_ID = "arcontroller_dictionary_key_ardrone3_settingsstate_cpuid_id";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_pictureformatchanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_autowhitebalancechanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_value";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_expositionchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_VALUE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_value";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MIN = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MAX = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_saturationchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_enabled";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_INTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_interval";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MININTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_mininterval";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MAXINTERVAL = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_timelapsechanged_maxinterval";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoautorecordchanged_enabled";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoautorecordchanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videostabilizationmodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videorecordingmodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoframeratechanged_framerate";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_picturesettingsstate_videoresolutionschanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED = "arcontroller_dictionary_key_ardrone3_mediastreamingstate_videoenablechanged_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE = "arcontroller_dictionary_key_ardrone3_mediastreamingstate_videostreammodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_homechanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_ALTITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_resethomechanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED_FIXED = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_gpsfixstatechanged_fixed";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_gpsupdatestatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_hometypechanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_returnhomedelaychanged_delay";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GEOFENCECENTERCHANGED_LATITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_geofencecenterchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GEOFENCECENTERCHANGED_LONGITUDE = "arcontroller_dictionary_key_ardrone3_gpssettingsstate_geofencecenterchanged_longitude";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_orientation_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_orientation_pan";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_defaultcameraorientation_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_defaultcameraorientation_pan";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_orientationv2_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_orientationv2_pan";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_defaultcameraorientationv2_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_defaultcameraorientationv2_pan";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE_MAX_TILT = "arcontroller_dictionary_key_ardrone3_camerastate_velocityrange_max_tilt";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE_MAX_PAN = "arcontroller_dictionary_key_ardrone3_camerastate_velocityrange_max_pan";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY = "arcontroller_dictionary_key_ardrone3_antiflickeringstate_electricfrequencychanged_frequency";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE = "arcontroller_dictionary_key_ardrone3_antiflickeringstate_modechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE = "arcontroller_dictionary_key_ardrone3_gpsstate_numberofsatellitechanged_numberofsatellite";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypeavailabilitychanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypeavailabilitychanged_available";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE = "arcontroller_dictionary_key_ardrone3_gpsstate_hometypechosenchanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES = "arcontroller_dictionary_key_ardrone3_prostate_features_features";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ID = "arcontroller_dictionary_key_ardrone3_accessorystate_connectedaccessories_id";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ACCESSORY_TYPE = "arcontroller_dictionary_key_ardrone3_accessorystate_connectedaccessories_accessory_type";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_UID = "arcontroller_dictionary_key_ardrone3_accessorystate_connectedaccessories_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_SWVERSION = "arcontroller_dictionary_key_ardrone3_accessorystate_connectedaccessories_swversion";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_BATTERY_ID = "arcontroller_dictionary_key_ardrone3_accessorystate_battery_id";
const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_BATTERY_BATTERYLEVEL = "arcontroller_dictionary_key_ardrone3_accessorystate_battery_batterylevel";

const char *ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SOUNDSTATE_ALERTSOUND_STATE = "arcontroller_dictionary_key_ardrone3_soundstate_alertsound_state";

ARCONTROLLER_FEATURE_ARDrone3_t *ARCONTROLLER_FEATURE_ARDrone3_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_ARDrone3_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingFlatTrim = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingFlatTrim;
            featureController->sendPilotingTakeOff = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingTakeOff;
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDRoll = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDRoll;
            featureController->setPilotingPCMDPitch = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPitch;
            featureController->setPilotingPCMDYaw = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDYaw;
            featureController->setPilotingPCMDGaz = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDGaz;
            featureController->setPilotingPCMDTimestampAndSeqNum = ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDTimestampAndSeqNum;
            featureController->sendPilotingLanding = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingLanding;
            featureController->sendPilotingEmergency = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingEmergency;
            featureController->sendPilotingNavigateHome = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingNavigateHome;
            featureController->sendPilotingAutoTakeOffMode = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingAutoTakeOffMode;
            featureController->sendPilotingMoveBy = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingMoveBy;
            featureController->sendPilotingUserTakeOff = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingUserTakeOff;
            featureController->sendPilotingCircle = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingCircle;
            featureController->sendPilotingMoveTo = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingMoveTo;
            featureController->sendPilotingCancelMoveTo = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingCancelMoveTo;
            featureController->sendPilotingStartPilotedPOI = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingStartPilotedPOI;
            featureController->sendPilotingStopPilotedPOI = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingStopPilotedPOI;
            featureController->sendAnimationsFlip = ARCONTROLLER_FEATURE_ARDrone3_SendAnimationsFlip;
            featureController->sendCameraOrientation = ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientation;
            featureController->setCameraOrientation = ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientation;
            featureController->setCameraOrientationTilt = ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationTilt;
            featureController->setCameraOrientationPan = ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationPan;
            featureController->sendCameraOrientationV2 = ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientationV2;
            featureController->setCameraOrientationV2 = ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationV2;
            featureController->setCameraOrientationV2Tilt = ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationV2Tilt;
            featureController->setCameraOrientationV2Pan = ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationV2Pan;
            featureController->sendCameraVelocity = ARCONTROLLER_FEATURE_ARDrone3_SendCameraVelocity;
            featureController->setCameraVelocity = ARCONTROLLER_FEATURE_ARDrone3_SetCameraVelocity;
            featureController->setCameraVelocityTilt = ARCONTROLLER_FEATURE_ARDrone3_SetCameraVelocityTilt;
            featureController->setCameraVelocityPan = ARCONTROLLER_FEATURE_ARDrone3_SetCameraVelocityPan;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPicture;
            featureController->sendMediaRecordVideo = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideo;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPictureV2;
            featureController->sendMediaRecordVideoV2 = ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideoV2;
            featureController->sendNetworkWifiScan = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiScan;
            featureController->sendNetworkWifiAuthChannel = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiAuthChannel;
            featureController->sendPilotingSettingsMaxAltitude = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxAltitude;
            featureController->sendPilotingSettingsMaxTilt = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxTilt;
            featureController->sendPilotingSettingsAbsolutControl = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsAbsolutControl;
            featureController->sendPilotingSettingsMaxDistance = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxDistance;
            featureController->sendPilotingSettingsNoFlyOverMaxDistance = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsNoFlyOverMaxDistance;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxHorizontalSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalSpeed;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxVerticalSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalSpeed;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxVerticalAcceleration = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalAcceleration;
            featureController->sendPilotingSettingsSetAutonomousFlightMaxRotationSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxRotationSpeed;
            featureController->sendPilotingSettingsBankedTurn = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsBankedTurn;
            featureController->sendPilotingSettingsMinAltitude = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMinAltitude;
            featureController->sendPilotingSettingsCirclingDirection = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingDirection;
            featureController->sendPilotingSettingsCirclingRadius = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingRadius;
            featureController->sendPilotingSettingsCirclingAltitude = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingAltitude;
            featureController->sendPilotingSettingsPitchMode = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsPitchMode;
            featureController->sendPilotingSettingsSetMotionDetectionMode = ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetMotionDetectionMode;
            featureController->sendSpeedSettingsMaxVerticalSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxVerticalSpeed;
            featureController->sendSpeedSettingsMaxRotationSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxRotationSpeed;
            featureController->sendSpeedSettingsHullProtection = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsHullProtection;
            featureController->sendSpeedSettingsOutdoor = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsOutdoor;
            featureController->sendSpeedSettingsMaxPitchRollRotationSpeed = ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxPitchRollRotationSpeed;
            featureController->sendNetworkSettingsWifiSelection = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSelection;
            featureController->sendNetworkSettingsWifiSecurity = ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSecurity;
            featureController->sendPictureSettingsPictureFormatSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsPictureFormatSelection;
            featureController->sendPictureSettingsAutoWhiteBalanceSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsAutoWhiteBalanceSelection;
            featureController->sendPictureSettingsExpositionSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsExpositionSelection;
            featureController->sendPictureSettingsSaturationSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsSaturationSelection;
            featureController->sendPictureSettingsTimelapseSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsTimelapseSelection;
            featureController->sendPictureSettingsVideoAutorecordSelection = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoAutorecordSelection;
            featureController->sendPictureSettingsVideoStabilizationMode = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoStabilizationMode;
            featureController->sendPictureSettingsVideoRecordingMode = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoRecordingMode;
            featureController->sendPictureSettingsVideoFramerate = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoFramerate;
            featureController->sendPictureSettingsVideoResolutions = ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoResolutions;
            featureController->sendMediaStreamingVideoEnable = ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoEnable;
            featureController->sendMediaStreamingVideoStreamMode = ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoStreamMode;
            featureController->sendGPSSettingsSetHome = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSetHome;
            featureController->sendGPSSettingsResetHome = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsResetHome;
            featureController->sendGPSSettingsSendControllerGPS = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSendControllerGPS;
            featureController->sendGPSSettingsHomeType = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsHomeType;
            featureController->sendGPSSettingsReturnHomeDelay = ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsReturnHomeDelay;
            featureController->sendAntiflickeringElectricFrequency = ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringElectricFrequency;
            featureController->sendAntiflickeringSetMode = ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringSetMode;
            featureController->sendSoundStartAlertSound = ARCONTROLLER_FEATURE_ARDrone3_SendSoundStartAlertSound;
            featureController->sendSoundStopAlertSound = ARCONTROLLER_FEATURE_ARDrone3_SendSoundStopAlertSound;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_ARDrone3_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->PilotingPCMDParameters = NULL;
            featureController->privatePart->CameraOrientationParameters = NULL;
            featureController->privatePart->CameraOrientationV2Parameters = NULL;
            featureController->privatePart->CameraVelocityParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->PilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_ARDrone3_PilotingPCMDParameters_t));
        if (featureController->privatePart->PilotingPCMDParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDInit (featureController);
    }

    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->CameraOrientationParameters = calloc (1, sizeof (ARCONTROLLER_ARDrone3_CameraOrientationParameters_t));
        if (featureController->privatePart->CameraOrientationParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationInit (featureController);
    }

    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->CameraOrientationV2Parameters = calloc (1, sizeof (ARCONTROLLER_ARDrone3_CameraOrientationV2Parameters_t));
        if (featureController->privatePart->CameraOrientationV2Parameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationV2Init (featureController);
    }

    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->CameraVelocityParameters = calloc (1, sizeof (ARCONTROLLER_ARDrone3_CameraVelocityParameters_t));
        if (featureController->privatePart->CameraVelocityParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_ARDrone3CameraVelocityInit (featureController);
    }

    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_ARDrone3_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_ARDrone3_Delete (ARCONTROLLER_FEATURE_ARDrone3_t **feature)
{
    // -- Delete the ARDrone3 feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->PilotingPCMDParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDDeInit (*feature);

                    free ((*feature)->privatePart->PilotingPCMDParameters);
                    (*feature)->privatePart->PilotingPCMDParameters = NULL;
                }
                if ((*feature)->privatePart->CameraOrientationParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationDeInit (*feature);

                    free ((*feature)->privatePart->CameraOrientationParameters);
                    (*feature)->privatePart->CameraOrientationParameters = NULL;
                }
                if ((*feature)->privatePart->CameraOrientationV2Parameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationV2DeInit (*feature);

                    free ((*feature)->privatePart->CameraOrientationV2Parameters);
                    (*feature)->privatePart->CameraOrientationV2Parameters = NULL;
                }
                if ((*feature)->privatePart->CameraVelocityParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_ARDrone3CameraVelocityDeInit (*feature);

                    free ((*feature)->privatePart->CameraVelocityParameters);
                    (*feature)->privatePart->CameraVelocityParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_ARDrone3_GetDictionary (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the ARDrone3 Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_AddCallback (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>ARDrone3</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_RemoveCallback (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>ARDrone3</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_RegisterARCommands (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoResolutionStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoResolutionStateCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventVideoEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlatTrimChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateNavigateHomeStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAttitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAutoTakeOffModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateGpsLocationChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateGpsLocationChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateLandingStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateLandingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAirSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAirSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateMoveToChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateMoveToChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateMotionStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateMotionStateCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePilotedPOICb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePilotedPOICallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateReturnHomeBatteryCapacityCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingStateReturnHomeBatteryCapacityCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingEventMoveByEndCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiScanListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiScanChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxTiltChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAbsolutControlChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxDistanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateBankedTurnChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMinAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingDirectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingRadiusChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStatePitchModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMotionDetectionCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMotionDetectionCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxVerticalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateHullProtectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateOutdoorChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSelectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductMotorVersionListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductGPSVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorSoftwareVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorFlightsStatusChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorLastErrorChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateP7IDCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateCPUIDCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SettingsStateCPUIDCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStatePictureFormatChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateAutoWhiteBalanceChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateExpositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateSaturationChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateTimelapseChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoAutorecordChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoStabilizationModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoRecordingModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoRecordingModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoFramerateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoFramerateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoResolutionsChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoResolutionsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoEnableChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoStreamModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoStreamModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateResetHomeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSFixStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSUpdateStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeTypeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateReturnHomeDelayChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGeofenceCenterChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGeofenceCenterChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_CameraStateDefaultCameraOrientationCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationV2Callback, feature);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_CameraStateDefaultCameraOrientationV2Callback, feature);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateVelocityRangeCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_CameraStateVelocityRangeCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateElectricFrequencyChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSStateNumberOfSatelliteChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeAvailabilityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeChosenChangedCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_PROStateFeaturesCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3AccessoryStateConnectedAccessoriesCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_AccessoryStateConnectedAccessoriesCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3AccessoryStateBatteryCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_AccessoryStateBatteryCallback, feature);
        ARCOMMANDS_Decoder_SetARDrone3SoundStateAlertSoundCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ARDrone3_SoundStateAlertSoundCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_UnregisterARCommands (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoStateChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordStateVideoResolutionStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaRecordEventVideoEventChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlatTrimChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateFlyingStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateNavigateHomeStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePositionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAttitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAutoTakeOffModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAltitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateGpsLocationChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateLandingStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateAirSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateMoveToChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateMotionStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStatePilotedPOICb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingStateReturnHomeBatteryCapacityCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingEventMoveByEndCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiScanListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiScanChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxAltitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxTiltChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAbsolutControlChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMaxDistanceChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateNoFlyOverMaxDistanceChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateAutonomousFlightMaxRotationSpeedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateBankedTurnChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMinAltitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingDirectionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingRadiusChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateCirclingAltitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStatePitchModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PilotingSettingsStateMotionDetectionCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxVerticalSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxRotationSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateHullProtectionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateOutdoorChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SpeedSettingsStateMaxPitchRollRotationSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3NetworkSettingsStateWifiSecurityCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductMotorVersionListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateProductGPSVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorSoftwareVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorFlightsStatusChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateMotorErrorLastErrorChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateP7IDCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SettingsStateCPUIDCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStatePictureFormatChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateAutoWhiteBalanceChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateExpositionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateSaturationChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateTimelapseChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoAutorecordChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoStabilizationModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoRecordingModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoFramerateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PictureSettingsStateVideoResolutionsChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoEnableChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3MediaStreamingStateVideoStreamModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateResetHomeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSFixStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGPSUpdateStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateHomeTypeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateReturnHomeDelayChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSSettingsStateGeofenceCenterChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateOrientationV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateDefaultCameraOrientationV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3CameraStateVelocityRangeCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateElectricFrequencyChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3AntiflickeringStateModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateNumberOfSatelliteChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeAvailabilityChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3GPSStateHomeTypeChosenChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3PROStateFeaturesCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3AccessoryStateConnectedAccessoriesCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3AccessoryStateBatteryCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetARDrone3SoundStateAlertSoundCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingFlatTrim (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingFlatTrim</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlatTrim command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingFlatTrim(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingTakeOff (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingTakeOff</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingPCMD (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t flag, int8_t roll, int8_t pitch, int8_t yaw, int8_t gaz, uint32_t timestampAndSeqNum)
{
    // -- Send a command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, roll, pitch, yaw, gaz, timestampAndSeqNum);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMD (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _flag, int8_t _roll, int8_t _pitch, int8_t _yaw, int8_t _gaz, uint32_t _timestampAndSeqNum)
{
    // -- Set the parameter for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
        feature->privatePart->PilotingPCMDParameters->roll = _roll;
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;
        feature->privatePart->PilotingPCMDParameters->timestampAndSeqNum = _timestampAndSeqNum;

            ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ARDrone3_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_ARDrone3_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PilotingPCMD</code> in project <code>ARDrone3</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->PilotingPCMDParameters->flag, feature->privatePart->PilotingPCMDParameters->roll, feature->privatePart->PilotingPCMDParameters->pitch, feature->privatePart->PilotingPCMDParameters->yaw, feature->privatePart->PilotingPCMDParameters->gaz, feature->privatePart->PilotingPCMDParameters->timestampAndSeqNum);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;

        ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDRoll (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _roll)
{
    // -- Set the roll for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->roll = _roll;

        ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDPitch (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _pitch)
{
    // -- Set the pitch for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;

        ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDYaw (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _yaw)
{
    // -- Set the yaw for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;

        ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDGaz (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _gaz)
{
    // -- Set the gaz for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;

        ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetPilotingPCMDTimestampAndSeqNum (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint32_t _timestampAndSeqNum)
{
    // -- Set the timestampAndSeqNum for the command <code>PilotingPCMD</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->timestampAndSeqNum = _timestampAndSeqNum;

        ARCONTROLLER_NAckCbs_ARDrone3PilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingLanding (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingLanding</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Landing command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingLanding(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingEmergency (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingEmergency</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Emergency command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingEmergency(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingNavigateHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t start)
{
    // -- Send a command <code>PilotingNavigateHome</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send NavigateHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingNavigateHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize, start);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingAutoTakeOffMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingAutoTakeOffMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoTakeOffMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingAutoTakeOffMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingMoveBy (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float dX, float dY, float dZ, float dPsi)
{
    // -- Send a command <code>PilotingMoveBy</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MoveBy command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingMoveBy(cmdBuffer, sizeof(cmdBuffer), &cmdSize, dX, dY, dZ, dPsi);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingUserTakeOff (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingUserTakeOff</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserTakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingUserTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingCircle (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTING_CIRCLE_DIRECTION direction)
{
    // -- Send a command <code>PilotingCircle</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Circle command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingCircle(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingMoveTo (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude, eARCOMMANDS_ARDRONE3_PILOTING_MOVETO_ORIENTATION_MODE orientation_mode, float heading)
{
    // -- Send a command <code>PilotingMoveTo</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MoveTo command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingMoveTo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude, orientation_mode, heading);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingCancelMoveTo (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingCancelMoveTo</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CancelMoveTo command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingCancelMoveTo(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingStartPilotedPOI (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude)
{
    // -- Send a command <code>PilotingStartPilotedPOI</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartPilotedPOI command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingStartPilotedPOI(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingStopPilotedPOI (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>PilotingStopPilotedPOI</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopPilotedPOI command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingStopPilotedPOI(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAnimationsFlip (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANIMATIONS_FLIP_DIRECTION direction)
{
    // -- Send a command <code>AnimationsFlip</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Flip command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AnimationsFlip(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t tilt, int8_t pan)
{
    // -- Send a command <code>CameraOrientation</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Orientation command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraOrientation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, tilt, pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _tilt, int8_t _pan)
{
    // -- Set the parameter for the command <code>CameraOrientation</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraOrientationParameters->tilt = _tilt;
        feature->privatePart->CameraOrientationParameters->pan = _pan;

            ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ARDrone3_SendCameraOrientationStruct (ARCONTROLLER_FEATURE_ARDrone3_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>CameraOrientation</code> in project <code>ARDrone3</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Orientation command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraOrientation(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->CameraOrientationParameters->tilt, feature->privatePart->CameraOrientationParameters->pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationTilt (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _tilt)
{
    // -- Set the tilt for the command <code>CameraOrientation</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraOrientationParameters->tilt = _tilt;

        ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationPan (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _pan)
{
    // -- Set the pan for the command <code>CameraOrientation</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraOrientationParameters->pan = _pan;

        ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendCameraOrientationV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float tilt, float pan)
{
    // -- Send a command <code>CameraOrientationV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send OrientationV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraOrientationV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, tilt, pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _tilt, float _pan)
{
    // -- Set the parameter for the command <code>CameraOrientationV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationV2Parameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraOrientationV2Parameters->tilt = _tilt;
        feature->privatePart->CameraOrientationV2Parameters->pan = _pan;

            ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationV2Changed (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ARDrone3_SendCameraOrientationV2Struct (ARCONTROLLER_FEATURE_ARDrone3_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>CameraOrientationV2</code> in project <code>ARDrone3</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationV2Parameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send OrientationV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraOrientationV2(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->CameraOrientationV2Parameters->tilt, feature->privatePart->CameraOrientationV2Parameters->pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationV2Tilt (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _tilt)
{
    // -- Set the tilt for the command <code>CameraOrientationV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationV2Parameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraOrientationV2Parameters->tilt = _tilt;

        ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationV2Changed (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraOrientationV2Pan (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _pan)
{
    // -- Set the pan for the command <code>CameraOrientationV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraOrientationV2Parameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraOrientationV2Parameters->pan = _pan;

        ARCONTROLLER_NAckCbs_ARDrone3CameraOrientationV2Changed (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendCameraVelocity (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float tilt, float pan)
{
    // -- Send a command <code>CameraVelocity</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Velocity command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraVelocity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, tilt, pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraVelocity (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _tilt, float _pan)
{
    // -- Set the parameter for the command <code>CameraVelocity</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraVelocityParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraVelocityParameters->tilt = _tilt;
        feature->privatePart->CameraVelocityParameters->pan = _pan;

            ARCONTROLLER_NAckCbs_ARDrone3CameraVelocityChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ARDrone3_SendCameraVelocityStruct (ARCONTROLLER_FEATURE_ARDrone3_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>CameraVelocity</code> in project <code>ARDrone3</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraVelocityParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Velocity command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3CameraVelocity(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->CameraVelocityParameters->tilt, feature->privatePart->CameraVelocityParameters->pan);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraVelocityTilt (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _tilt)
{
    // -- Set the tilt for the command <code>CameraVelocity</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraVelocityParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraVelocityParameters->tilt = _tilt;

        ARCONTROLLER_NAckCbs_ARDrone3CameraVelocityChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetCameraVelocityPan (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _pan)
{
    // -- Set the pan for the command <code>CameraVelocity</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->CameraVelocityParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->CameraVelocityParameters->pan = _pan;

        ARCONTROLLER_NAckCbs_ARDrone3CameraVelocityChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPicture (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordPicture</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideo (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEO_RECORD record, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordVideo</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Video command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordVideo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>MediaRecordPictureV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaRecordVideoV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORD_VIDEOV2_RECORD record)
{
    // -- Send a command <code>MediaRecordVideoV2</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoV2 command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaRecordVideoV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiScan (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORK_WIFISCAN_BAND band)
{
    // -- Send a command <code>NetworkWifiScan</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiScan command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkWifiAuthChannel (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>NetworkWifiAuthChannel</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxAltitude (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxAltitude</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxTilt (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxTilt</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxTilt command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxTilt(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsAbsolutControl (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t on)
{
    // -- Send a command <code>PilotingSettingsAbsolutControl</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AbsolutControl command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsAbsolutControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, on);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMaxDistance (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsMaxDistance</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxDistance command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMaxDistance(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsNoFlyOverMaxDistance (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t shouldNotFlyOver)
{
    // -- Send a command <code>PilotingSettingsNoFlyOverMaxDistance</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send NoFlyOverMaxDistance command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsNoFlyOverMaxDistance(cmdBuffer, sizeof(cmdBuffer), &cmdSize, shouldNotFlyOver);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxHorizontalSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxHorizontalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxVerticalSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxHorizontalAcceleration command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxHorizontalAcceleration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxVerticalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxVerticalAcceleration</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxVerticalAcceleration command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxVerticalAcceleration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetAutonomousFlightMaxRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PilotingSettingsSetAutonomousFlightMaxRotationSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAutonomousFlightMaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetAutonomousFlightMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsBankedTurn (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t value)
{
    // -- Send a command <code>PilotingSettingsBankedTurn</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send BankedTurn command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsBankedTurn(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsMinAltitude (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMinAltitude</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MinAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsMinAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingDirection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_CIRCLINGDIRECTION_VALUE value)
{
    // -- Send a command <code>PilotingSettingsCirclingDirection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CirclingDirection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsCirclingDirection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingRadius (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t value)
{
    // -- Send a command <code>PilotingSettingsCirclingRadius</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CirclingRadius command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsCirclingRadius(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsCirclingAltitude (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t value)
{
    // -- Send a command <code>PilotingSettingsCirclingAltitude</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CirclingAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsCirclingAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsPitchMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGS_PITCHMODE_VALUE value)
{
    // -- Send a command <code>PilotingSettingsPitchMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PitchMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsPitchMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPilotingSettingsSetMotionDetectionMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enable)
{
    // -- Send a command <code>PilotingSettingsSetMotionDetectionMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetMotionDetectionMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PilotingSettingsSetMotionDetectionMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxVerticalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxVerticalSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxRotationSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsHullProtection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t present)
{
    // -- Send a command <code>SpeedSettingsHullProtection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send HullProtection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsHullProtection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, present);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsOutdoor (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>SpeedSettingsOutdoor</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Outdoor command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsOutdoor(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSpeedSettingsMaxPitchRollRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxPitchRollRotationSpeed</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxPitchRollRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SpeedSettingsMaxPitchRollRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>NetworkSettingsWifiSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendNetworkSettingsWifiSecurity (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_TYPE type, char * key, eARCOMMANDS_ARDRONE3_NETWORKSETTINGS_WIFISECURITY_KEYTYPE keyType)
{
    // -- Send a command <code>NetworkSettingsWifiSecurity</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSecurity command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3NetworkSettingsWifiSecurity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, key, keyType);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsPictureFormatSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_PICTUREFORMATSELECTION_TYPE type)
{
    // -- Send a command <code>PictureSettingsPictureFormatSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureFormatSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsPictureFormatSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsAutoWhiteBalanceSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_AUTOWHITEBALANCESELECTION_TYPE type)
{
    // -- Send a command <code>PictureSettingsAutoWhiteBalanceSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoWhiteBalanceSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsAutoWhiteBalanceSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsExpositionSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PictureSettingsExpositionSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ExpositionSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsExpositionSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsSaturationSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float value)
{
    // -- Send a command <code>PictureSettingsSaturationSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SaturationSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsSaturationSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsTimelapseSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enabled, float interval)
{
    // -- Send a command <code>PictureSettingsTimelapseSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TimelapseSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsTimelapseSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled, interval);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoAutorecordSelection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enabled, uint8_t mass_storage_id)
{
    // -- Send a command <code>PictureSettingsVideoAutorecordSelection</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoAutorecordSelection command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoAutorecordSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoStabilizationMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOSTABILIZATIONMODE_MODE mode)
{
    // -- Send a command <code>PictureSettingsVideoStabilizationMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoStabilizationMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoStabilizationMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoRecordingMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORECORDINGMODE_MODE mode)
{
    // -- Send a command <code>PictureSettingsVideoRecordingMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoRecordingMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoRecordingMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoFramerate (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEOFRAMERATE_FRAMERATE framerate)
{
    // -- Send a command <code>PictureSettingsVideoFramerate</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoFramerate command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoFramerate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, framerate);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendPictureSettingsVideoResolutions (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGS_VIDEORESOLUTIONS_TYPE type)
{
    // -- Send a command <code>PictureSettingsVideoResolutions</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoResolutions command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3PictureSettingsVideoResolutions(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoEnable (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t enable)
{
    // -- Send a command <code>MediaStreamingVideoEnable</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoEnable command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaStreamingVideoEnable(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendMediaStreamingVideoStreamMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIASTREAMING_VIDEOSTREAMMODE_MODE mode)
{
    // -- Send a command <code>MediaStreamingVideoStreamMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoStreamMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3MediaStreamingVideoStreamMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSetHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude)
{
    // -- Send a command <code>GPSSettingsSetHome</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsSetHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsResetHome (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>GPSSettingsResetHome</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetHome command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsResetHome(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsSendControllerGPS (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double latitude, double longitude, double altitude, double horizontalAccuracy, double verticalAccuracy)
{
    // -- Send a command <code>GPSSettingsSendControllerGPS</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SendControllerGPS command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsSendControllerGPS(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude, horizontalAccuracy, verticalAccuracy);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsHomeType (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSETTINGS_HOMETYPE_TYPE type)
{
    // -- Send a command <code>GPSSettingsHomeType</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send HomeType command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsHomeType(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendGPSSettingsReturnHomeDelay (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t delay)
{
    // -- Send a command <code>GPSSettingsReturnHomeDelay</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ReturnHomeDelay command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3GPSSettingsReturnHomeDelay(cmdBuffer, sizeof(cmdBuffer), &cmdSize, delay);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringElectricFrequency (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERING_ELECTRICFREQUENCY_FREQUENCY frequency)
{
    // -- Send a command <code>AntiflickeringElectricFrequency</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ElectricFrequency command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AntiflickeringElectricFrequency(cmdBuffer, sizeof(cmdBuffer), &cmdSize, frequency);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendAntiflickeringSetMode (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERING_SETMODE_MODE mode)
{
    // -- Send a command <code>AntiflickeringSetMode</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetMode command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3AntiflickeringSetMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSoundStartAlertSound (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>SoundStartAlertSound</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartAlertSound command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SoundStartAlertSound(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SendSoundStopAlertSound (ARCONTROLLER_FEATURE_ARDrone3_t *feature)
{
    // -- Send a command <code>SoundStopAlertSound</code> in project <code>ARDrone3</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopAlertSound command
        cmdError = ARCOMMANDS_Generator_GenerateARDrone3SoundStopAlertSound(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoStateChangedV2Callback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordStateVideoResolutionStateCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING _streaming, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING _recording, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoResolutionState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoResolutionState (feature,  _streaming,  _recording, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventPictureEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventPictureEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaRecordEventVideoEventChangedCallback (eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventVideoEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventVideoEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlatTrimChangedCallback (void *customData)
{
    // -- callback used when the command <code>PilotingStateFlatTrimChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLATTRIMCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlatTrimChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlyingStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAlertStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAlertStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAlertStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateNavigateHomeStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason, void *customData)
{
    // -- callback used when the command <code>PilotingStateNavigateHomeStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateNavigateHomeStateChanged (feature,  _state,  _reason, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePositionChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>PilotingStatePositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStatePositionChanged (feature,  _latitude,  _longitude,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateSpeedChangedCallback (float _speedX, float _speedY, float _speedZ, void *customData)
{
    // -- callback used when the command <code>PilotingStateSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateSpeedChanged (feature,  _speedX,  _speedY,  _speedZ, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAttitudeChangedCallback (float _roll, float _pitch, float _yaw, void *customData)
{
    // -- callback used when the command <code>PilotingStateAttitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAttitudeChanged (feature,  _roll,  _pitch,  _yaw, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAutoTakeOffModeChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAutoTakeOffModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAutoTakeOffModeChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAltitudeChangedCallback (double _altitude, void *customData)
{
    // -- callback used when the command <code>PilotingStateAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAltitudeChanged (feature,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateGpsLocationChangedCallback (double _latitude, double _longitude, double _altitude, int8_t _latitude_accuracy, int8_t _longitude_accuracy, int8_t _altitude_accuracy, void *customData)
{
    // -- callback used when the command <code>PilotingStateGpsLocationChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateGpsLocationChanged (feature,  _latitude,  _longitude,  _altitude,  _latitude_accuracy,  _longitude_accuracy,  _altitude_accuracy, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateLandingStateChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateLandingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateLandingStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateAirSpeedChangedCallback (float _airSpeed, void *customData)
{
    // -- callback used when the command <code>PilotingStateAirSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AIRSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAirSpeedChanged (feature,  _airSpeed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateMoveToChangedCallback (double _latitude, double _longitude, double _altitude, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ORIENTATION_MODE _orientation_mode, float _heading, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_STATUS _status, void *customData)
{
    // -- callback used when the command <code>PilotingStateMoveToChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateMoveToChanged (feature,  _latitude,  _longitude,  _altitude,  _orientation_mode,  _heading,  _status, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateMotionStateCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_MOTIONSTATE_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateMotionState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOTIONSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateMotionState (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStatePilotedPOICallback (double _latitude, double _longitude, double _altitude, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_STATUS _status, void *customData)
{
    // -- callback used when the command <code>PilotingStatePilotedPOI</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStatePilotedPOI (feature,  _latitude,  _longitude,  _altitude,  _status, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingStateReturnHomeBatteryCapacityCallback (eARCOMMANDS_ARDRONE3_PILOTINGSTATE_RETURNHOMEBATTERYCAPACITY_STATUS _status, void *customData)
{
    // -- callback used when the command <code>PilotingStateReturnHomeBatteryCapacity</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_RETURNHOMEBATTERYCAPACITY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateReturnHomeBatteryCapacity (feature,  _status, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingEventMoveByEndCallback (float _dX, float _dY, float _dZ, float _dPsi, eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR _error, void *customData)
{
    // -- callback used when the command <code>PilotingEventMoveByEnd</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingEventMoveByEnd (feature,  _dX,  _dY,  _dZ,  _dPsi,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiScanListChangedCallback (const char * _ssid, int16_t _rssi, eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiScanListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiScanListChanged (feature,  _ssid,  _rssi,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiScanChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiScanChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFISCANCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiScanChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateWifiAuthChannelListChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiAuthChannelListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiAuthChannelListChanged (feature,  _band,  _channel,  _in_or_out, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiAuthChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiAuthChannelChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxTiltChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxTiltChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxTiltChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAbsolutControlChangedCallback (uint8_t _on, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAbsolutControlChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAbsolutControlChanged (feature,  _on, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMaxDistanceChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxDistanceChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxDistanceChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateNoFlyOverMaxDistanceChangedCallback (uint8_t _shouldNotFlyOver, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateNoFlyOverMaxDistanceChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateNoFlyOverMaxDistanceChanged (feature,  _shouldNotFlyOver, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalSpeedCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxHorizontalSpeed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalSpeed (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalSpeedCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxVerticalSpeed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALSPEED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalSpeed (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxHorizontalAccelerationCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxVerticalAccelerationCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxVerticalAcceleration</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalAcceleration (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateAutonomousFlightMaxRotationSpeedCallback (float _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateAutonomousFlightMaxRotationSpeed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXROTATIONSPEED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxRotationSpeed (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateBankedTurnChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateBankedTurnChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateBankedTurnChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMinAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMinAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMinAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingDirectionChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateCirclingDirectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingDirectionChanged (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingRadiusChangedCallback (uint16_t _current, uint16_t _min, uint16_t _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateCirclingRadiusChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingRadiusChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateCirclingAltitudeChangedCallback (uint16_t _current, uint16_t _min, uint16_t _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateCirclingAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStatePitchModeChangedCallback (eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE _value, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStatePitchModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStatePitchModeChanged (feature,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PilotingSettingsStateMotionDetectionCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMotionDetection</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MOTIONDETECTION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMotionDetection (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxVerticalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxVerticalSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxRotationSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateHullProtectionChangedCallback (uint8_t _present, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateHullProtectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateHullProtectionChanged (feature,  _present, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateOutdoorChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateOutdoorChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateOutdoorChanged (feature,  _outdoor, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SpeedSettingsStateMaxPitchRollRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxPitchRollRotationSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxPitchRollRotationSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSelectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSelectionChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityChangedCallback (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSecurityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurityChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_NetworkSettingsStateWifiSecurityCallback (eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE _type, const char * _key, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE _keyType, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSecurity</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurity (feature,  _type,  _key,  _keyType, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductMotorVersionListChangedCallback (uint8_t _motor_number, const char * _type, const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductMotorVersionListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductMotorVersionListChanged (feature,  _motor_number,  _type,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateProductGPSVersionChangedCallback (const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductGPSVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductGPSVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorStateChangedCallback (uint8_t _motorIds, eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorErrorStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorStateChanged (feature,  _motorIds,  _motorError, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorSoftwareVersionChangedCallback (const char * _version, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorSoftwareVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorSoftwareVersionChanged (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorFlightsStatusChangedCallback (uint16_t _nbFlights, uint16_t _lastFlightDuration, uint32_t _totalFlightDuration, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorFlightsStatusChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorFlightsStatusChanged (feature,  _nbFlights,  _lastFlightDuration,  _totalFlightDuration, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateMotorErrorLastErrorChangedCallback (eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError, void *customData)
{
    // -- callback used when the command <code>SettingsStateMotorErrorLastErrorChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorLastErrorChanged (feature,  _motorError, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateP7IDCallback (const char * _serialID, void *customData)
{
    // -- callback used when the command <code>SettingsStateP7ID</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateP7ID (feature,  _serialID, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SettingsStateCPUIDCallback (const char * _id, void *customData)
{
    // -- callback used when the command <code>SettingsStateCPUID</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_CPUID;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateCPUID (feature,  _id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStatePictureFormatChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStatePictureFormatChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStatePictureFormatChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateAutoWhiteBalanceChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateAutoWhiteBalanceChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateAutoWhiteBalanceChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateExpositionChangedCallback (float _value, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateExpositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateExpositionChanged (feature,  _value,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateSaturationChangedCallback (float _value, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateSaturationChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateSaturationChanged (feature,  _value,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateTimelapseChangedCallback (uint8_t _enabled, float _interval, float _minInterval, float _maxInterval, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateTimelapseChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateTimelapseChanged (feature,  _enabled,  _interval,  _minInterval,  _maxInterval, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoAutorecordChangedCallback (uint8_t _enabled, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateVideoAutorecordChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoAutorecordChanged (feature,  _enabled,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoStabilizationModeChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateVideoStabilizationModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoStabilizationModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoRecordingModeChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateVideoRecordingModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoRecordingModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoFramerateChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE _framerate, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateVideoFramerateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoFramerateChanged (feature,  _framerate, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PictureSettingsStateVideoResolutionsChangedCallback (eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>PictureSettingsStateVideoResolutionsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoResolutionsChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoEnableChangedCallback (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, void *customData)
{
    // -- callback used when the command <code>MediaStreamingStateVideoEnableChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaStreamingStateVideoEnableChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_MediaStreamingStateVideoStreamModeChangedCallback (eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>MediaStreamingStateVideoStreamModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementMediaStreamingStateVideoStreamModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateHomeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeChanged (feature,  _latitude,  _longitude,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateResetHomeChangedCallback (double _latitude, double _longitude, double _altitude, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateResetHomeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateResetHomeChanged (feature,  _latitude,  _longitude,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSFixStateChangedCallback (uint8_t _fixed, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateGPSFixStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSFixStateChanged (feature,  _fixed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGPSUpdateStateChangedCallback (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateGPSUpdateStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSUpdateStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateHomeTypeChangedCallback (eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateHomeTypeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeTypeChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateReturnHomeDelayChangedCallback (uint16_t _delay, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateReturnHomeDelayChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateReturnHomeDelayChanged (feature,  _delay, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSSettingsStateGeofenceCenterChangedCallback (double _latitude, double _longitude, void *customData)
{
    // -- callback used when the command <code>GPSSettingsStateGeofenceCenterChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GEOFENCECENTERCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGeofenceCenterChanged (feature,  _latitude,  _longitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationCallback (int8_t _tilt, int8_t _pan, void *customData)
{
    // -- callback used when the command <code>CameraStateOrientation</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementCameraStateOrientation (feature,  _tilt,  _pan, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateDefaultCameraOrientationCallback (int8_t _tilt, int8_t _pan, void *customData)
{
    // -- callback used when the command <code>CameraStateDefaultCameraOrientation</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementCameraStateDefaultCameraOrientation (feature,  _tilt,  _pan, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateOrientationV2Callback (float _tilt, float _pan, void *customData)
{
    // -- callback used when the command <code>CameraStateOrientationV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementCameraStateOrientationV2 (feature,  _tilt,  _pan, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateDefaultCameraOrientationV2Callback (float _tilt, float _pan, void *customData)
{
    // -- callback used when the command <code>CameraStateDefaultCameraOrientationV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementCameraStateDefaultCameraOrientationV2 (feature,  _tilt,  _pan, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_CameraStateVelocityRangeCallback (float _max_tilt, float _max_pan, void *customData)
{
    // -- callback used when the command <code>CameraStateVelocityRange</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementCameraStateVelocityRange (feature,  _max_tilt,  _max_pan, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateElectricFrequencyChangedCallback (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency, void *customData)
{
    // -- callback used when the command <code>AntiflickeringStateElectricFrequencyChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateElectricFrequencyChanged (feature,  _frequency, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_AntiflickeringStateModeChangedCallback (eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>AntiflickeringStateModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateNumberOfSatelliteChangedCallback (uint8_t _numberOfSatellite, void *customData)
{
    // -- callback used when the command <code>GPSStateNumberOfSatelliteChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSStateNumberOfSatelliteChanged (feature,  _numberOfSatellite, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeAvailabilityChangedCallback (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type, uint8_t _available, void *customData)
{
    // -- callback used when the command <code>GPSStateHomeTypeAvailabilityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeAvailabilityChanged (feature,  _type,  _available, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_GPSStateHomeTypeChosenChangedCallback (eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>GPSStateHomeTypeChosenChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeChosenChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_PROStateFeaturesCallback (uint64_t _features, void *customData)
{
    // -- callback used when the command <code>PROStateFeatures</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementPROStateFeatures (feature,  _features, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_AccessoryStateConnectedAccessoriesCallback (uint8_t _id, eARCOMMANDS_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ACCESSORY_TYPE _accessory_type, const char * _uid, const char * _swVersion, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>AccessoryStateConnectedAccessories</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_ARDrone3_NewCmdElementAccessoryStateConnectedAccessories (feature, _id,  _accessory_type,  _uid,  _swVersion,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_AccessoryStateBatteryCallback (uint8_t _id, uint8_t _batteryLevel, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>AccessoryStateBattery</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_BATTERY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_ARDrone3_NewCmdElementAccessoryStateBattery (feature, _id,  _batteryLevel,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ARDrone3_SoundStateAlertSoundCallback (eARCOMMANDS_ARDRONE3_SOUNDSTATE_ALERTSOUND_STATE _state, void *customData)
{
    // -- callback used when the command <code>SoundStateAlertSound</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ARDrone3_t *feature = (ARCONTROLLER_FEATURE_ARDrone3_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SOUNDSTATE_ALERTSOUND;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_ARDrone3_NewCmdElementSoundStateAlertSound (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStatePictureStateChangedV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoStateChangedV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordStateVideoResolutionState (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING _streaming, eARCOMMANDS_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING _recording, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoResolutionState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_STREAMING;
            argDictNewElement->value.I32 = _streaming;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDSTATE_VIDEORESOLUTIONSTATE_RECORDING;
            argDictNewElement->value.I32 = _recording;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventPictureEventChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventPictureEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaRecordEventVideoEventChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventVideoEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlatTrimChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlatTrimChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateFlyingStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAlertStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAlertStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateNavigateHomeStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE _state, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON _reason, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateNavigateHomeStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_NAVIGATEHOMESTATECHANGED_REASON;
            argDictNewElement->value.I32 = _reason;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStatePositionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStatePositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_POSITIONCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _speedX, float _speedY, float _speedZ, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDX;
            argDictNewElement->value.Float = _speedX;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDY;
            argDictNewElement->value.Float = _speedY;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_SPEEDCHANGED_SPEEDZ;
            argDictNewElement->value.Float = _speedZ;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAttitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _roll, float _pitch, float _yaw, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAttitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_ROLL;
            argDictNewElement->value.Float = _roll;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_PITCH;
            argDictNewElement->value.Float = _pitch;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ATTITUDECHANGED_YAW;
            argDictNewElement->value.Float = _yaw;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAutoTakeOffModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAutoTakeOffModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateGpsLocationChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, int8_t _latitude_accuracy, int8_t _longitude_accuracy, int8_t _altitude_accuracy, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateGpsLocationChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LATITUDE_ACCURACY;
            argDictNewElement->value.I8 = _latitude_accuracy;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_LONGITUDE_ACCURACY;
            argDictNewElement->value.I8 = _longitude_accuracy;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_GPSLOCATIONCHANGED_ALTITUDE_ACCURACY;
            argDictNewElement->value.I8 = _altitude_accuracy;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateLandingStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateLandingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_LANDINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateAirSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _airSpeed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAirSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_AIRSPEEDCHANGED_AIRSPEED;
            argDictNewElement->value.Float = _airSpeed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateMoveToChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ORIENTATION_MODE _orientation_mode, float _heading, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_STATUS _status, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateMoveToChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_ORIENTATION_MODE;
            argDictNewElement->value.I32 = _orientation_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_HEADING;
            argDictNewElement->value.Float = _heading;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOVETOCHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateMotionState (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_MOTIONSTATE_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateMotionState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_MOTIONSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStatePilotedPOI (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_STATUS _status, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStatePilotedPOI -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_PILOTEDPOI_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingStateReturnHomeBatteryCapacity (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSTATE_RETURNHOMEBATTERYCAPACITY_STATUS _status, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateReturnHomeBatteryCapacity -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSTATE_RETURNHOMEBATTERYCAPACITY_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingEventMoveByEnd (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _dX, float _dY, float _dZ, float _dPsi, eARCOMMANDS_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingEventMoveByEnd -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DX;
            argDictNewElement->value.Float = _dX;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DY;
            argDictNewElement->value.Float = _dY;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DZ;
            argDictNewElement->value.Float = _dZ;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_DPSI;
            argDictNewElement->value.Float = _dPsi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGEVENT_MOVEBYEND_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiScanListChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, const char * _ssid, int16_t _rssi, eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiScanListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiScanChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiScanChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateWifiAuthChannelListChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiAuthChannelListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkStateAllWifiAuthChannelChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiAuthChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxTiltChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxTiltChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAbsolutControlChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _on, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAbsolutControlChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_ABSOLUTCONTROLCHANGED_ON;
            argDictNewElement->value.U8 = _on;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMaxDistanceChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxDistanceChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MAXDISTANCECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateNoFlyOverMaxDistanceChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _shouldNotFlyOver, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateNoFlyOverMaxDistanceChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_NOFLYOVERMAXDISTANCECHANGED_SHOULDNOTFLYOVER;
            argDictNewElement->value.U8 = _shouldNotFlyOver;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxHorizontalSpeed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALSPEED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxVerticalSpeed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALSPEED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxHorizontalAcceleration -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXHORIZONTALACCELERATION_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxVerticalAcceleration (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxVerticalAcceleration -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXVERTICALACCELERATION_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateAutonomousFlightMaxRotationSpeed (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateAutonomousFlightMaxRotationSpeed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_AUTONOMOUSFLIGHTMAXROTATIONSPEED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateBankedTurnChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateBankedTurnChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMinAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMinAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MINALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingDirectionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateCirclingDirectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGDIRECTIONCHANGED_VALUE;
            argDictNewElement->value.I32 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingRadiusChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _current, uint16_t _min, uint16_t _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateCirclingRadiusChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_CURRENT;
            argDictNewElement->value.U16 = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MIN;
            argDictNewElement->value.U16 = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGRADIUSCHANGED_MAX;
            argDictNewElement->value.U16 = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateCirclingAltitudeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _current, uint16_t _min, uint16_t _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateCirclingAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_CURRENT;
            argDictNewElement->value.U16 = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MIN;
            argDictNewElement->value.U16 = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_CIRCLINGALTITUDECHANGED_MAX;
            argDictNewElement->value.U16 = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStatePitchModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStatePitchModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_PITCHMODECHANGED_VALUE;
            argDictNewElement->value.I32 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPilotingSettingsStateMotionDetection (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMotionDetection -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PILOTINGSETTINGSSTATE_MOTIONDETECTION_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxVerticalSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxRotationSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateHullProtectionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _present, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateHullProtectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_HULLPROTECTIONCHANGED_PRESENT;
            argDictNewElement->value.U8 = _present;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateOutdoorChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _outdoor, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateOutdoorChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSpeedSettingsStateMaxPitchRollRotationSpeedChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxPitchRollRotationSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SPEEDSETTINGSSTATE_MAXPITCHROLLROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSelectionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSelectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurityChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSecurityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITYCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementNetworkSettingsStateWifiSecurity (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE _type, const char * _key, eARCOMMANDS_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE _keyType, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSecurity -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEY;
            strLength = strlen (_key);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _key, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_NETWORKSETTINGSSTATE_WIFISECURITY_KEYTYPE;
            argDictNewElement->value.I32 = _keyType;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductMotorVersionListChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _motor_number, const char * _type, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductMotorVersionListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _motor_number);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _motor_number);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_MOTOR_NUMBER;
            argDictNewElement->value.U8 = _motor_number;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_TYPE;
            strLength = strlen (_type);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _type, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTMOTORVERSIONLISTCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateProductGPSVersionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductGPSVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _motorIds, eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR _motorError, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorErrorStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORIDS;
            argDictNewElement->value.U8 = _motorIds;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORSTATECHANGED_MOTORERROR;
            argDictNewElement->value.I32 = _motorError;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorSoftwareVersionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, const char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorSoftwareVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORSOFTWAREVERSIONCHANGED_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorFlightsStatusChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _nbFlights, uint16_t _lastFlightDuration, uint32_t _totalFlightDuration, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorFlightsStatusChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_NBFLIGHTS;
            argDictNewElement->value.U16 = _nbFlights;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_LASTFLIGHTDURATION;
            argDictNewElement->value.U16 = _lastFlightDuration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORFLIGHTSSTATUSCHANGED_TOTALFLIGHTDURATION;
            argDictNewElement->value.U32 = _totalFlightDuration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateMotorErrorLastErrorChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR _motorError, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateMotorErrorLastErrorChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_MOTORERRORLASTERRORCHANGED_MOTORERROR;
            argDictNewElement->value.I32 = _motorError;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateP7ID (ARCONTROLLER_FEATURE_ARDrone3_t *feature, const char * _serialID, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateP7ID -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_P7ID_SERIALID;
            strLength = strlen (_serialID);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serialID, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSettingsStateCPUID (ARCONTROLLER_FEATURE_ARDrone3_t *feature, const char * _id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateCPUID -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SETTINGSSTATE_CPUID_ID;
            strLength = strlen (_id);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _id, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStatePictureFormatChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStatePictureFormatChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_PICTUREFORMATCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateAutoWhiteBalanceChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateAutoWhiteBalanceChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_AUTOWHITEBALANCECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateExpositionChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateExpositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_EXPOSITIONCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateSaturationChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _value, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateSaturationChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_VALUE;
            argDictNewElement->value.Float = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_SATURATIONCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateTimelapseChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _enabled, float _interval, float _minInterval, float _maxInterval, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateTimelapseChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_INTERVAL;
            argDictNewElement->value.Float = _interval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MININTERVAL;
            argDictNewElement->value.Float = _minInterval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_TIMELAPSECHANGED_MAXINTERVAL;
            argDictNewElement->value.Float = _maxInterval;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoAutorecordChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _enabled, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateVideoAutorecordChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOAUTORECORDCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoStabilizationModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateVideoStabilizationModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOSTABILIZATIONMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoRecordingModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateVideoRecordingModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORECORDINGMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoFramerateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE _framerate, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateVideoFramerateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEOFRAMERATECHANGED_FRAMERATE;
            argDictNewElement->value.I32 = _framerate;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPictureSettingsStateVideoResolutionsChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PictureSettingsStateVideoResolutionsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PICTURESETTINGSSTATE_VIDEORESOLUTIONSCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaStreamingStateVideoEnableChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaStreamingStateVideoEnableChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED;
            argDictNewElement->value.I32 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementMediaStreamingStateVideoStreamModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaStreamingStateVideoStreamModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_MEDIASTREAMINGSTATE_VIDEOSTREAMMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateHomeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateResetHomeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, double _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateResetHomeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RESETHOMECHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSFixStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _fixed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateGPSFixStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSFIXSTATECHANGED_FIXED;
            argDictNewElement->value.U8 = _fixed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGPSUpdateStateChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateGPSUpdateStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GPSUPDATESTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateHomeTypeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateHomeTypeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_HOMETYPECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateReturnHomeDelayChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint16_t _delay, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateReturnHomeDelayChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_RETURNHOMEDELAYCHANGED_DELAY;
            argDictNewElement->value.U16 = _delay;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSSettingsStateGeofenceCenterChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, double _latitude, double _longitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSSettingsStateGeofenceCenterChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GEOFENCECENTERCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSETTINGSSTATE_GEOFENCECENTERCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementCameraStateOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _tilt, int8_t _pan, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraStateOrientation -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_TILT;
            argDictNewElement->value.I8 = _tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATION_PAN;
            argDictNewElement->value.I8 = _pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementCameraStateDefaultCameraOrientation (ARCONTROLLER_FEATURE_ARDrone3_t *feature, int8_t _tilt, int8_t _pan, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraStateDefaultCameraOrientation -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_TILT;
            argDictNewElement->value.I8 = _tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATION_PAN;
            argDictNewElement->value.I8 = _pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementCameraStateOrientationV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _tilt, float _pan, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraStateOrientationV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2_TILT;
            argDictNewElement->value.Float = _tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_ORIENTATIONV2_PAN;
            argDictNewElement->value.Float = _pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementCameraStateDefaultCameraOrientationV2 (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _tilt, float _pan, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraStateDefaultCameraOrientationV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2_TILT;
            argDictNewElement->value.Float = _tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_DEFAULTCAMERAORIENTATIONV2_PAN;
            argDictNewElement->value.Float = _pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementCameraStateVelocityRange (ARCONTROLLER_FEATURE_ARDrone3_t *feature, float _max_tilt, float _max_pan, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraStateVelocityRange -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE_MAX_TILT;
            argDictNewElement->value.Float = _max_tilt;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_CAMERASTATE_VELOCITYRANGE_MAX_PAN;
            argDictNewElement->value.Float = _max_pan;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateElectricFrequencyChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AntiflickeringStateElectricFrequencyChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY;
            argDictNewElement->value.I32 = _frequency;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementAntiflickeringStateModeChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AntiflickeringStateModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ANTIFLICKERINGSTATE_MODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSStateNumberOfSatelliteChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _numberOfSatellite, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSStateNumberOfSatelliteChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_NUMBEROFSATELLITECHANGED_NUMBEROFSATELLITE;
            argDictNewElement->value.U8 = _numberOfSatellite;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeAvailabilityChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE _type, uint8_t _available, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSStateHomeTypeAvailabilityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _type);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _type);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPEAVAILABILITYCHANGED_AVAILABLE;
            argDictNewElement->value.U8 = _available;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementGPSStateHomeTypeChosenChanged (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GPSStateHomeTypeChosenChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_GPSSTATE_HOMETYPECHOSENCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementPROStateFeatures (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint64_t _features, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PROStateFeatures -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_PROSTATE_FEATURES_FEATURES;
            argDictNewElement->value.U64 = _features;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementAccessoryStateConnectedAccessories (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _id, eARCOMMANDS_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ACCESSORY_TYPE _accessory_type, const char * _uid, const char * _swVersion, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateConnectedAccessories -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_ACCESSORY_TYPE;
            argDictNewElement->value.I32 = _accessory_type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_UID;
            strLength = strlen (_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_CONNECTEDACCESSORIES_SWVERSION;
            strLength = strlen (_swVersion);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _swVersion, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementAccessoryStateBattery (ARCONTROLLER_FEATURE_ARDrone3_t *feature, uint8_t _id, uint8_t _batteryLevel, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateBattery -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_BATTERY_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_ACCESSORYSTATE_BATTERY_BATTERYLEVEL;
            argDictNewElement->value.U8 = _batteryLevel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_NewCmdElementSoundStateAlertSound (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCOMMANDS_ARDRONE3_SOUNDSTATE_ALERTSOUND_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SoundStateAlertSound -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_ARDRONE3_SOUNDSTATE_ALERTSOUND_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ARDrone3_SetNetworkController (ARCONTROLLER_FEATURE_ARDrone3_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ARDrone3_GetCommandElements (ARCONTROLLER_FEATURE_ARDrone3_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE common --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE = "arcontroller_dictionary_key_common_networkevent_disconnection_cause";



const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED_NAME = "arcontroller_dictionary_key_common_settingsstate_productnamechanged_name";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_common_settingsstate_productversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_common_settingsstate_productversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED_HIGH = "arcontroller_dictionary_key_common_settingsstate_productserialhighchanged_high";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED_LOW = "arcontroller_dictionary_key_common_settingsstate_productseriallowchanged_low";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED_CODE = "arcontroller_dictionary_key_common_settingsstate_countrychanged_code";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED_AUTOMATIC = "arcontroller_dictionary_key_common_settingsstate_autocountrychanged_automatic";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT = "arcontroller_dictionary_key_common_commonstate_batterystatechanged_percent";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstoragestatelistchanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_NAME = "arcontroller_dictionary_key_common_commonstate_massstoragestatelistchanged_name";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_SIZE = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_size";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_USED_SIZE = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_used_size";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_PLUGGED = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_plugged";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_FULL = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_full";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_INTERNAL = "arcontroller_dictionary_key_common_commonstate_massstorageinfostatelistchanged_internal";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED_DATE = "arcontroller_dictionary_key_common_commonstate_currentdatechanged_date";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED_TIME = "arcontroller_dictionary_key_common_commonstate_currenttimechanged_time";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_FREE_SPACE = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_free_space";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_REC_TIME = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_rec_time";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_PHOTO_REMAINING = "arcontroller_dictionary_key_common_commonstate_massstorageinforemaininglistchanged_photo_remaining";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED_RSSI = "arcontroller_dictionary_key_common_commonstate_wifisignalchanged_rssi";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME = "arcontroller_dictionary_key_common_commonstate_sensorsstateslistchanged_sensorname";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORSTATE = "arcontroller_dictionary_key_common_commonstate_sensorsstateslistchanged_sensorstate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL = "arcontroller_dictionary_key_common_commonstate_productmodel_model";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_LISTFLAGS = "arcontroller_dictionary_key_common_commonstate_countrylistknown_listflags";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_COUNTRYCODES = "arcontroller_dictionary_key_common_commonstate_countrylistknown_countrycodes";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_deprecatedmassstoragecontentchanged_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBPHOTOS = "arcontroller_dictionary_key_common_commonstate_deprecatedmassstoragecontentchanged_nbphotos";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBVIDEOS = "arcontroller_dictionary_key_common_commonstate_deprecatedmassstoragecontentchanged_nbvideos";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBPUDS = "arcontroller_dictionary_key_common_commonstate_deprecatedmassstoragecontentchanged_nbpuds";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBCRASHLOGS = "arcontroller_dictionary_key_common_commonstate_deprecatedmassstoragecontentchanged_nbcrashlogs";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstoragecontent_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBPHOTOS = "arcontroller_dictionary_key_common_commonstate_massstoragecontent_nbphotos";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBVIDEOS = "arcontroller_dictionary_key_common_commonstate_massstoragecontent_nbvideos";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBPUDS = "arcontroller_dictionary_key_common_commonstate_massstoragecontent_nbpuds";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBCRASHLOGS = "arcontroller_dictionary_key_common_commonstate_massstoragecontent_nbcrashlogs";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBRAWPHOTOS = "arcontroller_dictionary_key_common_commonstate_massstoragecontent_nbrawphotos";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_MASS_STORAGE_ID = "arcontroller_dictionary_key_common_commonstate_massstoragecontentforcurrentrun_mass_storage_id";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_NBPHOTOS = "arcontroller_dictionary_key_common_commonstate_massstoragecontentforcurrentrun_nbphotos";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_NBVIDEOS = "arcontroller_dictionary_key_common_commonstate_massstoragecontentforcurrentrun_nbvideos";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_NBRAWPHOTOS = "arcontroller_dictionary_key_common_commonstate_massstoragecontentforcurrentrun_nbrawphotos";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_VIDEORECORDINGTIMESTAMP_STARTTIMESTAMP = "arcontroller_dictionary_key_common_commonstate_videorecordingtimestamp_starttimestamp";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_VIDEORECORDINGTIMESTAMP_STOPTIMESTAMP = "arcontroller_dictionary_key_common_commonstate_videorecordingtimestamp_stoptimestamp";


const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED_REGULATIONTYPE = "arcontroller_dictionary_key_common_overheatstate_overheatregulationchanged_regulationtype";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED_OUTDOOR = "arcontroller_dictionary_key_common_wifisettingsstate_outdoorsettingschanged_outdoor";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_FILEPATH = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_filepath";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkfileplayingstatechanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR = "arcontroller_dictionary_key_common_mavlinkstate_mavlinkplayerrorstatechanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MISSIONITEMEXECUTED_IDX = "arcontroller_dictionary_key_common_mavlinkstate_missionitemexecuted_idx";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSETTINGSSTATE_RETURNHOMEONDISCONNECTCHANGED_STATE = "arcontroller_dictionary_key_common_flightplansettingsstate_returnhomeondisconnectchanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSETTINGSSTATE_RETURNHOMEONDISCONNECTCHANGED_ISREADONLY = "arcontroller_dictionary_key_common_flightplansettingsstate_returnhomeondisconnectchanged_isreadonly";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_XAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_xaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_YAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_yaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_ZAXISCALIBRATION = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_zaxiscalibration";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_CALIBRATIONFAILED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstatechanged_calibrationfailed";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE_REQUIRED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationrequiredstate_required";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationaxistocalibratechanged_axis";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED_STARTED = "arcontroller_dictionary_key_common_calibrationstate_magnetocalibrationstartedchanged_started";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE = "arcontroller_dictionary_key_common_calibrationstate_pitotcalibrationstatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_LASTERROR = "arcontroller_dictionary_key_common_calibrationstate_pitotcalibrationstatechanged_lasterror";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_FOV = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_fov";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMAX = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_panmax";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMIN = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_panmin";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMAX = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_tiltmax";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMIN = "arcontroller_dictionary_key_common_camerasettingsstate_camerasettingschanged_tiltmin";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED_AVAILABILITYSTATE = "arcontroller_dictionary_key_common_flightplanstate_availabilitystatechanged_availabilitystate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT = "arcontroller_dictionary_key_common_flightplanstate_componentstatelistchanged_component";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_STATE = "arcontroller_dictionary_key_common_flightplanstate_componentstatelistchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_LOCKSTATECHANGED_LOCKSTATE = "arcontroller_dictionary_key_common_flightplanstate_lockstatechanged_lockstate";



const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_controllerlibarcommandsversion_version";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_skycontrollerlibarcommandsversion_version";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION_VERSION = "arcontroller_dictionary_key_common_arlibsversionsstate_devicelibarcommandsversion_version";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING_RUNNING = "arcontroller_dictionary_key_common_audiostate_audiostreamingrunning_running";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_LEFT = "arcontroller_dictionary_key_common_headlightsstate_intensitychanged_left";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_RIGHT = "arcontroller_dictionary_key_common_headlightsstate_intensitychanged_right";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ANIM = "arcontroller_dictionary_key_common_animationsstate_list_anim";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_STATE = "arcontroller_dictionary_key_common_animationsstate_list_state";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ERROR = "arcontroller_dictionary_key_common_animationsstate_list_error";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY = "arcontroller_dictionary_key_common_accessorystate_supportedaccessorieslistchanged_accessory";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY = "arcontroller_dictionary_key_common_accessorystate_accessoryconfigchanged_newaccessory";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR = "arcontroller_dictionary_key_common_accessorystate_accessoryconfigchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED_ENABLED = "arcontroller_dictionary_key_common_accessorystate_accessoryconfigmodificationenabled_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE = "arcontroller_dictionary_key_common_chargerstate_maxchargeratechanged_rate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS = "arcontroller_dictionary_key_common_chargerstate_currentchargestatechanged_status";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE = "arcontroller_dictionary_key_common_chargerstate_currentchargestatechanged_phase";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE = "arcontroller_dictionary_key_common_chargerstate_lastchargeratechanged_rate";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE = "arcontroller_dictionary_key_common_chargerstate_charginginfo_phase";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_RATE = "arcontroller_dictionary_key_common_chargerstate_charginginfo_rate";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_INTENSITY = "arcontroller_dictionary_key_common_chargerstate_charginginfo_intensity";
const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_FULLCHARGINGTIME = "arcontroller_dictionary_key_common_chargerstate_charginginfo_fullchargingtime";

const char *ARCONTROLLER_DICTIONARY_KEY_COMMON_RUNSTATE_RUNIDCHANGED_RUNID = "arcontroller_dictionary_key_common_runstate_runidchanged_runid";

ARCONTROLLER_FEATURE_Common_t *ARCONTROLLER_FEATURE_Common_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Common_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Common_t));
        if (featureController != NULL)
        {
            featureController->sendNetworkDisconnect = ARCONTROLLER_FEATURE_Common_SendNetworkDisconnect;
            featureController->sendSettingsAllSettings = ARCONTROLLER_FEATURE_Common_SendSettingsAllSettings;
            featureController->sendSettingsReset = ARCONTROLLER_FEATURE_Common_SendSettingsReset;
            featureController->sendSettingsProductName = ARCONTROLLER_FEATURE_Common_SendSettingsProductName;
            featureController->sendSettingsCountry = ARCONTROLLER_FEATURE_Common_SendSettingsCountry;
            featureController->sendSettingsAutoCountry = ARCONTROLLER_FEATURE_Common_SendSettingsAutoCountry;
            featureController->sendCommonAllStates = ARCONTROLLER_FEATURE_Common_SendCommonAllStates;
            featureController->sendCommonCurrentDate = ARCONTROLLER_FEATURE_Common_SendCommonCurrentDate;
            featureController->sendCommonCurrentTime = ARCONTROLLER_FEATURE_Common_SendCommonCurrentTime;
            featureController->sendCommonReboot = ARCONTROLLER_FEATURE_Common_SendCommonReboot;
            featureController->sendOverHeatSwitchOff = ARCONTROLLER_FEATURE_Common_SendOverHeatSwitchOff;
            featureController->sendOverHeatVentilate = ARCONTROLLER_FEATURE_Common_SendOverHeatVentilate;
            featureController->sendControllerIsPiloting = ARCONTROLLER_FEATURE_Common_SendControllerIsPiloting;
            featureController->sendWifiSettingsOutdoorSetting = ARCONTROLLER_FEATURE_Common_SendWifiSettingsOutdoorSetting;
            featureController->sendMavlinkStart = ARCONTROLLER_FEATURE_Common_SendMavlinkStart;
            featureController->sendMavlinkPause = ARCONTROLLER_FEATURE_Common_SendMavlinkPause;
            featureController->sendMavlinkStop = ARCONTROLLER_FEATURE_Common_SendMavlinkStop;
            featureController->sendFlightPlanSettingsReturnHomeOnDisconnect = ARCONTROLLER_FEATURE_Common_SendFlightPlanSettingsReturnHomeOnDisconnect;
            featureController->sendCalibrationMagnetoCalibration = ARCONTROLLER_FEATURE_Common_SendCalibrationMagnetoCalibration;
            featureController->sendCalibrationPitotCalibration = ARCONTROLLER_FEATURE_Common_SendCalibrationPitotCalibration;
            featureController->sendGPSControllerPositionForRun = ARCONTROLLER_FEATURE_Common_SendGPSControllerPositionForRun;
            featureController->sendAudioControllerReadyForStreaming = ARCONTROLLER_FEATURE_Common_SendAudioControllerReadyForStreaming;
            featureController->sendHeadlightsIntensity = ARCONTROLLER_FEATURE_Common_SendHeadlightsIntensity;
            featureController->sendAnimationsStartAnimation = ARCONTROLLER_FEATURE_Common_SendAnimationsStartAnimation;
            featureController->sendAnimationsStopAnimation = ARCONTROLLER_FEATURE_Common_SendAnimationsStopAnimation;
            featureController->sendAnimationsStopAllAnimations = ARCONTROLLER_FEATURE_Common_SendAnimationsStopAllAnimations;
            featureController->sendAccessoryConfig = ARCONTROLLER_FEATURE_Common_SendAccessoryConfig;
            featureController->sendChargerSetMaxChargeRate = ARCONTROLLER_FEATURE_Common_SendChargerSetMaxChargeRate;
            featureController->sendFactoryReset = ARCONTROLLER_FEATURE_Common_SendFactoryReset;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Common_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Common_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Common_Delete (ARCONTROLLER_FEATURE_Common_t **feature)
{
    // -- Delete the common feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Common_GetDictionary (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the common Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_AddCallback (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Common</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_RemoveCallback (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Common</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_RegisterARCommands (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_NetworkEventDisconnectionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateAllSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateResetChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateProductNameChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateProductVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialHighChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialLowChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateCountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_SettingsStateAutoCountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateAllStatesChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateBatteryStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateMassStorageStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateCurrentDateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateCurrentTimeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoRemainingListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateWifiSignalChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateSensorsStatesListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateProductModelCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateCountryListKnownCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateDeprecatedMassStorageContentChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateDeprecatedMassStorageContentChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateMassStorageContentCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentForCurrentRunCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateMassStorageContentForCurrentRunCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCommonStateVideoRecordingTimestampCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CommonStateVideoRecordingTimestampCallback, feature);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatRegulationChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_WifiSettingsStateOutdoorSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkFilePlayingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkPlayErrorStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMissionItemExecutedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_MavlinkStateMissionItemExecutedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanSettingsStateReturnHomeOnDisconnectChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_FlightPlanSettingsStateReturnHomeOnDisconnectChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationRequiredStateCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStartedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCalibrationStatePitotCalibrationStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CalibrationStatePitotCalibrationStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_CameraSettingsStateCameraSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_FlightPlanStateAvailabilityStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_FlightPlanStateComponentStateListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateLockStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_FlightPlanStateLockStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_FlightPlanEventStartingErrorEventCallback, feature);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_FlightPlanEventSpeedBridleEventCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateControllerLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateSkyControllerLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateDeviceLibARCommandsVersionCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_AudioStateAudioStreamingRunningCallback, feature);
        ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_HeadlightsStateIntensityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAnimationsStateListCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_AnimationsStateListCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_AccessoryStateSupportedAccessoriesListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigModificationEnabledCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_ChargerStateMaxChargeRateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_ChargerStateCurrentChargeStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_ChargerStateLastChargeRateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_ChargerStateChargingInfoCallback, feature);
        ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Common_RunStateRunIdChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_UnregisterARCommands (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetCommonNetworkEventDisconnectionCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAllSettingsChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateResetChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductNameChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialHighChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateProductSerialLowChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateCountryChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonSettingsStateAutoCountryChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateAllStatesChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateBatteryStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageStateListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoStateListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentDateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCurrentTimeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageInfoRemainingListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateWifiSignalChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateSensorsStatesListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateProductModelCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateCountryListKnownCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateDeprecatedMassStorageContentChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateMassStorageContentForCurrentRunCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCommonStateVideoRecordingTimestampCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonOverHeatStateOverHeatRegulationChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonWifiSettingsStateOutdoorSettingsChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkFilePlayingStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMavlinkPlayErrorStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonMavlinkStateMissionItemExecutedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanSettingsStateReturnHomeOnDisconnectChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationRequiredStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationAxisToCalibrateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStateMagnetoCalibrationStartedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCalibrationStatePitotCalibrationStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonCameraSettingsStateCameraSettingsChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateAvailabilityStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateComponentStateListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanStateLockStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventStartingErrorEventCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonFlightPlanEventSpeedBridleEventCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateControllerLibARCommandsVersionCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateSkyControllerLibARCommandsVersionCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonARLibsVersionsStateDeviceLibARCommandsVersionCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAudioStateAudioStreamingRunningCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonHeadlightsStateIntensityChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAnimationsStateListCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateSupportedAccessoriesListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonAccessoryStateAccessoryConfigModificationEnabledCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateMaxChargeRateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateCurrentChargeStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateLastChargeRateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonChargerStateChargingInfoCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetCommonRunStateRunIdChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendNetworkDisconnect (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>NetworkDisconnect</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Disconnect command
        cmdError = ARCOMMANDS_Generator_GenerateCommonNetworkDisconnect(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsAllSettings (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>SettingsAllSettings</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllSettings command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsAllSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsReset (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>SettingsReset</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsProductName (ARCONTROLLER_FEATURE_Common_t *feature, char * name)
{
    // -- Send a command <code>SettingsProductName</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ProductName command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsProductName(cmdBuffer, sizeof(cmdBuffer), &cmdSize, name);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsCountry (ARCONTROLLER_FEATURE_Common_t *feature, char * code)
{
    // -- Send a command <code>SettingsCountry</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Country command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, code);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendSettingsAutoCountry (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t automatic)
{
    // -- Send a command <code>SettingsAutoCountry</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoCountry command
        cmdError = ARCOMMANDS_Generator_GenerateCommonSettingsAutoCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, automatic);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonAllStates (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>CommonAllStates</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllStates command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonAllStates(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonCurrentDate (ARCONTROLLER_FEATURE_Common_t *feature, char * date)
{
    // -- Send a command <code>CommonCurrentDate</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CurrentDate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonCurrentDate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, date);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonCurrentTime (ARCONTROLLER_FEATURE_Common_t *feature, char * time)
{
    // -- Send a command <code>CommonCurrentTime</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CurrentTime command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonCurrentTime(cmdBuffer, sizeof(cmdBuffer), &cmdSize, time);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCommonReboot (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>CommonReboot</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reboot command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCommonReboot(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendOverHeatSwitchOff (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>OverHeatSwitchOff</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SwitchOff command
        cmdError = ARCOMMANDS_Generator_GenerateCommonOverHeatSwitchOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendOverHeatVentilate (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>OverHeatVentilate</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Ventilate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonOverHeatVentilate(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendControllerIsPiloting (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t piloting)
{
    // -- Send a command <code>ControllerIsPiloting</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send IsPiloting command
        cmdError = ARCOMMANDS_Generator_GenerateCommonControllerIsPiloting(cmdBuffer, sizeof(cmdBuffer), &cmdSize, piloting);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendWifiSettingsOutdoorSetting (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>WifiSettingsOutdoorSetting</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send OutdoorSetting command
        cmdError = ARCOMMANDS_Generator_GenerateCommonWifiSettingsOutdoorSetting(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkStart (ARCONTROLLER_FEATURE_Common_t *feature, char * filepath, eARCOMMANDS_COMMON_MAVLINK_START_TYPE type)
{
    // -- Send a command <code>MavlinkStart</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Start command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkStart(cmdBuffer, sizeof(cmdBuffer), &cmdSize, filepath, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkPause (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>MavlinkPause</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Pause command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkPause(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendMavlinkStop (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>MavlinkStop</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Stop command
        cmdError = ARCOMMANDS_Generator_GenerateCommonMavlinkStop(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendFlightPlanSettingsReturnHomeOnDisconnect (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t value)
{
    // -- Send a command <code>FlightPlanSettingsReturnHomeOnDisconnect</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ReturnHomeOnDisconnect command
        cmdError = ARCOMMANDS_Generator_GenerateCommonFlightPlanSettingsReturnHomeOnDisconnect(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCalibrationMagnetoCalibration (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t calibrate)
{
    // -- Send a command <code>CalibrationMagnetoCalibration</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MagnetoCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCalibrationMagnetoCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, calibrate);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendCalibrationPitotCalibration (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t calibrate)
{
    // -- Send a command <code>CalibrationPitotCalibration</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PitotCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateCommonCalibrationPitotCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, calibrate);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendGPSControllerPositionForRun (ARCONTROLLER_FEATURE_Common_t *feature, double latitude, double longitude)
{
    // -- Send a command <code>GPSControllerPositionForRun</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerPositionForRun command
        cmdError = ARCOMMANDS_Generator_GenerateCommonGPSControllerPositionForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAudioControllerReadyForStreaming (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t ready)
{
    // -- Send a command <code>AudioControllerReadyForStreaming</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerReadyForStreaming command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAudioControllerReadyForStreaming(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ready);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendHeadlightsIntensity (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t left, uint8_t right)
{
    // -- Send a command <code>HeadlightsIntensity</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Intensity command
        cmdError = ARCOMMANDS_Generator_GenerateCommonHeadlightsIntensity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, left, right);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAnimationsStartAnimation (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ANIMATIONS_STARTANIMATION_ANIM anim)
{
    // -- Send a command <code>AnimationsStartAnimation</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAnimationsStartAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, anim);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAnimationsStopAnimation (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ANIMATIONS_STOPANIMATION_ANIM anim)
{
    // -- Send a command <code>AnimationsStopAnimation</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAnimationsStopAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, anim);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAnimationsStopAllAnimations (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>AnimationsStopAllAnimations</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopAllAnimations command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAnimationsStopAllAnimations(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendAccessoryConfig (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ACCESSORY_CONFIG_ACCESSORY accessory)
{
    // -- Send a command <code>AccessoryConfig</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Config command
        cmdError = ARCOMMANDS_Generator_GenerateCommonAccessoryConfig(cmdBuffer, sizeof(cmdBuffer), &cmdSize, accessory);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendChargerSetMaxChargeRate (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGER_SETMAXCHARGERATE_RATE rate)
{
    // -- Send a command <code>ChargerSetMaxChargeRate</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetMaxChargeRate command
        cmdError = ARCOMMANDS_Generator_GenerateCommonChargerSetMaxChargeRate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, rate);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SendFactoryReset (ARCONTROLLER_FEATURE_Common_t *feature)
{
    // -- Send a command <code>FactoryReset</code> in project <code>Common</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateCommonFactoryReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Common_NetworkEventDisconnectionCallback (eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause, void *customData)
{
    // -- callback used when the command <code>NetworkEventDisconnection</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementNetworkEventDisconnection (feature,  _cause, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateAllSettingsChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateAllSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_ALLSETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateAllSettingsChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateResetChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateResetChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_RESETCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateResetChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductNameChangedCallback (const char * _name, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductNameChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductNameChanged (feature,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductVersionChangedCallback (const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialHighChangedCallback (const char * _high, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductSerialHighChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialHighChanged (feature,  _high, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateProductSerialLowChangedCallback (const char * _low, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductSerialLowChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialLowChanged (feature,  _low, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateCountryChangedCallback (const char * _code, void *customData)
{
    // -- callback used when the command <code>SettingsStateCountryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateCountryChanged (feature,  _code, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_SettingsStateAutoCountryChangedCallback (uint8_t _automatic, void *customData)
{
    // -- callback used when the command <code>SettingsStateAutoCountryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementSettingsStateAutoCountryChanged (feature,  _automatic, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateAllStatesChangedCallback (void *customData)
{
    // -- callback used when the command <code>CommonStateAllStatesChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_ALLSTATESCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateAllStatesChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateBatteryStateChangedCallback (uint8_t _percent, void *customData)
{
    // -- callback used when the command <code>CommonStateBatteryStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateBatteryStateChanged (feature,  _percent, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageStateListChangedCallback (uint8_t _mass_storage_id, const char * _name, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageStateListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageStateListChanged (feature,  _mass_storage_id,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoStateListChangedCallback (uint8_t _mass_storage_id, uint32_t _size, uint32_t _used_size, uint8_t _plugged, uint8_t _full, uint8_t _internal, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageInfoStateListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoStateListChanged (feature,  _mass_storage_id,  _size,  _used_size,  _plugged,  _full,  _internal, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateCurrentDateChangedCallback (const char * _date, void *customData)
{
    // -- callback used when the command <code>CommonStateCurrentDateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateCurrentDateChanged (feature,  _date, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateCurrentTimeChangedCallback (const char * _time, void *customData)
{
    // -- callback used when the command <code>CommonStateCurrentTimeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateCurrentTimeChanged (feature,  _time, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageInfoRemainingListChangedCallback (uint32_t _free_space, uint16_t _rec_time, uint32_t _photo_remaining, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageInfoRemainingListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoRemainingListChanged (feature,  _free_space,  _rec_time,  _photo_remaining, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateWifiSignalChangedCallback (int16_t _rssi, void *customData)
{
    // -- callback used when the command <code>CommonStateWifiSignalChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateWifiSignalChanged (feature,  _rssi, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateSensorsStatesListChangedCallback (eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName, uint8_t _sensorState, void *customData)
{
    // -- callback used when the command <code>CommonStateSensorsStatesListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateSensorsStatesListChanged (feature,  _sensorName,  _sensorState, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateProductModelCallback (eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL _model, void *customData)
{
    // -- callback used when the command <code>CommonStateProductModel</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateProductModel (feature,  _model, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateCountryListKnownCallback (uint8_t _listFlags, const char * _countryCodes, void *customData)
{
    // -- callback used when the command <code>CommonStateCountryListKnown</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateCountryListKnown (feature,  _listFlags,  _countryCodes, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateDeprecatedMassStorageContentChangedCallback (uint8_t _mass_storage_id, uint16_t _nbPhotos, uint16_t _nbVideos, uint16_t _nbPuds, uint16_t _nbCrashLogs, void *customData)
{
    // -- callback used when the command <code>CommonStateDeprecatedMassStorageContentChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateDeprecatedMassStorageContentChanged (feature,  _mass_storage_id,  _nbPhotos,  _nbVideos,  _nbPuds,  _nbCrashLogs, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageContentCallback (uint8_t _mass_storage_id, uint16_t _nbPhotos, uint16_t _nbVideos, uint16_t _nbPuds, uint16_t _nbCrashLogs, uint16_t _nbRawPhotos, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageContent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageContent (feature,  _mass_storage_id,  _nbPhotos,  _nbVideos,  _nbPuds,  _nbCrashLogs,  _nbRawPhotos, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateMassStorageContentForCurrentRunCallback (uint8_t _mass_storage_id, uint16_t _nbPhotos, uint16_t _nbVideos, uint16_t _nbRawPhotos, void *customData)
{
    // -- callback used when the command <code>CommonStateMassStorageContentForCurrentRun</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageContentForCurrentRun (feature,  _mass_storage_id,  _nbPhotos,  _nbVideos,  _nbRawPhotos, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CommonStateVideoRecordingTimestampCallback (uint64_t _startTimestamp, uint64_t _stopTimestamp, void *customData)
{
    // -- callback used when the command <code>CommonStateVideoRecordingTimestamp</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_VIDEORECORDINGTIMESTAMP;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCommonStateVideoRecordingTimestamp (feature,  _startTimestamp,  _stopTimestamp, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatChangedCallback (void *customData)
{
    // -- callback used when the command <code>OverHeatStateOverHeatChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_OverHeatStateOverHeatRegulationChangedCallback (uint8_t _regulationType, void *customData)
{
    // -- callback used when the command <code>OverHeatStateOverHeatRegulationChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatRegulationChanged (feature,  _regulationType, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_WifiSettingsStateOutdoorSettingsChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>WifiSettingsStateOutdoorSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementWifiSettingsStateOutdoorSettingsChanged (feature,  _outdoor, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkFilePlayingStateChangedCallback (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state, const char * _filepath, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>MavlinkStateMavlinkFilePlayingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkFilePlayingStateChanged (feature,  _state,  _filepath,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_MavlinkStateMavlinkPlayErrorStateChangedCallback (eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MavlinkStateMavlinkPlayErrorStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkPlayErrorStateChanged (feature,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_MavlinkStateMissionItemExecutedCallback (uint32_t _idx, void *customData)
{
    // -- callback used when the command <code>MavlinkStateMissionItemExecuted</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MISSIONITEMEXECUTED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementMavlinkStateMissionItemExecuted (feature,  _idx, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanSettingsStateReturnHomeOnDisconnectChangedCallback (uint8_t _state, uint8_t _isReadOnly, void *customData)
{
    // -- callback used when the command <code>FlightPlanSettingsStateReturnHomeOnDisconnectChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSETTINGSSTATE_RETURNHOMEONDISCONNECTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanSettingsStateReturnHomeOnDisconnectChanged (feature,  _state,  _isReadOnly, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStateChangedCallback (uint8_t _xAxisCalibration, uint8_t _yAxisCalibration, uint8_t _zAxisCalibration, uint8_t _calibrationFailed, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStateChanged (feature,  _xAxisCalibration,  _yAxisCalibration,  _zAxisCalibration,  _calibrationFailed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationRequiredStateCallback (uint8_t _required, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationRequiredState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationRequiredState (feature,  _required, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationAxisToCalibrateChangedCallback (eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationAxisToCalibrateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationAxisToCalibrateChanged (feature,  _axis, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStateMagnetoCalibrationStartedChangedCallback (uint8_t _started, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationStartedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStartedChanged (feature,  _started, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CalibrationStatePitotCalibrationStateChangedCallback (eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE _state, uint8_t _lastError, void *customData)
{
    // -- callback used when the command <code>CalibrationStatePitotCalibrationStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCalibrationStatePitotCalibrationStateChanged (feature,  _state,  _lastError, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_CameraSettingsStateCameraSettingsChangedCallback (float _fov, float _panMax, float _panMin, float _tiltMax, float _tiltMin, void *customData)
{
    // -- callback used when the command <code>CameraSettingsStateCameraSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementCameraSettingsStateCameraSettingsChanged (feature,  _fov,  _panMax,  _panMin,  _tiltMax,  _tiltMin, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanStateAvailabilityStateChangedCallback (uint8_t _AvailabilityState, void *customData)
{
    // -- callback used when the command <code>FlightPlanStateAvailabilityStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanStateAvailabilityStateChanged (feature,  _AvailabilityState, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanStateComponentStateListChangedCallback (eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component, uint8_t _State, void *customData)
{
    // -- callback used when the command <code>FlightPlanStateComponentStateListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanStateComponentStateListChanged (feature,  _component,  _State, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanStateLockStateChangedCallback (uint8_t _LockState, void *customData)
{
    // -- callback used when the command <code>FlightPlanStateLockStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_LOCKSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanStateLockStateChanged (feature,  _LockState, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanEventStartingErrorEventCallback (void *customData)
{
    // -- callback used when the command <code>FlightPlanEventStartingErrorEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANEVENT_STARTINGERROREVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanEventStartingErrorEvent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_FlightPlanEventSpeedBridleEventCallback (void *customData)
{
    // -- callback used when the command <code>FlightPlanEventSpeedBridleEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANEVENT_SPEEDBRIDLEEVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementFlightPlanEventSpeedBridleEvent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateControllerLibARCommandsVersionCallback (const char * _version, void *customData)
{
    // -- callback used when the command <code>ARLibsVersionsStateControllerLibARCommandsVersion</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateControllerLibARCommandsVersion (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateSkyControllerLibARCommandsVersionCallback (const char * _version, void *customData)
{
    // -- callback used when the command <code>ARLibsVersionsStateSkyControllerLibARCommandsVersion</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateSkyControllerLibARCommandsVersion (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ARLibsVersionsStateDeviceLibARCommandsVersionCallback (const char * _version, void *customData)
{
    // -- callback used when the command <code>ARLibsVersionsStateDeviceLibARCommandsVersion</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateDeviceLibARCommandsVersion (feature,  _version, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AudioStateAudioStreamingRunningCallback (uint8_t _running, void *customData)
{
    // -- callback used when the command <code>AudioStateAudioStreamingRunning</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAudioStateAudioStreamingRunning (feature,  _running, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_HeadlightsStateIntensityChangedCallback (uint8_t _left, uint8_t _right, void *customData)
{
    // -- callback used when the command <code>HeadlightsStateIntensityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementHeadlightsStateIntensityChanged (feature,  _left,  _right, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AnimationsStateListCallback (eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM _anim, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE _state, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR _error, void *customData)
{
    // -- callback used when the command <code>AnimationsStateList</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAnimationsStateList (feature,  _anim,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AccessoryStateSupportedAccessoriesListChangedCallback (eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY _accessory, void *customData)
{
    // -- callback used when the command <code>AccessoryStateSupportedAccessoriesListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAccessoryStateSupportedAccessoriesListChanged (feature,  _accessory, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigChangedCallback (eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY _newAccessory, eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>AccessoryStateAccessoryConfigChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigChanged (feature,  _newAccessory,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_AccessoryStateAccessoryConfigModificationEnabledCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>AccessoryStateAccessoryConfigModificationEnabled</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigModificationEnabled (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateMaxChargeRateChangedCallback (eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE _rate, void *customData)
{
    // -- callback used when the command <code>ChargerStateMaxChargeRateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateMaxChargeRateChanged (feature,  _rate, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateCurrentChargeStateChangedCallback (eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS _status, eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE _phase, void *customData)
{
    // -- callback used when the command <code>ChargerStateCurrentChargeStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateCurrentChargeStateChanged (feature,  _status,  _phase, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateLastChargeRateChangedCallback (eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE _rate, void *customData)
{
    // -- callback used when the command <code>ChargerStateLastChargeRateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateLastChargeRateChanged (feature,  _rate, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_ChargerStateChargingInfoCallback (eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE _phase, eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE _rate, uint8_t _intensity, uint8_t _fullChargingTime, void *customData)
{
    // -- callback used when the command <code>ChargerStateChargingInfo</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementChargerStateChargingInfo (feature,  _phase,  _rate,  _intensity,  _fullChargingTime, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Common_RunStateRunIdChangedCallback (const char * _runId, void *customData)
{
    // -- callback used when the command <code>RunStateRunIdChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Common_t *feature = (ARCONTROLLER_FEATURE_Common_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_COMMON_RUNSTATE_RUNIDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Common_NewCmdElementRunStateRunIdChanged (feature,  _runId, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementNetworkEventDisconnection (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE _cause, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkEventDisconnection -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_NETWORKEVENT_DISCONNECTION_CAUSE;
            argDictNewElement->value.I32 = _cause;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateAllSettingsChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateAllSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateResetChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateResetChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductNameChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductNameChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTNAMECHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductVersionChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialHighChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _high, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductSerialHighChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALHIGHCHANGED_HIGH;
            strLength = strlen (_high);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _high, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateProductSerialLowChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _low, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductSerialLowChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_PRODUCTSERIALLOWCHANGED_LOW;
            strLength = strlen (_low);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _low, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateCountryChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _code, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateCountryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_COUNTRYCHANGED_CODE;
            strLength = strlen (_code);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _code, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementSettingsStateAutoCountryChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _automatic, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateAutoCountryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_SETTINGSSTATE_AUTOCOUNTRYCHANGED_AUTOMATIC;
            argDictNewElement->value.U8 = _automatic;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateAllStatesChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateAllStatesChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateBatteryStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _percent, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateBatteryStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_BATTERYSTATECHANGED_PERCENT;
            argDictNewElement->value.U8 = _percent;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageStateListChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _mass_storage_id, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageStateListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGESTATELISTCHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoStateListChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _mass_storage_id, uint32_t _size, uint32_t _used_size, uint8_t _plugged, uint8_t _full, uint8_t _internal, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageInfoStateListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_SIZE;
            argDictNewElement->value.U32 = _size;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_USED_SIZE;
            argDictNewElement->value.U32 = _used_size;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_PLUGGED;
            argDictNewElement->value.U8 = _plugged;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_FULL;
            argDictNewElement->value.U8 = _full;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOSTATELISTCHANGED_INTERNAL;
            argDictNewElement->value.U8 = _internal;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateCurrentDateChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _date, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateCurrentDateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTDATECHANGED_DATE;
            strLength = strlen (_date);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _date, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateCurrentTimeChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _time, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateCurrentTimeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_CURRENTTIMECHANGED_TIME;
            strLength = strlen (_time);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _time, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageInfoRemainingListChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint32_t _free_space, uint16_t _rec_time, uint32_t _photo_remaining, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageInfoRemainingListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_FREE_SPACE;
            argDictNewElement->value.U32 = _free_space;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_REC_TIME;
            argDictNewElement->value.U16 = _rec_time;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGEINFOREMAININGLISTCHANGED_PHOTO_REMAINING;
            argDictNewElement->value.U32 = _photo_remaining;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateWifiSignalChanged (ARCONTROLLER_FEATURE_Common_t *feature, int16_t _rssi, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateWifiSignalChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_WIFISIGNALCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateSensorsStatesListChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME _sensorName, uint8_t _sensorState, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateSensorsStatesListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _sensorName);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _sensorName);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORNAME;
            argDictNewElement->value.I32 = _sensorName;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_SENSORSSTATESLISTCHANGED_SENSORSTATE;
            argDictNewElement->value.U8 = _sensorState;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateProductModel (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL _model, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateProductModel -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_PRODUCTMODEL_MODEL;
            argDictNewElement->value.I32 = _model;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateCountryListKnown (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _listFlags, const char * _countryCodes, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateCountryListKnown -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_LISTFLAGS;
            argDictNewElement->value.U8 = _listFlags;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_COUNTRYLISTKNOWN_COUNTRYCODES;
            strLength = strlen (_countryCodes);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _countryCodes, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateDeprecatedMassStorageContentChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _mass_storage_id, uint16_t _nbPhotos, uint16_t _nbVideos, uint16_t _nbPuds, uint16_t _nbCrashLogs, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateDeprecatedMassStorageContentChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBPHOTOS;
            argDictNewElement->value.U16 = _nbPhotos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBVIDEOS;
            argDictNewElement->value.U16 = _nbVideos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBPUDS;
            argDictNewElement->value.U16 = _nbPuds;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_DEPRECATEDMASSSTORAGECONTENTCHANGED_NBCRASHLOGS;
            argDictNewElement->value.U16 = _nbCrashLogs;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageContent (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _mass_storage_id, uint16_t _nbPhotos, uint16_t _nbVideos, uint16_t _nbPuds, uint16_t _nbCrashLogs, uint16_t _nbRawPhotos, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageContent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBPHOTOS;
            argDictNewElement->value.U16 = _nbPhotos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBVIDEOS;
            argDictNewElement->value.U16 = _nbVideos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBPUDS;
            argDictNewElement->value.U16 = _nbPuds;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBCRASHLOGS;
            argDictNewElement->value.U16 = _nbCrashLogs;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENT_NBRAWPHOTOS;
            argDictNewElement->value.U16 = _nbRawPhotos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateMassStorageContentForCurrentRun (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _mass_storage_id, uint16_t _nbPhotos, uint16_t _nbVideos, uint16_t _nbRawPhotos, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateMassStorageContentForCurrentRun -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _mass_storage_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _mass_storage_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_NBPHOTOS;
            argDictNewElement->value.U16 = _nbPhotos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_NBVIDEOS;
            argDictNewElement->value.U16 = _nbVideos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_MASSSTORAGECONTENTFORCURRENTRUN_NBRAWPHOTOS;
            argDictNewElement->value.U16 = _nbRawPhotos;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCommonStateVideoRecordingTimestamp (ARCONTROLLER_FEATURE_Common_t *feature, uint64_t _startTimestamp, uint64_t _stopTimestamp, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateVideoRecordingTimestamp -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_VIDEORECORDINGTIMESTAMP_STARTTIMESTAMP;
            argDictNewElement->value.U64 = _startTimestamp;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_COMMONSTATE_VIDEORECORDINGTIMESTAMP_STOPTIMESTAMP;
            argDictNewElement->value.U64 = _stopTimestamp;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event OverHeatStateOverHeatChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementOverHeatStateOverHeatRegulationChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _regulationType, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event OverHeatStateOverHeatRegulationChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_OVERHEATSTATE_OVERHEATREGULATIONCHANGED_REGULATIONTYPE;
            argDictNewElement->value.U8 = _regulationType;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementWifiSettingsStateOutdoorSettingsChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _outdoor, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiSettingsStateOutdoorSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_WIFISETTINGSSTATE_OUTDOORSETTINGSCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkFilePlayingStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE _state, const char * _filepath, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MavlinkStateMavlinkFilePlayingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_FILEPATH;
            strLength = strlen (_filepath);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filepath, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKFILEPLAYINGSTATECHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementMavlinkStateMavlinkPlayErrorStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MavlinkStateMavlinkPlayErrorStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MAVLINKPLAYERRORSTATECHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementMavlinkStateMissionItemExecuted (ARCONTROLLER_FEATURE_Common_t *feature, uint32_t _idx, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MavlinkStateMissionItemExecuted -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_MAVLINKSTATE_MISSIONITEMEXECUTED_IDX;
            argDictNewElement->value.U32 = _idx;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanSettingsStateReturnHomeOnDisconnectChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _state, uint8_t _isReadOnly, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanSettingsStateReturnHomeOnDisconnectChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSETTINGSSTATE_RETURNHOMEONDISCONNECTCHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSETTINGSSTATE_RETURNHOMEONDISCONNECTCHANGED_ISREADONLY;
            argDictNewElement->value.U8 = _isReadOnly;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _xAxisCalibration, uint8_t _yAxisCalibration, uint8_t _zAxisCalibration, uint8_t _calibrationFailed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_XAXISCALIBRATION;
            argDictNewElement->value.U8 = _xAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_YAXISCALIBRATION;
            argDictNewElement->value.U8 = _yAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_ZAXISCALIBRATION;
            argDictNewElement->value.U8 = _zAxisCalibration;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATECHANGED_CALIBRATIONFAILED;
            argDictNewElement->value.U8 = _calibrationFailed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationRequiredState (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _required, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationRequiredState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONREQUIREDSTATE_REQUIRED;
            argDictNewElement->value.U8 = _required;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationAxisToCalibrateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS _axis, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationAxisToCalibrateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONAXISTOCALIBRATECHANGED_AXIS;
            argDictNewElement->value.I32 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStateMagnetoCalibrationStartedChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _started, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationStartedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTARTEDCHANGED_STARTED;
            argDictNewElement->value.U8 = _started;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCalibrationStatePitotCalibrationStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE _state, uint8_t _lastError, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStatePitotCalibrationStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CALIBRATIONSTATE_PITOTCALIBRATIONSTATECHANGED_LASTERROR;
            argDictNewElement->value.U8 = _lastError;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementCameraSettingsStateCameraSettingsChanged (ARCONTROLLER_FEATURE_Common_t *feature, float _fov, float _panMax, float _panMin, float _tiltMax, float _tiltMin, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraSettingsStateCameraSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_FOV;
            argDictNewElement->value.Float = _fov;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMAX;
            argDictNewElement->value.Float = _panMax;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_PANMIN;
            argDictNewElement->value.Float = _panMin;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMAX;
            argDictNewElement->value.Float = _tiltMax;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CAMERASETTINGSSTATE_CAMERASETTINGSCHANGED_TILTMIN;
            argDictNewElement->value.Float = _tiltMin;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanStateAvailabilityStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _AvailabilityState, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanStateAvailabilityStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_AVAILABILITYSTATECHANGED_AVAILABILITYSTATE;
            argDictNewElement->value.U8 = _AvailabilityState;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanStateComponentStateListChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT _component, uint8_t _State, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanStateComponentStateListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _component);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _component);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_COMPONENT;
            argDictNewElement->value.I32 = _component;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_COMPONENTSTATELISTCHANGED_STATE;
            argDictNewElement->value.U8 = _State;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanStateLockStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _LockState, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanStateLockStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_FLIGHTPLANSTATE_LOCKSTATECHANGED_LOCKSTATE;
            argDictNewElement->value.U8 = _LockState;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanEventStartingErrorEvent (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanEventStartingErrorEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementFlightPlanEventSpeedBridleEvent (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FlightPlanEventSpeedBridleEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateControllerLibARCommandsVersion (ARCONTROLLER_FEATURE_Common_t *feature, const char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ARLibsVersionsStateControllerLibARCommandsVersion -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_CONTROLLERLIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateSkyControllerLibARCommandsVersion (ARCONTROLLER_FEATURE_Common_t *feature, const char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ARLibsVersionsStateSkyControllerLibARCommandsVersion -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_SKYCONTROLLERLIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementARLibsVersionsStateDeviceLibARCommandsVersion (ARCONTROLLER_FEATURE_Common_t *feature, const char * _version, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ARLibsVersionsStateDeviceLibARCommandsVersion -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ARLIBSVERSIONSSTATE_DEVICELIBARCOMMANDSVERSION_VERSION;
            strLength = strlen (_version);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _version, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAudioStateAudioStreamingRunning (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _running, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AudioStateAudioStreamingRunning -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_AUDIOSTATE_AUDIOSTREAMINGRUNNING_RUNNING;
            argDictNewElement->value.U8 = _running;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementHeadlightsStateIntensityChanged (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _left, uint8_t _right, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event HeadlightsStateIntensityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_LEFT;
            argDictNewElement->value.U8 = _left;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_HEADLIGHTSSTATE_INTENSITYCHANGED_RIGHT;
            argDictNewElement->value.U8 = _right;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAnimationsStateList (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ANIM _anim, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_STATE _state, eARCOMMANDS_COMMON_ANIMATIONSSTATE_LIST_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateList -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _anim);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _anim);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ANIM;
            argDictNewElement->value.I32 = _anim;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ANIMATIONSSTATE_LIST_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAccessoryStateSupportedAccessoriesListChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY _accessory, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateSupportedAccessoriesListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _accessory);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _accessory);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_SUPPORTEDACCESSORIESLISTCHANGED_ACCESSORY;
            argDictNewElement->value.I32 = _accessory;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY _newAccessory, eARCOMMANDS_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateAccessoryConfigChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_NEWACCESSORY;
            argDictNewElement->value.I32 = _newAccessory;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementAccessoryStateAccessoryConfigModificationEnabled (ARCONTROLLER_FEATURE_Common_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessoryStateAccessoryConfigModificationEnabled -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_ACCESSORYSTATE_ACCESSORYCONFIGMODIFICATIONENABLED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateMaxChargeRateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE _rate, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateMaxChargeRateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_MAXCHARGERATECHANGED_RATE;
            argDictNewElement->value.I32 = _rate;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateCurrentChargeStateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS _status, eARCOMMANDS_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE _phase, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateCurrentChargeStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CURRENTCHARGESTATECHANGED_PHASE;
            argDictNewElement->value.I32 = _phase;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateLastChargeRateChanged (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE _rate, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateLastChargeRateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_LASTCHARGERATECHANGED_RATE;
            argDictNewElement->value.I32 = _rate;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementChargerStateChargingInfo (ARCONTROLLER_FEATURE_Common_t *feature, eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE _phase, eARCOMMANDS_COMMON_CHARGERSTATE_CHARGINGINFO_RATE _rate, uint8_t _intensity, uint8_t _fullChargingTime, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChargerStateChargingInfo -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_PHASE;
            argDictNewElement->value.I32 = _phase;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_RATE;
            argDictNewElement->value.I32 = _rate;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_INTENSITY;
            argDictNewElement->value.U8 = _intensity;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_CHARGERSTATE_CHARGINGINFO_FULLCHARGINGTIME;
            argDictNewElement->value.U8 = _fullChargingTime;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_NewCmdElementRunStateRunIdChanged (ARCONTROLLER_FEATURE_Common_t *feature, const char * _runId, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RunStateRunIdChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_COMMON_RUNSTATE_RUNIDCHANGED_RUNID;
            strLength = strlen (_runId);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _runId, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Common_SetNetworkController (ARCONTROLLER_FEATURE_Common_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Common_GetCommandElements (ARCONTROLLER_FEATURE_Common_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE controller_info --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

ARCONTROLLER_FEATURE_ControllerInfo_t *ARCONTROLLER_FEATURE_ControllerInfo_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_ControllerInfo_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_ControllerInfo_t));
        if (featureController != NULL)
        {
            featureController->sendGps = ARCONTROLLER_FEATURE_ControllerInfo_SendGps;
            featureController->setGps = ARCONTROLLER_FEATURE_ControllerInfo_SetGps;
            featureController->setGpsLatitude = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsLatitude;
            featureController->setGpsLongitude = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsLongitude;
            featureController->setGpsAltitude = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsAltitude;
            featureController->setGpsHorizontalAccuracy = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsHorizontalAccuracy;
            featureController->setGpsVerticalAccuracy = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsVerticalAccuracy;
            featureController->setGpsNorthSpeed = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsNorthSpeed;
            featureController->setGpsEastSpeed = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsEastSpeed;
            featureController->setGpsDownSpeed = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsDownSpeed;
            featureController->setGpsTimestamp = ARCONTROLLER_FEATURE_ControllerInfo_SetGpsTimestamp;
            featureController->sendBarometer = ARCONTROLLER_FEATURE_ControllerInfo_SendBarometer;
            featureController->setBarometer = ARCONTROLLER_FEATURE_ControllerInfo_SetBarometer;
            featureController->setBarometerPressure = ARCONTROLLER_FEATURE_ControllerInfo_SetBarometerPressure;
            featureController->setBarometerTimestamp = ARCONTROLLER_FEATURE_ControllerInfo_SetBarometerTimestamp;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_ControllerInfo_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->GpsParameters = NULL;
            featureController->privatePart->BarometerParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->GpsParameters = calloc (1, sizeof (ARCONTROLLER_ControllerInfo_GpsParameters_t));
        if (featureController->privatePart->GpsParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_ControllerInfoGpsInit (featureController);
    }

    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->BarometerParameters = calloc (1, sizeof (ARCONTROLLER_ControllerInfo_BarometerParameters_t));
        if (featureController->privatePart->BarometerParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_ControllerInfoBarometerInit (featureController);
    }

    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_ControllerInfo_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_ControllerInfo_Delete (ARCONTROLLER_FEATURE_ControllerInfo_t **feature)
{
    // -- Delete the controller_info feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->GpsParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_ControllerInfoGpsDeInit (*feature);

                    free ((*feature)->privatePart->GpsParameters);
                    (*feature)->privatePart->GpsParameters = NULL;
                }
                if ((*feature)->privatePart->BarometerParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_ControllerInfoBarometerDeInit (*feature);

                    free ((*feature)->privatePart->BarometerParameters);
                    (*feature)->privatePart->BarometerParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_ControllerInfo_GetDictionary (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the controller_info Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_AddCallback (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>ControllerInfo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_RemoveCallback (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>ControllerInfo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_RegisterARCommands (ARCONTROLLER_FEATURE_ControllerInfo_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_UnregisterARCommands (ARCONTROLLER_FEATURE_ControllerInfo_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SendGps (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, double latitude, double longitude, float altitude, float horizontal_accuracy, float vertical_accuracy, float north_speed, float east_speed, float down_speed, double timestamp)
{
    // -- Send a command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Gps command
        cmdError = ARCOMMANDS_Generator_GenerateControllerInfoGps(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude, longitude, altitude, horizontal_accuracy, vertical_accuracy, north_speed, east_speed, down_speed, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGps (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, double _latitude, double _longitude, float _altitude, float _horizontal_accuracy, float _vertical_accuracy, float _north_speed, float _east_speed, float _down_speed, double _timestamp)
{
    // -- Set the parameter for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->latitude = _latitude;
        feature->privatePart->GpsParameters->longitude = _longitude;
        feature->privatePart->GpsParameters->altitude = _altitude;
        feature->privatePart->GpsParameters->horizontal_accuracy = _horizontal_accuracy;
        feature->privatePart->GpsParameters->vertical_accuracy = _vertical_accuracy;
        feature->privatePart->GpsParameters->north_speed = _north_speed;
        feature->privatePart->GpsParameters->east_speed = _east_speed;
        feature->privatePart->GpsParameters->down_speed = _down_speed;
        feature->privatePart->GpsParameters->timestamp = _timestamp;

            ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ControllerInfo_SendGpsStruct (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>Gps</code> in project <code>ControllerInfo</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Gps command
        cmdError = ARCOMMANDS_Generator_GenerateControllerInfoGps(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->GpsParameters->latitude, feature->privatePart->GpsParameters->longitude, feature->privatePart->GpsParameters->altitude, feature->privatePart->GpsParameters->horizontal_accuracy, feature->privatePart->GpsParameters->vertical_accuracy, feature->privatePart->GpsParameters->north_speed, feature->privatePart->GpsParameters->east_speed, feature->privatePart->GpsParameters->down_speed, feature->privatePart->GpsParameters->timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsLatitude (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, double _latitude)
{
    // -- Set the latitude for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->latitude = _latitude;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsLongitude (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, double _longitude)
{
    // -- Set the longitude for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->longitude = _longitude;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsAltitude (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _altitude)
{
    // -- Set the altitude for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->altitude = _altitude;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsHorizontalAccuracy (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _horizontal_accuracy)
{
    // -- Set the horizontal_accuracy for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->horizontal_accuracy = _horizontal_accuracy;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsVerticalAccuracy (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _vertical_accuracy)
{
    // -- Set the vertical_accuracy for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->vertical_accuracy = _vertical_accuracy;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsNorthSpeed (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _north_speed)
{
    // -- Set the north_speed for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->north_speed = _north_speed;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsEastSpeed (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _east_speed)
{
    // -- Set the east_speed for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->east_speed = _east_speed;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsDownSpeed (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _down_speed)
{
    // -- Set the down_speed for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->down_speed = _down_speed;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetGpsTimestamp (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, double _timestamp)
{
    // -- Set the timestamp for the command <code>Gps</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->GpsParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->GpsParameters->timestamp = _timestamp;

        ARCONTROLLER_NAckCbs_ControllerInfoGpsChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SendBarometer (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float pressure, double timestamp)
{
    // -- Send a command <code>Barometer</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Barometer command
        cmdError = ARCOMMANDS_Generator_GenerateControllerInfoBarometer(cmdBuffer, sizeof(cmdBuffer), &cmdSize, pressure, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetBarometer (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _pressure, double _timestamp)
{
    // -- Set the parameter for the command <code>Barometer</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->BarometerParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->BarometerParameters->pressure = _pressure;
        feature->privatePart->BarometerParameters->timestamp = _timestamp;

            ARCONTROLLER_NAckCbs_ControllerInfoBarometerChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_ControllerInfo_SendBarometerStruct (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>Barometer</code> in project <code>ControllerInfo</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->BarometerParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Barometer command
        cmdError = ARCOMMANDS_Generator_GenerateControllerInfoBarometer(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->BarometerParameters->pressure, feature->privatePart->BarometerParameters->timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetBarometerPressure (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, float _pressure)
{
    // -- Set the pressure for the command <code>Barometer</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->BarometerParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->BarometerParameters->pressure = _pressure;

        ARCONTROLLER_NAckCbs_ControllerInfoBarometerChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetBarometerTimestamp (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, double _timestamp)
{
    // -- Set the timestamp for the command <code>Barometer</code> in project <code>ControllerInfo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->BarometerParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->BarometerParameters->timestamp = _timestamp;

        ARCONTROLLER_NAckCbs_ControllerInfoBarometerChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ControllerInfo_SetNetworkController (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ControllerInfo_GetCommandElements (ARCONTROLLER_FEATURE_ControllerInfo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE debug --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_ID = "arcontroller_dictionary_key_debug_settingsinfo_id";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_LABEL = "arcontroller_dictionary_key_debug_settingsinfo_label";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_TYPE = "arcontroller_dictionary_key_debug_settingsinfo_type";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_MODE = "arcontroller_dictionary_key_debug_settingsinfo_mode";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_RANGE_MIN = "arcontroller_dictionary_key_debug_settingsinfo_range_min";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_RANGE_MAX = "arcontroller_dictionary_key_debug_settingsinfo_range_max";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_RANGE_STEP = "arcontroller_dictionary_key_debug_settingsinfo_range_step";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_VALUE = "arcontroller_dictionary_key_debug_settingsinfo_value";

const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSLIST_ID = "arcontroller_dictionary_key_debug_settingslist_id";
const char *ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSLIST_VALUE = "arcontroller_dictionary_key_debug_settingslist_value";

ARCONTROLLER_FEATURE_Debug_t *ARCONTROLLER_FEATURE_Debug_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Debug_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Debug_t));
        if (featureController != NULL)
        {
            featureController->sendGetAllSettings = ARCONTROLLER_FEATURE_Debug_SendGetAllSettings;
            featureController->sendSetSetting = ARCONTROLLER_FEATURE_Debug_SendSetSetting;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Debug_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Debug_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Debug_Delete (ARCONTROLLER_FEATURE_Debug_t **feature)
{
    // -- Delete the debug feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Debug_GetDictionary (ARCONTROLLER_FEATURE_Debug_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the debug Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Debug_AddCallback (ARCONTROLLER_FEATURE_Debug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Debug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Debug_RemoveCallback (ARCONTROLLER_FEATURE_Debug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Debug</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Debug_RegisterARCommands (ARCONTROLLER_FEATURE_Debug_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetDebugSettingsInfoCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Debug_SettingsInfoCallback, feature);
        ARCOMMANDS_Decoder_SetDebugSettingsListCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Debug_SettingsListCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Debug_UnregisterARCommands (ARCONTROLLER_FEATURE_Debug_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetDebugSettingsInfoCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetDebugSettingsListCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Debug_SendGetAllSettings (ARCONTROLLER_FEATURE_Debug_t *feature)
{
    // -- Send a command <code>GetAllSettings</code> in project <code>Debug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAllSettings command
        cmdError = ARCOMMANDS_Generator_GenerateDebugGetAllSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Debug_SendSetSetting (ARCONTROLLER_FEATURE_Debug_t *feature, uint16_t id, char * value)
{
    // -- Send a command <code>SetSetting</code> in project <code>Debug</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetSetting command
        cmdError = ARCOMMANDS_Generator_GenerateDebugSetSetting(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Debug_SettingsInfoCallback (uint8_t _list_flags, uint16_t _id, const char * _label, eARCOMMANDS_DEBUG_SETTING_TYPE _type, eARCOMMANDS_DEBUG_SETTING_MODE _mode, const char * _range_min, const char * _range_max, const char * _range_step, const char * _value, void *customData)
{
    // -- callback used when the command <code>SettingsInfo</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Debug_t *feature = (ARCONTROLLER_FEATURE_Debug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                listIndex = HASH_COUNT (dictCmdElement->elements);
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
            
            //Create new element
            newElement = ARCONTROLLER_Debug_NewCmdElementSettingsInfo (feature, _list_flags,  _id,  _label,  _type,  _mode,  _range_min,  _range_max,  _range_step,  _value, listIndex, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Debug_SettingsListCallback (uint16_t _id, const char * _value, void *customData)
{
    // -- callback used when the command <code>SettingsList</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Debug_t *feature = (ARCONTROLLER_FEATURE_Debug_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSLIST;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Debug_NewCmdElementSettingsList (feature,  _id,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Debug_NewCmdElementSettingsInfo (ARCONTROLLER_FEATURE_Debug_t *feature, uint8_t _list_flags, uint16_t _id, const char * _label, eARCOMMANDS_DEBUG_SETTING_TYPE _type, eARCOMMANDS_DEBUG_SETTING_MODE _mode, const char * _range_min, const char * _range_max, const char * _range_step, const char * _value, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsInfo -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_ID;
            argDictNewElement->value.U16 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_LABEL;
            strLength = strlen (_label);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _label, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_RANGE_MIN;
            strLength = strlen (_range_min);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _range_min, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_RANGE_MAX;
            strLength = strlen (_range_max);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _range_max, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_RANGE_STEP;
            strLength = strlen (_range_step);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _range_step, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSINFO_VALUE;
            strLength = strlen (_value);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _value, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Debug_NewCmdElementSettingsList (ARCONTROLLER_FEATURE_Debug_t *feature, uint16_t _id, const char * _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsList -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSLIST_ID;
            argDictNewElement->value.U16 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DEBUG_SETTINGSLIST_VALUE;
            strLength = strlen (_value);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _value, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Debug_SetNetworkController (ARCONTROLLER_FEATURE_Debug_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Debug_GetCommandElements (ARCONTROLLER_FEATURE_Debug_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE drone_manager --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_SERIAL = "arcontroller_dictionary_key_drone_manager_dronelistitem_serial";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_MODEL = "arcontroller_dictionary_key_drone_manager_dronelistitem_model";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_NAME = "arcontroller_dictionary_key_drone_manager_dronelistitem_name";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_CONNECTION_ORDER = "arcontroller_dictionary_key_drone_manager_dronelistitem_connection_order";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_ACTIVE = "arcontroller_dictionary_key_drone_manager_dronelistitem_active";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_VISIBLE = "arcontroller_dictionary_key_drone_manager_dronelistitem_visible";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_SECURITY = "arcontroller_dictionary_key_drone_manager_dronelistitem_security";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_HAS_SAVED_KEY = "arcontroller_dictionary_key_drone_manager_dronelistitem_has_saved_key";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_RSSI = "arcontroller_dictionary_key_drone_manager_dronelistitem_rssi";

const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_STATE = "arcontroller_dictionary_key_drone_manager_connectionstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_SERIAL = "arcontroller_dictionary_key_drone_manager_connectionstate_serial";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_MODEL = "arcontroller_dictionary_key_drone_manager_connectionstate_model";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_NAME = "arcontroller_dictionary_key_drone_manager_connectionstate_name";

const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_AUTHENTICATIONFAILED_SERIAL = "arcontroller_dictionary_key_drone_manager_authenticationfailed_serial";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_AUTHENTICATIONFAILED_MODEL = "arcontroller_dictionary_key_drone_manager_authenticationfailed_model";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_AUTHENTICATIONFAILED_NAME = "arcontroller_dictionary_key_drone_manager_authenticationfailed_name";

const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONREFUSED_SERIAL = "arcontroller_dictionary_key_drone_manager_connectionrefused_serial";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONREFUSED_MODEL = "arcontroller_dictionary_key_drone_manager_connectionrefused_model";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONREFUSED_NAME = "arcontroller_dictionary_key_drone_manager_connectionrefused_name";

const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_SERIAL = "arcontroller_dictionary_key_drone_manager_knowndroneitem_serial";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_MODEL = "arcontroller_dictionary_key_drone_manager_knowndroneitem_model";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_NAME = "arcontroller_dictionary_key_drone_manager_knowndroneitem_name";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_SECURITY = "arcontroller_dictionary_key_drone_manager_knowndroneitem_security";
const char *ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_HAS_SAVED_KEY = "arcontroller_dictionary_key_drone_manager_knowndroneitem_has_saved_key";

ARCONTROLLER_FEATURE_DroneManager_t *ARCONTROLLER_FEATURE_DroneManager_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_DroneManager_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_DroneManager_t));
        if (featureController != NULL)
        {
            featureController->sendDiscoverDrones = ARCONTROLLER_FEATURE_DroneManager_SendDiscoverDrones;
            featureController->sendConnect = ARCONTROLLER_FEATURE_DroneManager_SendConnect;
            featureController->sendForget = ARCONTROLLER_FEATURE_DroneManager_SendForget;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_DroneManager_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_DroneManager_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_DroneManager_Delete (ARCONTROLLER_FEATURE_DroneManager_t **feature)
{
    // -- Delete the drone_manager feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_DroneManager_GetDictionary (ARCONTROLLER_FEATURE_DroneManager_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the drone_manager Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_AddCallback (ARCONTROLLER_FEATURE_DroneManager_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>DroneManager</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_RemoveCallback (ARCONTROLLER_FEATURE_DroneManager_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>DroneManager</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_RegisterARCommands (ARCONTROLLER_FEATURE_DroneManager_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetDroneManagerDroneListItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_DroneManager_DroneListItemCallback, feature);
        ARCOMMANDS_Decoder_SetDroneManagerConnectionStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_DroneManager_ConnectionStateCallback, feature);
        ARCOMMANDS_Decoder_SetDroneManagerAuthenticationFailedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_DroneManager_AuthenticationFailedCallback, feature);
        ARCOMMANDS_Decoder_SetDroneManagerConnectionRefusedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_DroneManager_ConnectionRefusedCallback, feature);
        ARCOMMANDS_Decoder_SetDroneManagerKnownDroneItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_DroneManager_KnownDroneItemCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_UnregisterARCommands (ARCONTROLLER_FEATURE_DroneManager_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetDroneManagerDroneListItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetDroneManagerConnectionStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetDroneManagerAuthenticationFailedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetDroneManagerConnectionRefusedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetDroneManagerKnownDroneItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_SendDiscoverDrones (ARCONTROLLER_FEATURE_DroneManager_t *feature)
{
    // -- Send a command <code>DiscoverDrones</code> in project <code>DroneManager</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DiscoverDrones command
        cmdError = ARCOMMANDS_Generator_GenerateDroneManagerDiscoverDrones(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_SendConnect (ARCONTROLLER_FEATURE_DroneManager_t *feature, char * serial, char * key)
{
    // -- Send a command <code>Connect</code> in project <code>DroneManager</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Connect command
        cmdError = ARCOMMANDS_Generator_GenerateDroneManagerConnect(cmdBuffer, sizeof(cmdBuffer), &cmdSize, serial, key);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_SendForget (ARCONTROLLER_FEATURE_DroneManager_t *feature, char * serial)
{
    // -- Send a command <code>Forget</code> in project <code>DroneManager</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Forget command
        cmdError = ARCOMMANDS_Generator_GenerateDroneManagerForget(cmdBuffer, sizeof(cmdBuffer), &cmdSize, serial);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_DroneManager_DroneListItemCallback (const char * _serial, uint16_t _model, const char * _name, uint8_t _connection_order, uint8_t _active, uint8_t _visible, eARCOMMANDS_DRONE_MANAGER_SECURITY _security, uint8_t _has_saved_key, int8_t _rssi, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>DroneListItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_DroneManager_t *feature = (ARCONTROLLER_FEATURE_DroneManager_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            HASH_FIND_STR (dictCmdElement->elements, _serial, dictElement);
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_DroneManager_NewCmdElementDroneListItem (feature, _serial,  _model,  _name,  _connection_order,  _active,  _visible,  _security,  _has_saved_key,  _rssi,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_DroneManager_ConnectionStateCallback (eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE _state, const char * _serial, uint16_t _model, const char * _name, void *customData)
{
    // -- callback used when the command <code>ConnectionState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_DroneManager_t *feature = (ARCONTROLLER_FEATURE_DroneManager_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_DroneManager_NewCmdElementConnectionState (feature,  _state,  _serial,  _model,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_DroneManager_AuthenticationFailedCallback (const char * _serial, uint16_t _model, const char * _name, void *customData)
{
    // -- callback used when the command <code>AuthenticationFailed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_DroneManager_t *feature = (ARCONTROLLER_FEATURE_DroneManager_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_AUTHENTICATIONFAILED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_DroneManager_NewCmdElementAuthenticationFailed (feature,  _serial,  _model,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_DroneManager_ConnectionRefusedCallback (const char * _serial, uint16_t _model, const char * _name, void *customData)
{
    // -- callback used when the command <code>ConnectionRefused</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_DroneManager_t *feature = (ARCONTROLLER_FEATURE_DroneManager_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONREFUSED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_DroneManager_NewCmdElementConnectionRefused (feature,  _serial,  _model,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_DroneManager_KnownDroneItemCallback (const char * _serial, uint16_t _model, const char * _name, eARCOMMANDS_DRONE_MANAGER_SECURITY _security, uint8_t _has_saved_key, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>KnownDroneItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_DroneManager_t *feature = (ARCONTROLLER_FEATURE_DroneManager_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            HASH_FIND_STR (dictCmdElement->elements, _serial, dictElement);
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_DroneManager_NewCmdElementKnownDroneItem (feature, _serial,  _model,  _name,  _security,  _has_saved_key,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_DroneManager_NewCmdElementDroneListItem (ARCONTROLLER_FEATURE_DroneManager_t *feature, const char * _serial, uint16_t _model, const char * _name, uint8_t _connection_order, uint8_t _active, uint8_t _visible, eARCOMMANDS_DRONE_MANAGER_SECURITY _security, uint8_t _has_saved_key, int8_t _rssi, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DroneListItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_serial);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _serial, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_SERIAL;
            strLength = strlen (_serial);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serial, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_MODEL;
            argDictNewElement->value.U16 = _model;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_CONNECTION_ORDER;
            argDictNewElement->value.U8 = _connection_order;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_ACTIVE;
            argDictNewElement->value.U8 = _active;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_VISIBLE;
            argDictNewElement->value.U8 = _visible;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_SECURITY;
            argDictNewElement->value.I32 = _security;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_HAS_SAVED_KEY;
            argDictNewElement->value.U8 = _has_saved_key;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_DRONELISTITEM_RSSI;
            argDictNewElement->value.I8 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_DroneManager_NewCmdElementConnectionState (ARCONTROLLER_FEATURE_DroneManager_t *feature, eARCOMMANDS_DRONE_MANAGER_CONNECTION_STATE _state, const char * _serial, uint16_t _model, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ConnectionState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_SERIAL;
            strLength = strlen (_serial);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serial, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_MODEL;
            argDictNewElement->value.U16 = _model;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONSTATE_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_DroneManager_NewCmdElementAuthenticationFailed (ARCONTROLLER_FEATURE_DroneManager_t *feature, const char * _serial, uint16_t _model, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AuthenticationFailed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_AUTHENTICATIONFAILED_SERIAL;
            strLength = strlen (_serial);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serial, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_AUTHENTICATIONFAILED_MODEL;
            argDictNewElement->value.U16 = _model;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_AUTHENTICATIONFAILED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_DroneManager_NewCmdElementConnectionRefused (ARCONTROLLER_FEATURE_DroneManager_t *feature, const char * _serial, uint16_t _model, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ConnectionRefused -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONREFUSED_SERIAL;
            strLength = strlen (_serial);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serial, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONREFUSED_MODEL;
            argDictNewElement->value.U16 = _model;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_CONNECTIONREFUSED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_DroneManager_NewCmdElementKnownDroneItem (ARCONTROLLER_FEATURE_DroneManager_t *feature, const char * _serial, uint16_t _model, const char * _name, eARCOMMANDS_DRONE_MANAGER_SECURITY _security, uint8_t _has_saved_key, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event KnownDroneItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_serial);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _serial, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_SERIAL;
            strLength = strlen (_serial);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serial, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_MODEL;
            argDictNewElement->value.U16 = _model;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_SECURITY;
            argDictNewElement->value.I32 = _security;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_DRONE_MANAGER_KNOWNDRONEITEM_HAS_SAVED_KEY;
            argDictNewElement->value.U8 = _has_saved_key;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_DroneManager_SetNetworkController (ARCONTROLLER_FEATURE_DroneManager_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_DroneManager_GetCommandElements (ARCONTROLLER_FEATURE_DroneManager_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE follow_me --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_MODE = "arcontroller_dictionary_key_follow_me_state_mode";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_BEHAVIOR = "arcontroller_dictionary_key_follow_me_state_behavior";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_ANIMATION = "arcontroller_dictionary_key_follow_me_state_animation";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_ANIMATION_AVAILABLE = "arcontroller_dictionary_key_follow_me_state_animation_available";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_MODEINFO_MODE = "arcontroller_dictionary_key_follow_me_modeinfo_mode";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_MODEINFO_MISSING_REQUIREMENTS = "arcontroller_dictionary_key_follow_me_modeinfo_missing_requirements";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_MODEINFO_IMPROVEMENTS = "arcontroller_dictionary_key_follow_me_modeinfo_improvements";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_USE_DEFAULT = "arcontroller_dictionary_key_follow_me_geographicconfig_use_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_DISTANCE = "arcontroller_dictionary_key_follow_me_geographicconfig_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_ELEVATION = "arcontroller_dictionary_key_follow_me_geographicconfig_elevation";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_AZIMUTH = "arcontroller_dictionary_key_follow_me_geographicconfig_azimuth";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_USE_DEFAULT = "arcontroller_dictionary_key_follow_me_relativeconfig_use_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_DISTANCE = "arcontroller_dictionary_key_follow_me_relativeconfig_distance";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_ELEVATION = "arcontroller_dictionary_key_follow_me_relativeconfig_elevation";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_AZIMUTH = "arcontroller_dictionary_key_follow_me_relativeconfig_azimuth";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_LATITUDE = "arcontroller_dictionary_key_follow_me_targettrajectory_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_LONGITUDE = "arcontroller_dictionary_key_follow_me_targettrajectory_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_ALTITUDE = "arcontroller_dictionary_key_follow_me_targettrajectory_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_NORTH_SPEED = "arcontroller_dictionary_key_follow_me_targettrajectory_north_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_EAST_SPEED = "arcontroller_dictionary_key_follow_me_targettrajectory_east_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_DOWN_SPEED = "arcontroller_dictionary_key_follow_me_targettrajectory_down_speed";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_USE_DEFAULT = "arcontroller_dictionary_key_follow_me_helicoidanimconfig_use_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_SPEED = "arcontroller_dictionary_key_follow_me_helicoidanimconfig_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_REVOLUTION_NB = "arcontroller_dictionary_key_follow_me_helicoidanimconfig_revolution_nb";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_VERTICAL_DISTANCE = "arcontroller_dictionary_key_follow_me_helicoidanimconfig_vertical_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIG_USE_DEFAULT = "arcontroller_dictionary_key_follow_me_swinganimconfig_use_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIG_SPEED = "arcontroller_dictionary_key_follow_me_swinganimconfig_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIG_VERTICAL_DISTANCE = "arcontroller_dictionary_key_follow_me_swinganimconfig_vertical_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIG_USE_DEFAULT = "arcontroller_dictionary_key_follow_me_boomeranganimconfig_use_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIG_SPEED = "arcontroller_dictionary_key_follow_me_boomeranganimconfig_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIG_DISTANCE = "arcontroller_dictionary_key_follow_me_boomeranganimconfig_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIG_USE_DEFAULT = "arcontroller_dictionary_key_follow_me_candleanimconfig_use_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIG_SPEED = "arcontroller_dictionary_key_follow_me_candleanimconfig_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIG_VERTICAL_DISTANCE = "arcontroller_dictionary_key_follow_me_candleanimconfig_vertical_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_USE_DEFAULT = "arcontroller_dictionary_key_follow_me_dollyslideanimconfig_use_default";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_SPEED = "arcontroller_dictionary_key_follow_me_dollyslideanimconfig_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_ANGLE = "arcontroller_dictionary_key_follow_me_dollyslideanimconfig_angle";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_HORIZONTAL_DISTANCE = "arcontroller_dictionary_key_follow_me_dollyslideanimconfig_horizontal_distance";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETFRAMINGPOSITIONCHANGED_HORIZONTAL = "arcontroller_dictionary_key_follow_me_targetframingpositionchanged_horizontal";
const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETFRAMINGPOSITIONCHANGED_VERTICAL = "arcontroller_dictionary_key_follow_me_targetframingpositionchanged_vertical";

const char *ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETIMAGEDETECTIONSTATE_STATE = "arcontroller_dictionary_key_follow_me_targetimagedetectionstate_state";

ARCONTROLLER_FEATURE_FollowMe_t *ARCONTROLLER_FEATURE_FollowMe_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_FollowMe_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_FollowMe_t));
        if (featureController != NULL)
        {
            featureController->sendStart = ARCONTROLLER_FEATURE_FollowMe_SendStart;
            featureController->sendStop = ARCONTROLLER_FEATURE_FollowMe_SendStop;
            featureController->sendConfigureGeographic = ARCONTROLLER_FEATURE_FollowMe_SendConfigureGeographic;
            featureController->sendConfigureRelative = ARCONTROLLER_FEATURE_FollowMe_SendConfigureRelative;
            featureController->sendStopAnimation = ARCONTROLLER_FEATURE_FollowMe_SendStopAnimation;
            featureController->sendStartHelicoidAnim = ARCONTROLLER_FEATURE_FollowMe_SendStartHelicoidAnim;
            featureController->sendStartSwingAnim = ARCONTROLLER_FEATURE_FollowMe_SendStartSwingAnim;
            featureController->sendStartBoomerangAnim = ARCONTROLLER_FEATURE_FollowMe_SendStartBoomerangAnim;
            featureController->sendStartCandleAnim = ARCONTROLLER_FEATURE_FollowMe_SendStartCandleAnim;
            featureController->sendStartDollySlideAnim = ARCONTROLLER_FEATURE_FollowMe_SendStartDollySlideAnim;
            featureController->sendTargetFramingPosition = ARCONTROLLER_FEATURE_FollowMe_SendTargetFramingPosition;
            featureController->sendTargetImageDetection = ARCONTROLLER_FEATURE_FollowMe_SendTargetImageDetection;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_FollowMe_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_FollowMe_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_FollowMe_Delete (ARCONTROLLER_FEATURE_FollowMe_t **feature)
{
    // -- Delete the follow_me feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_FollowMe_GetDictionary (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the follow_me Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_AddCallback (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>FollowMe</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_RemoveCallback (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>FollowMe</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_RegisterARCommands (ARCONTROLLER_FEATURE_FollowMe_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetFollowMeStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_StateCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeModeInfoCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_ModeInfoCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeGeographicConfigCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_GeographicConfigCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeRelativeConfigCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_RelativeConfigCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeTargetTrajectoryCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_TargetTrajectoryCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeHelicoidAnimConfigCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_HelicoidAnimConfigCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeSwingAnimConfigCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_SwingAnimConfigCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeBoomerangAnimConfigCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_BoomerangAnimConfigCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeCandleAnimConfigCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_CandleAnimConfigCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeDollySlideAnimConfigCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_DollySlideAnimConfigCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeTargetFramingPositionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_TargetFramingPositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetFollowMeTargetImageDetectionStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_FollowMe_TargetImageDetectionStateCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_UnregisterARCommands (ARCONTROLLER_FEATURE_FollowMe_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetFollowMeStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeModeInfoCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeGeographicConfigCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeRelativeConfigCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeTargetTrajectoryCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeHelicoidAnimConfigCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeSwingAnimConfigCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeBoomerangAnimConfigCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeCandleAnimConfigCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeDollySlideAnimConfigCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeTargetFramingPositionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetFollowMeTargetImageDetectionStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStart (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCOMMANDS_FOLLOW_ME_MODE mode)
{
    // -- Send a command <code>Start</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Start command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStart(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStop (ARCONTROLLER_FEATURE_FollowMe_t *feature)
{
    // -- Send a command <code>Stop</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Stop command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStop(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendConfigureGeographic (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t use_default, float distance, float elevation, float azimuth)
{
    // -- Send a command <code>ConfigureGeographic</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConfigureGeographic command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeConfigureGeographic(cmdBuffer, sizeof(cmdBuffer), &cmdSize, use_default, distance, elevation, azimuth);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendConfigureRelative (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t use_default, float distance, float elevation, float azimuth)
{
    // -- Send a command <code>ConfigureRelative</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConfigureRelative command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeConfigureRelative(cmdBuffer, sizeof(cmdBuffer), &cmdSize, use_default, distance, elevation, azimuth);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStopAnimation (ARCONTROLLER_FEATURE_FollowMe_t *feature)
{
    // -- Send a command <code>StopAnimation</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StopAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStopAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStartHelicoidAnim (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t use_default, float speed, float revolution_number, float vertical_distance)
{
    // -- Send a command <code>StartHelicoidAnim</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartHelicoidAnim command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStartHelicoidAnim(cmdBuffer, sizeof(cmdBuffer), &cmdSize, use_default, speed, revolution_number, vertical_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStartSwingAnim (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t use_default, float speed, float vertical_distance)
{
    // -- Send a command <code>StartSwingAnim</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartSwingAnim command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStartSwingAnim(cmdBuffer, sizeof(cmdBuffer), &cmdSize, use_default, speed, vertical_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStartBoomerangAnim (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t use_default, float speed, float distance)
{
    // -- Send a command <code>StartBoomerangAnim</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartBoomerangAnim command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStartBoomerangAnim(cmdBuffer, sizeof(cmdBuffer), &cmdSize, use_default, speed, distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStartCandleAnim (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t use_default, float speed, float vertical_distance)
{
    // -- Send a command <code>StartCandleAnim</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartCandleAnim command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStartCandleAnim(cmdBuffer, sizeof(cmdBuffer), &cmdSize, use_default, speed, vertical_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendStartDollySlideAnim (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t use_default, float speed, float angle, float horizontal_distance)
{
    // -- Send a command <code>StartDollySlideAnim</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartDollySlideAnim command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeStartDollySlideAnim(cmdBuffer, sizeof(cmdBuffer), &cmdSize, use_default, speed, angle, horizontal_distance);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendTargetFramingPosition (ARCONTROLLER_FEATURE_FollowMe_t *feature, int8_t horizontal, int8_t vertical)
{
    // -- Send a command <code>TargetFramingPosition</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TargetFramingPosition command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeTargetFramingPosition(cmdBuffer, sizeof(cmdBuffer), &cmdSize, horizontal, vertical);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SendTargetImageDetection (ARCONTROLLER_FEATURE_FollowMe_t *feature, float target_azimuth, float target_elevation, float change_of_scale, uint8_t confidence_index, uint8_t is_new_selection, uint64_t timestamp)
{
    // -- Send a command <code>TargetImageDetection</code> in project <code>FollowMe</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TargetImageDetection command
        cmdError = ARCOMMANDS_Generator_GenerateFollowMeTargetImageDetection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, target_azimuth, target_elevation, change_of_scale, confidence_index, is_new_selection, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_FollowMe_StateCallback (eARCOMMANDS_FOLLOW_ME_MODE _mode, eARCOMMANDS_FOLLOW_ME_BEHAVIOR _behavior, eARCOMMANDS_FOLLOW_ME_ANIMATION _animation, uint16_t _animation_available, void *customData)
{
    // -- callback used when the command <code>State</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementState (feature,  _mode,  _behavior,  _animation,  _animation_available, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_ModeInfoCallback (eARCOMMANDS_FOLLOW_ME_MODE _mode, uint16_t _missing_requirements, uint16_t _improvements, void *customData)
{
    // -- callback used when the command <code>ModeInfo</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_MODEINFO;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementModeInfo (feature,  _mode,  _missing_requirements,  _improvements, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_GeographicConfigCallback (uint8_t _use_default, float _distance, float _elevation, float _azimuth, void *customData)
{
    // -- callback used when the command <code>GeographicConfig</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementGeographicConfig (feature,  _use_default,  _distance,  _elevation,  _azimuth, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_RelativeConfigCallback (uint8_t _use_default, float _distance, float _elevation, float _azimuth, void *customData)
{
    // -- callback used when the command <code>RelativeConfig</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementRelativeConfig (feature,  _use_default,  _distance,  _elevation,  _azimuth, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_TargetTrajectoryCallback (double _latitude, double _longitude, float _altitude, float _north_speed, float _east_speed, float _down_speed, void *customData)
{
    // -- callback used when the command <code>TargetTrajectory</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementTargetTrajectory (feature,  _latitude,  _longitude,  _altitude,  _north_speed,  _east_speed,  _down_speed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_HelicoidAnimConfigCallback (uint8_t _use_default, float _speed, float _revolution_nb, float _vertical_distance, void *customData)
{
    // -- callback used when the command <code>HelicoidAnimConfig</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementHelicoidAnimConfig (feature,  _use_default,  _speed,  _revolution_nb,  _vertical_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_SwingAnimConfigCallback (uint8_t _use_default, float _speed, float _vertical_distance, void *customData)
{
    // -- callback used when the command <code>SwingAnimConfig</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIG;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementSwingAnimConfig (feature,  _use_default,  _speed,  _vertical_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_BoomerangAnimConfigCallback (uint8_t _use_default, float _speed, float _distance, void *customData)
{
    // -- callback used when the command <code>BoomerangAnimConfig</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIG;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementBoomerangAnimConfig (feature,  _use_default,  _speed,  _distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_CandleAnimConfigCallback (uint8_t _use_default, float _speed, float _vertical_distance, void *customData)
{
    // -- callback used when the command <code>CandleAnimConfig</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIG;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementCandleAnimConfig (feature,  _use_default,  _speed,  _vertical_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_DollySlideAnimConfigCallback (uint8_t _use_default, float _speed, float _angle, float _horizontal_distance, void *customData)
{
    // -- callback used when the command <code>DollySlideAnimConfig</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementDollySlideAnimConfig (feature,  _use_default,  _speed,  _angle,  _horizontal_distance, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_TargetFramingPositionChangedCallback (int8_t _horizontal, int8_t _vertical, void *customData)
{
    // -- callback used when the command <code>TargetFramingPositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETFRAMINGPOSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementTargetFramingPositionChanged (feature,  _horizontal,  _vertical, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_FollowMe_TargetImageDetectionStateCallback (eARCOMMANDS_FOLLOW_ME_IMAGE_DETECTION_STATUS _state, void *customData)
{
    // -- callback used when the command <code>TargetImageDetectionState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_FollowMe_t *feature = (ARCONTROLLER_FEATURE_FollowMe_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETIMAGEDETECTIONSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_FollowMe_NewCmdElementTargetImageDetectionState (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementState (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCOMMANDS_FOLLOW_ME_MODE _mode, eARCOMMANDS_FOLLOW_ME_BEHAVIOR _behavior, eARCOMMANDS_FOLLOW_ME_ANIMATION _animation, uint16_t _animation_available, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event State -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_BEHAVIOR;
            argDictNewElement->value.I32 = _behavior;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_ANIMATION;
            argDictNewElement->value.I32 = _animation;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_STATE_ANIMATION_AVAILABLE;
            argDictNewElement->value.U16 = _animation_available;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementModeInfo (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCOMMANDS_FOLLOW_ME_MODE _mode, uint16_t _missing_requirements, uint16_t _improvements, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ModeInfo -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _mode);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _mode);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_MODEINFO_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_MODEINFO_MISSING_REQUIREMENTS;
            argDictNewElement->value.U16 = _missing_requirements;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_MODEINFO_IMPROVEMENTS;
            argDictNewElement->value.U16 = _improvements;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementGeographicConfig (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _use_default, float _distance, float _elevation, float _azimuth, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GeographicConfig -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_USE_DEFAULT;
            argDictNewElement->value.U8 = _use_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_ELEVATION;
            argDictNewElement->value.Float = _elevation;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_GEOGRAPHICCONFIG_AZIMUTH;
            argDictNewElement->value.Float = _azimuth;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementRelativeConfig (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _use_default, float _distance, float _elevation, float _azimuth, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RelativeConfig -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_USE_DEFAULT;
            argDictNewElement->value.U8 = _use_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_ELEVATION;
            argDictNewElement->value.Float = _elevation;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_RELATIVECONFIG_AZIMUTH;
            argDictNewElement->value.Float = _azimuth;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementTargetTrajectory (ARCONTROLLER_FEATURE_FollowMe_t *feature, double _latitude, double _longitude, float _altitude, float _north_speed, float _east_speed, float _down_speed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event TargetTrajectory -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_ALTITUDE;
            argDictNewElement->value.Float = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_NORTH_SPEED;
            argDictNewElement->value.Float = _north_speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_EAST_SPEED;
            argDictNewElement->value.Float = _east_speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETTRAJECTORY_DOWN_SPEED;
            argDictNewElement->value.Float = _down_speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementHelicoidAnimConfig (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _use_default, float _speed, float _revolution_nb, float _vertical_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event HelicoidAnimConfig -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_USE_DEFAULT;
            argDictNewElement->value.U8 = _use_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_REVOLUTION_NB;
            argDictNewElement->value.Float = _revolution_nb;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_HELICOIDANIMCONFIG_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementSwingAnimConfig (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _use_default, float _speed, float _vertical_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SwingAnimConfig -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIG_USE_DEFAULT;
            argDictNewElement->value.U8 = _use_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIG_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_SWINGANIMCONFIG_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementBoomerangAnimConfig (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _use_default, float _speed, float _distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event BoomerangAnimConfig -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIG_USE_DEFAULT;
            argDictNewElement->value.U8 = _use_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIG_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_BOOMERANGANIMCONFIG_DISTANCE;
            argDictNewElement->value.Float = _distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementCandleAnimConfig (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _use_default, float _speed, float _vertical_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CandleAnimConfig -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIG_USE_DEFAULT;
            argDictNewElement->value.U8 = _use_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIG_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_CANDLEANIMCONFIG_VERTICAL_DISTANCE;
            argDictNewElement->value.Float = _vertical_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementDollySlideAnimConfig (ARCONTROLLER_FEATURE_FollowMe_t *feature, uint8_t _use_default, float _speed, float _angle, float _horizontal_distance, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DollySlideAnimConfig -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_USE_DEFAULT;
            argDictNewElement->value.U8 = _use_default;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_SPEED;
            argDictNewElement->value.Float = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_ANGLE;
            argDictNewElement->value.Float = _angle;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_DOLLYSLIDEANIMCONFIG_HORIZONTAL_DISTANCE;
            argDictNewElement->value.Float = _horizontal_distance;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementTargetFramingPositionChanged (ARCONTROLLER_FEATURE_FollowMe_t *feature, int8_t _horizontal, int8_t _vertical, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event TargetFramingPositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETFRAMINGPOSITIONCHANGED_HORIZONTAL;
            argDictNewElement->value.I8 = _horizontal;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETFRAMINGPOSITIONCHANGED_VERTICAL;
            argDictNewElement->value.I8 = _vertical;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_NewCmdElementTargetImageDetectionState (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCOMMANDS_FOLLOW_ME_IMAGE_DETECTION_STATUS _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event TargetImageDetectionState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_FOLLOW_ME_TARGETIMAGEDETECTIONSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_FollowMe_SetNetworkController (ARCONTROLLER_FEATURE_FollowMe_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_FollowMe_GetCommandElements (ARCONTROLLER_FEATURE_FollowMe_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE JumpingSumo --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_posturechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_alertstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_SPEED = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_speedchanged_speed";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_REALSPEED = "arcontroller_dictionary_key_jumpingsumo_pilotingstate_speedchanged_realspeed";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumploadchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumptypechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_animationsstate_jumpmotorproblemchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_jumpingsumo_settingsstate_productgpsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_jumpingsumo_settingsstate_productgpsversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordstate_videostatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_pictureeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_videoeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR = "arcontroller_dictionary_key_jumpingsumo_mediarecordevent_videoeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networksettingsstate_wifiselectionchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_SSID = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiscanlistchanged_channel";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_jumpingsumo_networkstate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY = "arcontroller_dictionary_key_jumpingsumo_networkstate_linkqualitychanged_quality";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED_VOLUME = "arcontroller_dictionary_key_jumpingsumo_audiosettingsstate_mastervolumechanged_volume";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME = "arcontroller_dictionary_key_jumpingsumo_audiosettingsstate_themechanged_theme";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_UUID = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_uuid";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_VERSION = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_version";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_PRODUCT = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_product";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_NAME = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_name";
const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_LASTMODIFIED = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptmetadatalistchanged_lastmodified";


const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptuploadchanged_resultcode";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_scriptdeletechanged_resultcode";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE = "arcontroller_dictionary_key_jumpingsumo_roadplanstate_playscriptchanged_resultcode";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR = "arcontroller_dictionary_key_jumpingsumo_speedsettingsstate_outdoorchanged_outdoor";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED = "arcontroller_dictionary_key_jumpingsumo_mediastreamingstate_videoenablechanged_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED = "arcontroller_dictionary_key_jumpingsumo_videosettingsstate_autorecordchanged_enabled";

ARCONTROLLER_FEATURE_JumpingSumo_t *ARCONTROLLER_FEATURE_JumpingSumo_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_JumpingSumo_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumo_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDSpeed = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDSpeed;
            featureController->setPilotingPCMDTurn = ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDTurn;
            featureController->sendPilotingPosture = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPosture;
            featureController->sendPilotingAddCapOffset = ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingAddCapOffset;
            featureController->sendAnimationsJumpStop = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpStop;
            featureController->sendAnimationsJumpCancel = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpCancel;
            featureController->sendAnimationsJumpLoad = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpLoad;
            featureController->sendAnimationsJump = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJump;
            featureController->sendAnimationsSimpleAnimation = ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsSimpleAnimation;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPicture;
            featureController->sendMediaRecordVideo = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideo;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPictureV2;
            featureController->sendMediaRecordVideoV2 = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideoV2;
            featureController->sendNetworkSettingsWifiSelection = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkSettingsWifiSelection;
            featureController->sendNetworkWifiScan = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiScan;
            featureController->sendNetworkWifiAuthChannel = ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiAuthChannel;
            featureController->sendAudioSettingsMasterVolume = ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsMasterVolume;
            featureController->sendAudioSettingsTheme = ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsTheme;
            featureController->sendRoadPlanAllScriptsMetadata = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanAllScriptsMetadata;
            featureController->sendRoadPlanScriptUploaded = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptUploaded;
            featureController->sendRoadPlanScriptDelete = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptDelete;
            featureController->sendRoadPlanPlayScript = ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanPlayScript;
            featureController->sendSpeedSettingsOutdoor = ARCONTROLLER_FEATURE_JumpingSumo_SendSpeedSettingsOutdoor;
            featureController->sendMediaStreamingVideoEnable = ARCONTROLLER_FEATURE_JumpingSumo_SendMediaStreamingVideoEnable;
            featureController->sendVideoSettingsAutorecord = ARCONTROLLER_FEATURE_JumpingSumo_SendVideoSettingsAutorecord;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_JumpingSumo_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->PilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->PilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_JumpingSumo_PilotingPCMDParameters_t));
        if (featureController->privatePart->PilotingPCMDParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_JumpingSumoPilotingPCMDInit (featureController);
    }

    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_JumpingSumo_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_JumpingSumo_Delete (ARCONTROLLER_FEATURE_JumpingSumo_t **feature)
{
    // -- Delete the JumpingSumo feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->PilotingPCMDParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_JumpingSumoPilotingPCMDDeInit (*feature);

                    free ((*feature)->privatePart->PilotingPCMDParameters);
                    (*feature)->privatePart->PilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_JumpingSumo_GetDictionary (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the JumpingSumo Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_AddCallback (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>JumpingSumo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_RemoveCallback (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>JumpingSumo</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_RegisterARCommands (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_PilotingStatePostureChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpLoadChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpTypeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpMotorProblemChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_SettingsStateProductGPSVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventVideoEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_NetworkSettingsStateWifiSelectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiScanListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiScanChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateLinkQualityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateMasterVolumeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateThemeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptMetadataListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateAllScriptsMetadataChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptUploadChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptDeleteChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStatePlayScriptChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_SpeedSettingsStateOutdoorChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_MediaStreamingStateVideoEnableChangedCallback, feature);
        ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsStateAutorecordChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_JumpingSumo_VideoSettingsStateAutorecordChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_UnregisterARCommands (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStatePostureChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoPilotingStateSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpLoadChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpTypeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAnimationsStateJumpMotorProblemChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoSettingsStateProductGPSVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordStateVideoStateChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaRecordEventVideoEventChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiScanListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiScanChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoNetworkStateLinkQualityChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateMasterVolumeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoAudioSettingsStateThemeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptMetadataListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateAllScriptsMetadataChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptUploadChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStateScriptDeleteChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoRoadPlanStatePlayScriptChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoSpeedSettingsStateOutdoorChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoMediaStreamingStateVideoEnableChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetJumpingSumoVideoSettingsStateAutorecordChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPCMD (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t flag, int8_t speed, int8_t turn)
{
    // -- Send a command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, speed, turn);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMD (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _flag, int8_t _speed, int8_t _turn)
{
    // -- Set the parameter for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
        feature->privatePart->PilotingPCMDParameters->speed = _speed;
        feature->privatePart->PilotingPCMDParameters->turn = _turn;

            ARCONTROLLER_NAckCbs_JumpingSumoPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_JumpingSumo_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->PilotingPCMDParameters->flag, feature->privatePart->PilotingPCMDParameters->speed, feature->privatePart->PilotingPCMDParameters->turn);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;

        ARCONTROLLER_NAckCbs_JumpingSumoPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDSpeed (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _speed)
{
    // -- Set the speed for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->speed = _speed;

        ARCONTROLLER_NAckCbs_JumpingSumoPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetPilotingPCMDTurn (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _turn)
{
    // -- Set the turn for the command <code>PilotingPCMD</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->turn = _turn;

        ARCONTROLLER_NAckCbs_JumpingSumoPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingPosture (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTING_POSTURE_TYPE type)
{
    // -- Send a command <code>PilotingPosture</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Posture command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingPosture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendPilotingAddCapOffset (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, float offset)
{
    // -- Send a command <code>PilotingAddCapOffset</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AddCapOffset command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoPilotingAddCapOffset(cmdBuffer, sizeof(cmdBuffer), &cmdSize, offset);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpStop (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>AnimationsJumpStop</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpStop command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpStop(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpCancel (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>AnimationsJumpCancel</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpCancel command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpCancel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJumpLoad (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>AnimationsJumpLoad</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send JumpLoad command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJumpLoad(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsJump (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_JUMP_TYPE type)
{
    // -- Send a command <code>AnimationsJump</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Jump command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsJump(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAnimationsSimpleAnimation (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONS_SIMPLEANIMATION_ID id)
{
    // -- Send a command <code>AnimationsSimpleAnimation</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SimpleAnimation command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAnimationsSimpleAnimation(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPicture (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordPicture</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideo (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEO_RECORD record, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordVideo</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Video command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordVideo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>MediaRecordPictureV2</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaRecordVideoV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORD_VIDEOV2_RECORD record)
{
    // -- Send a command <code>MediaRecordVideoV2</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoV2 command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaRecordVideoV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkSettingsWifiSelection (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>NetworkSettingsWifiSelection</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiScan (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORK_WIFISCAN_BAND band)
{
    // -- Send a command <code>NetworkWifiScan</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiScan command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendNetworkWifiAuthChannel (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>NetworkWifiAuthChannel</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoNetworkWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsMasterVolume (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t volume)
{
    // -- Send a command <code>AudioSettingsMasterVolume</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MasterVolume command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAudioSettingsMasterVolume(cmdBuffer, sizeof(cmdBuffer), &cmdSize, volume);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendAudioSettingsTheme (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGS_THEME_THEME theme)
{
    // -- Send a command <code>AudioSettingsTheme</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Theme command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoAudioSettingsTheme(cmdBuffer, sizeof(cmdBuffer), &cmdSize, theme);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanAllScriptsMetadata (ARCONTROLLER_FEATURE_JumpingSumo_t *feature)
{
    // -- Send a command <code>RoadPlanAllScriptsMetadata</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllScriptsMetadata command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanAllScriptsMetadata(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptUploaded (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid, char * md5Hash)
{
    // -- Send a command <code>RoadPlanScriptUploaded</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ScriptUploaded command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanScriptUploaded(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid, md5Hash);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanScriptDelete (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid)
{
    // -- Send a command <code>RoadPlanScriptDelete</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ScriptDelete command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanScriptDelete(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendRoadPlanPlayScript (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, char * uuid)
{
    // -- Send a command <code>RoadPlanPlayScript</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PlayScript command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoRoadPlanPlayScript(cmdBuffer, sizeof(cmdBuffer), &cmdSize, uuid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendSpeedSettingsOutdoor (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t outdoor)
{
    // -- Send a command <code>SpeedSettingsOutdoor</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Outdoor command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoSpeedSettingsOutdoor(cmdBuffer, sizeof(cmdBuffer), &cmdSize, outdoor);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendMediaStreamingVideoEnable (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t enable)
{
    // -- Send a command <code>MediaStreamingVideoEnable</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoEnable command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoMediaStreamingVideoEnable(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SendVideoSettingsAutorecord (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t enabled)
{
    // -- Send a command <code>VideoSettingsAutorecord</code> in project <code>JumpingSumo</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Autorecord command
        cmdError = ARCOMMANDS_Generator_GenerateJumpingSumoVideoSettingsAutorecord(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enabled);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStatePostureChangedCallback (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStatePostureChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStatePostureChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateAlertStateChangedCallback (eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAlertStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateAlertStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_PilotingStateSpeedChangedCallback (int8_t _speed, int16_t _realSpeed, void *customData)
{
    // -- callback used when the command <code>PilotingStateSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateSpeedChanged (feature,  _speed,  _realSpeed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpLoadChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>AnimationsStateJumpLoadChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpLoadChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpTypeChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>AnimationsStateJumpTypeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpTypeChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AnimationsStateJumpMotorProblemChangedCallback (eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>AnimationsStateJumpMotorProblemChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpMotorProblemChanged (feature,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_SettingsStateProductGPSVersionChangedCallback (const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductGPSVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementSettingsStateProductGPSVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordStateVideoStateChangedV2Callback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventPictureEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventPictureEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaRecordEventVideoEventChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventVideoEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventVideoEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSelectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkSettingsStateWifiSelectionChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiScanListChangedCallback (const char * _ssid, int16_t _rssi, eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiScanListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiScanListChanged (feature,  _ssid,  _rssi,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiScanChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiScanChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_ALLWIFISCANCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiScanChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateWifiAuthChannelListChangedCallback (eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiAuthChannelListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiAuthChannelListChanged (feature,  _band,  _channel,  _in_or_out, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiAuthChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiAuthChannelChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_NetworkStateLinkQualityChangedCallback (uint8_t _quality, void *customData)
{
    // -- callback used when the command <code>NetworkStateLinkQualityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateLinkQualityChanged (feature,  _quality, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateMasterVolumeChangedCallback (uint8_t _volume, void *customData)
{
    // -- callback used when the command <code>AudioSettingsStateMasterVolumeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateMasterVolumeChanged (feature,  _volume, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_AudioSettingsStateThemeChangedCallback (eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME _theme, void *customData)
{
    // -- callback used when the command <code>AudioSettingsStateThemeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateThemeChanged (feature,  _theme, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptMetadataListChangedCallback (const char * _uuid, uint8_t _version, const char * _product, const char * _name, uint64_t _lastModified, void *customData)
{
    // -- callback used when the command <code>RoadPlanStateScriptMetadataListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptMetadataListChanged (feature,  _uuid,  _version,  _product,  _name,  _lastModified, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateAllScriptsMetadataChangedCallback (void *customData)
{
    // -- callback used when the command <code>RoadPlanStateAllScriptsMetadataChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_ALLSCRIPTSMETADATACHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateAllScriptsMetadataChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptUploadChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>RoadPlanStateScriptUploadChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptUploadChanged (feature,  _resultCode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStateScriptDeleteChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>RoadPlanStateScriptDeleteChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptDeleteChanged (feature,  _resultCode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_RoadPlanStatePlayScriptChangedCallback (eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE _resultCode, void *customData)
{
    // -- callback used when the command <code>RoadPlanStatePlayScriptChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStatePlayScriptChanged (feature,  _resultCode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_SpeedSettingsStateOutdoorChangedCallback (uint8_t _outdoor, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateOutdoorChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementSpeedSettingsStateOutdoorChanged (feature,  _outdoor, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_MediaStreamingStateVideoEnableChangedCallback (eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, void *customData)
{
    // -- callback used when the command <code>MediaStreamingStateVideoEnableChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementMediaStreamingStateVideoEnableChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_JumpingSumo_VideoSettingsStateAutorecordChangedCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>VideoSettingsStateAutorecordChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_JumpingSumo_t *feature = (ARCONTROLLER_FEATURE_JumpingSumo_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_VIDEOSETTINGSSTATE_AUTORECORDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_JumpingSumo_NewCmdElementVideoSettingsStateAutorecordChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStatePostureChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStatePostureChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_POSTURECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateAlertStateChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAlertStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementPilotingStateSpeedChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, int8_t _speed, int16_t _realSpeed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_SPEED;
            argDictNewElement->value.I8 = _speed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_PILOTINGSTATE_SPEEDCHANGED_REALSPEED;
            argDictNewElement->value.I16 = _realSpeed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpLoadChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateJumpLoadChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPLOADCHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpTypeChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateJumpTypeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPTYPECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAnimationsStateJumpMotorProblemChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AnimationsStateJumpMotorProblemChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ANIMATIONSSTATE_JUMPMOTORPROBLEMCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementSettingsStateProductGPSVersionChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductGPSVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SETTINGSSTATE_PRODUCTGPSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStatePictureStateChangedV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordStateVideoStateChangedV2 (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventPictureEventChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventPictureEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaRecordEventVideoEventChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventVideoEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkSettingsStateWifiSelectionChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSelectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiScanListChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, const char * _ssid, int16_t _rssi, eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiScanListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiScanChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiScanChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateWifiAuthChannelListChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiAuthChannelListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateAllWifiAuthChannelChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiAuthChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementNetworkStateLinkQualityChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _quality, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateLinkQualityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY;
            argDictNewElement->value.U8 = _quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateMasterVolumeChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _volume, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AudioSettingsStateMasterVolumeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_MASTERVOLUMECHANGED_VOLUME;
            argDictNewElement->value.U8 = _volume;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementAudioSettingsStateThemeChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME _theme, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AudioSettingsStateThemeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_AUDIOSETTINGSSTATE_THEMECHANGED_THEME;
            argDictNewElement->value.I32 = _theme;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptMetadataListChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, const char * _uuid, uint8_t _version, const char * _product, const char * _name, uint64_t _lastModified, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateScriptMetadataListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_uuid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _uuid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_UUID;
            strLength = strlen (_uuid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _uuid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_VERSION;
            argDictNewElement->value.U8 = _version;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_PRODUCT;
            strLength = strlen (_product);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _product, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U64;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTMETADATALISTCHANGED_LASTMODIFIED;
            argDictNewElement->value.U64 = _lastModified;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateAllScriptsMetadataChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateAllScriptsMetadataChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptUploadChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE _resultCode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateScriptUploadChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTUPLOADCHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStateScriptDeleteChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE _resultCode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStateScriptDeleteChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_SCRIPTDELETECHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementRoadPlanStatePlayScriptChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE _resultCode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RoadPlanStatePlayScriptChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_ROADPLANSTATE_PLAYSCRIPTCHANGED_RESULTCODE;
            argDictNewElement->value.I32 = _resultCode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementSpeedSettingsStateOutdoorChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _outdoor, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateOutdoorChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_SPEEDSETTINGSSTATE_OUTDOORCHANGED_OUTDOOR;
            argDictNewElement->value.U8 = _outdoor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementMediaStreamingStateVideoEnableChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCOMMANDS_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaStreamingStateVideoEnableChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED;
            argDictNewElement->value.I32 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_NewCmdElementVideoSettingsStateAutorecordChanged (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VideoSettingsStateAutorecordChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_JUMPINGSUMO_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_JumpingSumo_SetNetworkController (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_JumpingSumo_GetCommandElements (ARCONTROLLER_FEATURE_JumpingSumo_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE mapper --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABSTATE_BUTTONS = "arcontroller_dictionary_key_mapper_grabstate_buttons";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABSTATE_AXES = "arcontroller_dictionary_key_mapper_grabstate_axes";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABSTATE_BUTTONS_STATE = "arcontroller_dictionary_key_mapper_grabstate_buttons_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABBUTTONEVENT_BUTTON = "arcontroller_dictionary_key_mapper_grabbuttonevent_button";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABBUTTONEVENT_EVENT = "arcontroller_dictionary_key_mapper_grabbuttonevent_event";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABAXISEVENT_AXIS = "arcontroller_dictionary_key_mapper_grabaxisevent_axis";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABAXISEVENT_VALUE = "arcontroller_dictionary_key_mapper_grabaxisevent_value";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_UID = "arcontroller_dictionary_key_mapper_buttonmappingitem_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_PRODUCT = "arcontroller_dictionary_key_mapper_buttonmappingitem_product";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_ACTION = "arcontroller_dictionary_key_mapper_buttonmappingitem_action";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_BUTTONS = "arcontroller_dictionary_key_mapper_buttonmappingitem_buttons";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_UID = "arcontroller_dictionary_key_mapper_axismappingitem_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_PRODUCT = "arcontroller_dictionary_key_mapper_axismappingitem_product";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_ACTION = "arcontroller_dictionary_key_mapper_axismappingitem_action";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_AXIS = "arcontroller_dictionary_key_mapper_axismappingitem_axis";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_BUTTONS = "arcontroller_dictionary_key_mapper_axismappingitem_buttons";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONAXISEVENT_ACTION = "arcontroller_dictionary_key_mapper_applicationaxisevent_action";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONAXISEVENT_VALUE = "arcontroller_dictionary_key_mapper_applicationaxisevent_value";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONBUTTONEVENT_ACTION = "arcontroller_dictionary_key_mapper_applicationbuttonevent_action";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_UID = "arcontroller_dictionary_key_mapper_expomapitem_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_PRODUCT = "arcontroller_dictionary_key_mapper_expomapitem_product";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_AXIS = "arcontroller_dictionary_key_mapper_expomapitem_axis";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_EXPO = "arcontroller_dictionary_key_mapper_expomapitem_expo";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_UID = "arcontroller_dictionary_key_mapper_invertedmapitem_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_PRODUCT = "arcontroller_dictionary_key_mapper_invertedmapitem_product";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_AXIS = "arcontroller_dictionary_key_mapper_invertedmapitem_axis";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_INVERTED = "arcontroller_dictionary_key_mapper_invertedmapitem_inverted";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_ACTIVEPRODUCT_PRODUCT = "arcontroller_dictionary_key_mapper_activeproduct_product";

ARCONTROLLER_FEATURE_Mapper_t *ARCONTROLLER_FEATURE_Mapper_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Mapper_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Mapper_t));
        if (featureController != NULL)
        {
            featureController->sendGrab = ARCONTROLLER_FEATURE_Mapper_SendGrab;
            featureController->sendMapButtonAction = ARCONTROLLER_FEATURE_Mapper_SendMapButtonAction;
            featureController->sendMapAxisAction = ARCONTROLLER_FEATURE_Mapper_SendMapAxisAction;
            featureController->sendResetMapping = ARCONTROLLER_FEATURE_Mapper_SendResetMapping;
            featureController->sendSetExpo = ARCONTROLLER_FEATURE_Mapper_SendSetExpo;
            featureController->sendSetInverted = ARCONTROLLER_FEATURE_Mapper_SendSetInverted;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Mapper_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Mapper_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Mapper_Delete (ARCONTROLLER_FEATURE_Mapper_t **feature)
{
    // -- Delete the mapper feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Mapper_GetDictionary (ARCONTROLLER_FEATURE_Mapper_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the mapper Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_AddCallback (ARCONTROLLER_FEATURE_Mapper_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Mapper</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_RemoveCallback (ARCONTROLLER_FEATURE_Mapper_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Mapper</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_RegisterARCommands (ARCONTROLLER_FEATURE_Mapper_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMapperGrabStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_GrabStateCallback, feature);
        ARCOMMANDS_Decoder_SetMapperGrabButtonEventCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_GrabButtonEventCallback, feature);
        ARCOMMANDS_Decoder_SetMapperGrabAxisEventCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_GrabAxisEventCallback, feature);
        ARCOMMANDS_Decoder_SetMapperButtonMappingItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_ButtonMappingItemCallback, feature);
        ARCOMMANDS_Decoder_SetMapperAxisMappingItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_AxisMappingItemCallback, feature);
        ARCOMMANDS_Decoder_SetMapperApplicationAxisEventCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_ApplicationAxisEventCallback, feature);
        ARCOMMANDS_Decoder_SetMapperApplicationButtonEventCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_ApplicationButtonEventCallback, feature);
        ARCOMMANDS_Decoder_SetMapperExpoMapItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_ExpoMapItemCallback, feature);
        ARCOMMANDS_Decoder_SetMapperInvertedMapItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_InvertedMapItemCallback, feature);
        ARCOMMANDS_Decoder_SetMapperActiveProductCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Mapper_ActiveProductCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_UnregisterARCommands (ARCONTROLLER_FEATURE_Mapper_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMapperGrabStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperGrabButtonEventCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperGrabAxisEventCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperButtonMappingItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperAxisMappingItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperApplicationAxisEventCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperApplicationButtonEventCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperExpoMapItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperInvertedMapItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperActiveProductCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_SendGrab (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t buttons, uint32_t axes)
{
    // -- Send a command <code>Grab</code> in project <code>Mapper</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Grab command
        cmdError = ARCOMMANDS_Generator_GenerateMapperGrab(cmdBuffer, sizeof(cmdBuffer), &cmdSize, buttons, axes);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_SendMapButtonAction (ARCONTROLLER_FEATURE_Mapper_t *feature, uint16_t product, eARCOMMANDS_MAPPER_BUTTON_ACTION action, uint32_t buttons)
{
    // -- Send a command <code>MapButtonAction</code> in project <code>Mapper</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MapButtonAction command
        cmdError = ARCOMMANDS_Generator_GenerateMapperMapButtonAction(cmdBuffer, sizeof(cmdBuffer), &cmdSize, product, action, buttons);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_SendMapAxisAction (ARCONTROLLER_FEATURE_Mapper_t *feature, uint16_t product, eARCOMMANDS_MAPPER_AXIS_ACTION action, int32_t axis, uint32_t buttons)
{
    // -- Send a command <code>MapAxisAction</code> in project <code>Mapper</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MapAxisAction command
        cmdError = ARCOMMANDS_Generator_GenerateMapperMapAxisAction(cmdBuffer, sizeof(cmdBuffer), &cmdSize, product, action, axis, buttons);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_SendResetMapping (ARCONTROLLER_FEATURE_Mapper_t *feature, uint16_t product)
{
    // -- Send a command <code>ResetMapping</code> in project <code>Mapper</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetMapping command
        cmdError = ARCOMMANDS_Generator_GenerateMapperResetMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, product);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_SendSetExpo (ARCONTROLLER_FEATURE_Mapper_t *feature, uint16_t product, int32_t axis, eARCOMMANDS_MAPPER_EXPO_TYPE expo)
{
    // -- Send a command <code>SetExpo</code> in project <code>Mapper</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetExpo command
        cmdError = ARCOMMANDS_Generator_GenerateMapperSetExpo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, product, axis, expo);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_SendSetInverted (ARCONTROLLER_FEATURE_Mapper_t *feature, uint16_t product, int32_t axis, uint8_t inverted)
{
    // -- Send a command <code>SetInverted</code> in project <code>Mapper</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetInverted command
        cmdError = ARCOMMANDS_Generator_GenerateMapperSetInverted(cmdBuffer, sizeof(cmdBuffer), &cmdSize, product, axis, inverted);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Mapper_GrabStateCallback (uint32_t _buttons, uint32_t _axes, uint32_t _buttons_state, void *customData)
{
    // -- callback used when the command <code>GrabState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Mapper_NewCmdElementGrabState (feature,  _buttons,  _axes,  _buttons_state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_GrabButtonEventCallback (uint32_t _button, eARCOMMANDS_MAPPER_BUTTON_EVENT _event, void *customData)
{
    // -- callback used when the command <code>GrabButtonEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABBUTTONEVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Mapper_NewCmdElementGrabButtonEvent (feature,  _button,  _event, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_GrabAxisEventCallback (uint32_t _axis, int8_t _value, void *customData)
{
    // -- callback used when the command <code>GrabAxisEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABAXISEVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Mapper_NewCmdElementGrabAxisEvent (feature,  _axis,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_ButtonMappingItemCallback (uint32_t _uid, uint16_t _product, eARCOMMANDS_MAPPER_BUTTON_ACTION _action, uint32_t _buttons, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>ButtonMappingItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu32, _uid);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Mapper_NewCmdElementButtonMappingItem (feature, _uid,  _product,  _action,  _buttons,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_AxisMappingItemCallback (uint32_t _uid, uint16_t _product, eARCOMMANDS_MAPPER_AXIS_ACTION _action, int32_t _axis, uint32_t _buttons, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>AxisMappingItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu32, _uid);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Mapper_NewCmdElementAxisMappingItem (feature, _uid,  _product,  _action,  _axis,  _buttons,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_ApplicationAxisEventCallback (eARCOMMANDS_MAPPER_AXIS_ACTION _action, int8_t _value, void *customData)
{
    // -- callback used when the command <code>ApplicationAxisEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONAXISEVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Mapper_NewCmdElementApplicationAxisEvent (feature,  _action,  _value, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_ApplicationButtonEventCallback (eARCOMMANDS_MAPPER_BUTTON_ACTION _action, void *customData)
{
    // -- callback used when the command <code>ApplicationButtonEvent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONBUTTONEVENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Mapper_NewCmdElementApplicationButtonEvent (feature,  _action, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_ExpoMapItemCallback (uint32_t _uid, uint16_t _product, int32_t _axis, eARCOMMANDS_MAPPER_EXPO_TYPE _expo, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>ExpoMapItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu32, _uid);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Mapper_NewCmdElementExpoMapItem (feature, _uid,  _product,  _axis,  _expo,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_InvertedMapItemCallback (uint32_t _uid, uint16_t _product, int32_t _axis, uint8_t _inverted, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>InvertedMapItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu32, _uid);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Mapper_NewCmdElementInvertedMapItem (feature, _uid,  _product,  _axis,  _inverted,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Mapper_ActiveProductCallback (uint16_t _product, void *customData)
{
    // -- callback used when the command <code>ActiveProduct</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Mapper_t *feature = (ARCONTROLLER_FEATURE_Mapper_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_ACTIVEPRODUCT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Mapper_NewCmdElementActiveProduct (feature,  _product, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementGrabState (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t _buttons, uint32_t _axes, uint32_t _buttons_state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GrabState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABSTATE_BUTTONS;
            argDictNewElement->value.U32 = _buttons;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABSTATE_AXES;
            argDictNewElement->value.U32 = _axes;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABSTATE_BUTTONS_STATE;
            argDictNewElement->value.U32 = _buttons_state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementGrabButtonEvent (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t _button, eARCOMMANDS_MAPPER_BUTTON_EVENT _event, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GrabButtonEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABBUTTONEVENT_BUTTON;
            argDictNewElement->value.U32 = _button;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABBUTTONEVENT_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementGrabAxisEvent (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t _axis, int8_t _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GrabAxisEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABAXISEVENT_AXIS;
            argDictNewElement->value.U32 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_GRABAXISEVENT_VALUE;
            argDictNewElement->value.I8 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementButtonMappingItem (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t _uid, uint16_t _product, eARCOMMANDS_MAPPER_BUTTON_ACTION _action, uint32_t _buttons, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu32, _uid);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_UID;
            argDictNewElement->value.U32 = _uid;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_PRODUCT;
            argDictNewElement->value.U16 = _product;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_BUTTONMAPPINGITEM_BUTTONS;
            argDictNewElement->value.U32 = _buttons;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementAxisMappingItem (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t _uid, uint16_t _product, eARCOMMANDS_MAPPER_AXIS_ACTION _action, int32_t _axis, uint32_t _buttons, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu32, _uid);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_UID;
            argDictNewElement->value.U32 = _uid;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_PRODUCT;
            argDictNewElement->value.U16 = _product;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_AXIS;
            argDictNewElement->value.I32 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_AXISMAPPINGITEM_BUTTONS;
            argDictNewElement->value.U32 = _buttons;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementApplicationAxisEvent (ARCONTROLLER_FEATURE_Mapper_t *feature, eARCOMMANDS_MAPPER_AXIS_ACTION _action, int8_t _value, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ApplicationAxisEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONAXISEVENT_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONAXISEVENT_VALUE;
            argDictNewElement->value.I8 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementApplicationButtonEvent (ARCONTROLLER_FEATURE_Mapper_t *feature, eARCOMMANDS_MAPPER_BUTTON_ACTION _action, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ApplicationButtonEvent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_APPLICATIONBUTTONEVENT_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementExpoMapItem (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t _uid, uint16_t _product, int32_t _axis, eARCOMMANDS_MAPPER_EXPO_TYPE _expo, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ExpoMapItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu32, _uid);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_UID;
            argDictNewElement->value.U32 = _uid;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_PRODUCT;
            argDictNewElement->value.U16 = _product;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_AXIS;
            argDictNewElement->value.I32 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_EXPOMAPITEM_EXPO;
            argDictNewElement->value.I32 = _expo;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementInvertedMapItem (ARCONTROLLER_FEATURE_Mapper_t *feature, uint32_t _uid, uint16_t _product, int32_t _axis, uint8_t _inverted, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event InvertedMapItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu32, _uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu32, _uid);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_UID;
            argDictNewElement->value.U32 = _uid;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_PRODUCT;
            argDictNewElement->value.U16 = _product;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_AXIS;
            argDictNewElement->value.I32 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_INVERTEDMAPITEM_INVERTED;
            argDictNewElement->value.U8 = _inverted;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_NewCmdElementActiveProduct (ARCONTROLLER_FEATURE_Mapper_t *feature, uint16_t _product, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ActiveProduct -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_ACTIVEPRODUCT_PRODUCT;
            argDictNewElement->value.U16 = _product;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Mapper_SetNetworkController (ARCONTROLLER_FEATURE_Mapper_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Mapper_GetCommandElements (ARCONTROLLER_FEATURE_Mapper_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE mapper_mini --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_UID = "arcontroller_dictionary_key_mapper_mini_buttonmappingitem_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_MODES = "arcontroller_dictionary_key_mapper_mini_buttonmappingitem_modes";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_ACTION = "arcontroller_dictionary_key_mapper_mini_buttonmappingitem_action";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_BUTTONS = "arcontroller_dictionary_key_mapper_mini_buttonmappingitem_buttons";

const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_UID = "arcontroller_dictionary_key_mapper_mini_axismappingitem_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_MODES = "arcontroller_dictionary_key_mapper_mini_axismappingitem_modes";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_ACTION = "arcontroller_dictionary_key_mapper_mini_axismappingitem_action";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_AXIS = "arcontroller_dictionary_key_mapper_mini_axismappingitem_axis";
const char *ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_BUTTONS = "arcontroller_dictionary_key_mapper_mini_axismappingitem_buttons";

ARCONTROLLER_FEATURE_MapperMini_t *ARCONTROLLER_FEATURE_MapperMini_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_MapperMini_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_MapperMini_t));
        if (featureController != NULL)
        {
            featureController->sendMapButtonAction = ARCONTROLLER_FEATURE_MapperMini_SendMapButtonAction;
            featureController->sendMapAxisAction = ARCONTROLLER_FEATURE_MapperMini_SendMapAxisAction;
            featureController->sendResetMapping = ARCONTROLLER_FEATURE_MapperMini_SendResetMapping;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_MapperMini_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_MapperMini_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_MapperMini_Delete (ARCONTROLLER_FEATURE_MapperMini_t **feature)
{
    // -- Delete the mapper_mini feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_MapperMini_GetDictionary (ARCONTROLLER_FEATURE_MapperMini_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the mapper_mini Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_AddCallback (ARCONTROLLER_FEATURE_MapperMini_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>MapperMini</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_RemoveCallback (ARCONTROLLER_FEATURE_MapperMini_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>MapperMini</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_RegisterARCommands (ARCONTROLLER_FEATURE_MapperMini_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMapperMiniButtonMappingItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MapperMini_ButtonMappingItemCallback, feature);
        ARCOMMANDS_Decoder_SetMapperMiniAxisMappingItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MapperMini_AxisMappingItemCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_UnregisterARCommands (ARCONTROLLER_FEATURE_MapperMini_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMapperMiniButtonMappingItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMapperMiniAxisMappingItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_SendMapButtonAction (ARCONTROLLER_FEATURE_MapperMini_t *feature, uint8_t modes, eARCOMMANDS_MAPPER_MINI_BUTTON_ACTION action, uint32_t buttons)
{
    // -- Send a command <code>MapButtonAction</code> in project <code>MapperMini</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MapButtonAction command
        cmdError = ARCOMMANDS_Generator_GenerateMapperMiniMapButtonAction(cmdBuffer, sizeof(cmdBuffer), &cmdSize, modes, action, buttons);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_SendMapAxisAction (ARCONTROLLER_FEATURE_MapperMini_t *feature, uint8_t modes, eARCOMMANDS_MAPPER_MINI_AXIS_ACTION action, int8_t axis, uint32_t buttons)
{
    // -- Send a command <code>MapAxisAction</code> in project <code>MapperMini</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MapAxisAction command
        cmdError = ARCOMMANDS_Generator_GenerateMapperMiniMapAxisAction(cmdBuffer, sizeof(cmdBuffer), &cmdSize, modes, action, axis, buttons);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_SendResetMapping (ARCONTROLLER_FEATURE_MapperMini_t *feature, uint8_t modes)
{
    // -- Send a command <code>ResetMapping</code> in project <code>MapperMini</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetMapping command
        cmdError = ARCOMMANDS_Generator_GenerateMapperMiniResetMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, modes);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_MapperMini_ButtonMappingItemCallback (uint16_t _uid, uint8_t _modes, eARCOMMANDS_MAPPER_MINI_BUTTON_ACTION _action, uint32_t _buttons, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>ButtonMappingItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MapperMini_t *feature = (ARCONTROLLER_FEATURE_MapperMini_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu16, _uid);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu16, _uid);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_MapperMini_NewCmdElementButtonMappingItem (feature, _uid,  _modes,  _action,  _buttons,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MapperMini_AxisMappingItemCallback (uint16_t _uid, uint8_t _modes, eARCOMMANDS_MAPPER_MINI_AXIS_ACTION _action, int8_t _axis, uint32_t _buttons, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>AxisMappingItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MapperMini_t *feature = (ARCONTROLLER_FEATURE_MapperMini_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu16, _uid);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu16, _uid);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_MapperMini_NewCmdElementAxisMappingItem (feature, _uid,  _modes,  _action,  _axis,  _buttons,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MapperMini_NewCmdElementButtonMappingItem (ARCONTROLLER_FEATURE_MapperMini_t *feature, uint16_t _uid, uint8_t _modes, eARCOMMANDS_MAPPER_MINI_BUTTON_ACTION _action, uint32_t _buttons, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu16, _uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu16, _uid);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_UID;
            argDictNewElement->value.U16 = _uid;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_MODES;
            argDictNewElement->value.U8 = _modes;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_BUTTONMAPPINGITEM_BUTTONS;
            argDictNewElement->value.U32 = _buttons;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MapperMini_NewCmdElementAxisMappingItem (ARCONTROLLER_FEATURE_MapperMini_t *feature, uint16_t _uid, uint8_t _modes, eARCOMMANDS_MAPPER_MINI_AXIS_ACTION _action, int8_t _axis, uint32_t _buttons, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu16, _uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu16, _uid);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_UID;
            argDictNewElement->value.U16 = _uid;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_MODES;
            argDictNewElement->value.U8 = _modes;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_AXIS;
            argDictNewElement->value.I8 = _axis;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MAPPER_MINI_AXISMAPPINGITEM_BUTTONS;
            argDictNewElement->value.U32 = _buttons;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MapperMini_SetNetworkController (ARCONTROLLER_FEATURE_MapperMini_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MapperMini_GetCommandElements (ARCONTROLLER_FEATURE_MapperMini_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE MiniDrone --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/


const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_flyingstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_alertstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_autotakeoffmodechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE = "arcontroller_dictionary_key_minidrone_pilotingstate_flyingmodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingstate_planegearboxchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_PILOTINGMODECHANGED_MODE = "arcontroller_dictionary_key_minidrone_pilotingstate_pilotingmodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechanged_mass_storage_id";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_minidrone_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_minidrone_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_minidrone_mediarecordevent_pictureeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxaltitudechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxtiltchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_STATE = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_bankedturnchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTHROTTLECHANGED_MAX = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_maxthrottlechanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_PREFERREDPILOTINGMODECHANGED_MODE = "arcontroller_dictionary_key_minidrone_pilotingsettingsstate_preferredpilotingmodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxverticalspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxrotationspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED_PRESENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_wheelschanged_present";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxhorizontalspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxhorizontalspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxhorizontalspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXPLANEMODEROTATIONSPEEDCHANGED_CURRENT = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxplanemoderotationspeedchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXPLANEMODEROTATIONSPEEDCHANGED_MIN = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxplanemoderotationspeedchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXPLANEMODEROTATIONSPEEDCHANGED_MAX = "arcontroller_dictionary_key_minidrone_speedsettingsstate_maxplanemoderotationspeedchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_MOTOR = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_motor";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_TYPE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productmotorsversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productinertialversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_minidrone_settingsstate_productinertialversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED_ENABLE = "arcontroller_dictionary_key_minidrone_settingsstate_cutoutmodechanged_enable";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED_DELAY = "arcontroller_dictionary_key_minidrone_floodcontrolstate_floodcontrolchanged_delay";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_ID = "arcontroller_dictionary_key_minidrone_usbaccessorystate_lightstate_id";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE = "arcontroller_dictionary_key_minidrone_usbaccessorystate_lightstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_INTENSITY = "arcontroller_dictionary_key_minidrone_usbaccessorystate_lightstate_intensity";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_ID = "arcontroller_dictionary_key_minidrone_usbaccessorystate_clawstate_id";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE = "arcontroller_dictionary_key_minidrone_usbaccessorystate_clawstate_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_ID = "arcontroller_dictionary_key_minidrone_usbaccessorystate_gunstate_id";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE = "arcontroller_dictionary_key_minidrone_usbaccessorystate_gunstate_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_POSX = "arcontroller_dictionary_key_minidrone_navigationdatastate_droneposition_posx";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_POSY = "arcontroller_dictionary_key_minidrone_navigationdatastate_droneposition_posy";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_POSZ = "arcontroller_dictionary_key_minidrone_navigationdatastate_droneposition_posz";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_PSI = "arcontroller_dictionary_key_minidrone_navigationdatastate_droneposition_psi";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_TS = "arcontroller_dictionary_key_minidrone_navigationdatastate_droneposition_ts";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_SPEED_X = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronespeed_speed_x";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_SPEED_Y = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronespeed_speed_y";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_SPEED_Z = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronespeed_speed_z";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_TS = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronespeed_ts";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEALTITUDE_ALTITUDE = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronealtitude_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEALTITUDE_TS = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronealtitude_ts";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_W = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronequaternion_q_w";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_X = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronequaternion_q_x";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_Y = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronequaternion_q_y";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_Z = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronequaternion_q_z";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_TS = "arcontroller_dictionary_key_minidrone_navigationdatastate_dronequaternion_ts";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_POWERMODECHANGED_POWER_MODE = "arcontroller_dictionary_key_minidrone_minicamstate_powermodechanged_power_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PRODUCTSERIALCHANGED_SERIAL_NUMBER = "arcontroller_dictionary_key_minidrone_minicamstate_productserialchanged_serial_number";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_STATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_minicamstate_statechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_minidrone_minicamstate_versionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_minidrone_minicamstate_versionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PICTURECHANGED_STATE = "arcontroller_dictionary_key_minidrone_minicamstate_picturechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PICTURECHANGED_RESULT = "arcontroller_dictionary_key_minidrone_minicamstate_picturechanged_result";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_STATE = "arcontroller_dictionary_key_minidrone_minicamstate_videostatechanged_state";
const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_ERROR = "arcontroller_dictionary_key_minidrone_minicamstate_videostatechanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_MASSSTORAGEFORMATCHANGED_STATE = "arcontroller_dictionary_key_minidrone_minicamstate_massstorageformatchanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED = "arcontroller_dictionary_key_minidrone_videosettingsstate_autorecordchanged_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY = "arcontroller_dictionary_key_minidrone_videosettingsstate_electricfrequencychanged_frequency";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_VIDEORESOLUTIONCHANGED_TYPE = "arcontroller_dictionary_key_minidrone_videosettingsstate_videoresolutionchanged_type";

const char *ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_REMOTECONTROLLERSTATE_CONNECTIONCHANGED_STATE = "arcontroller_dictionary_key_minidrone_remotecontrollerstate_connectionchanged_state";

ARCONTROLLER_FEATURE_MiniDrone_t *ARCONTROLLER_FEATURE_MiniDrone_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_MiniDrone_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDrone_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingFlatTrim = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlatTrim;
            featureController->sendPilotingTakeOff = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTakeOff;
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDRoll = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDRoll;
            featureController->setPilotingPCMDPitch = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPitch;
            featureController->setPilotingPCMDYaw = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDYaw;
            featureController->setPilotingPCMDGaz = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDGaz;
            featureController->setPilotingPCMDTimestamp = ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDTimestamp;
            featureController->sendPilotingLanding = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingLanding;
            featureController->sendPilotingEmergency = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingEmergency;
            featureController->sendPilotingAutoTakeOffMode = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingAutoTakeOffMode;
            featureController->sendPilotingFlyingMode = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlyingMode;
            featureController->sendPilotingPlaneGearBox = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPlaneGearBox;
            featureController->sendPilotingTogglePilotingMode = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTogglePilotingMode;
            featureController->sendAnimationsFlip = ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsFlip;
            featureController->sendAnimationsCap = ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsCap;
            featureController->sendMediaRecordPicture = ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPicture;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPictureV2;
            featureController->sendPilotingSettingsMaxAltitude = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxAltitude;
            featureController->sendPilotingSettingsMaxTilt = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxTilt;
            featureController->sendPilotingSettingsBankedTurn = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsBankedTurn;
            featureController->sendPilotingSettingsMaxThrottle = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxThrottle;
            featureController->sendPilotingSettingsPreferredPilotingMode = ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsPreferredPilotingMode;
            featureController->sendSpeedSettingsMaxVerticalSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxVerticalSpeed;
            featureController->sendSpeedSettingsMaxRotationSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxRotationSpeed;
            featureController->sendSpeedSettingsWheels = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsWheels;
            featureController->sendSpeedSettingsMaxHorizontalSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxHorizontalSpeed;
            featureController->sendSpeedSettingsMaxPlaneModeRotationSpeed = ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxPlaneModeRotationSpeed;
            featureController->sendSettingsCutOutMode = ARCONTROLLER_FEATURE_MiniDrone_SendSettingsCutOutMode;
            featureController->sendGPSControllerLatitudeForRun = ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLatitudeForRun;
            featureController->sendGPSControllerLongitudeForRun = ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLongitudeForRun;
            featureController->sendConfigurationControllerType = ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerType;
            featureController->sendConfigurationControllerName = ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerName;
            featureController->sendUsbAccessoryLightControl = ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryLightControl;
            featureController->sendUsbAccessoryClawControl = ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryClawControl;
            featureController->sendUsbAccessoryGunControl = ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryGunControl;
            featureController->sendRemoteControllerSetPairedRemote = ARCONTROLLER_FEATURE_MiniDrone_SendRemoteControllerSetPairedRemote;
            featureController->sendVideoSettingsAutorecord = ARCONTROLLER_FEATURE_MiniDrone_SendVideoSettingsAutorecord;
            featureController->sendVideoSettingsElectricFrequency = ARCONTROLLER_FEATURE_MiniDrone_SendVideoSettingsElectricFrequency;
            featureController->sendVideoSettingsVideoResolution = ARCONTROLLER_FEATURE_MiniDrone_SendVideoSettingsVideoResolution;
            featureController->sendMinicamPicture = ARCONTROLLER_FEATURE_MiniDrone_SendMinicamPicture;
            featureController->sendMinicamVideo = ARCONTROLLER_FEATURE_MiniDrone_SendMinicamVideo;
            featureController->sendMinicamMassStorageFormat = ARCONTROLLER_FEATURE_MiniDrone_SendMinicamMassStorageFormat;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_MiniDrone_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->PilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->PilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_MiniDrone_PilotingPCMDParameters_t));
        if (featureController->privatePart->PilotingPCMDParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDInit (featureController);
    }

    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_MiniDrone_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_MiniDrone_Delete (ARCONTROLLER_FEATURE_MiniDrone_t **feature)
{
    // -- Delete the MiniDrone feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->PilotingPCMDParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDDeInit (*feature);

                    free ((*feature)->privatePart->PilotingPCMDParameters);
                    (*feature)->privatePart->PilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_MiniDrone_GetDictionary (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the MiniDrone Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_AddCallback (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>MiniDrone</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_RemoveCallback (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>MiniDrone</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_RegisterARCommands (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlatTrimChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAutoTakeOffModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStatePlaneGearBoxChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingStatePlaneGearBoxChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStatePilotingModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingStatePilotingModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxTiltChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateBankedTurnChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateBankedTurnChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxThrottleChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxThrottleChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStatePreferredPilotingModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStatePreferredPilotingModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxVerticalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateWheelsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxHorizontalSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductMotorsVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductInertialVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_SettingsStateCutOutModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_FloodControlStateFloodControlChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateLightStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateLightStateCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateClawStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateClawStateCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateGunStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateGunStateCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDronePositionCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDronePositionCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDroneSpeedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDroneSpeedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDroneAltitudeCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDroneAltitudeCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDroneQuaternionCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDroneQuaternionCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStatePowerModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MinicamStatePowerModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateProductSerialChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MinicamStateProductSerialChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MinicamStateStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MinicamStateVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStatePictureChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MinicamStatePictureChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateVideoStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MinicamStateVideoStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateMassStorageFormatChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_MinicamStateMassStorageFormatChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneVideoSettingsStateAutorecordChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_VideoSettingsStateAutorecordChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneVideoSettingsStateElectricFrequencyChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_VideoSettingsStateElectricFrequencyChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneVideoSettingsStateVideoResolutionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_VideoSettingsStateVideoResolutionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetMiniDroneRemoteControllerStateConnectionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_MiniDrone_RemoteControllerStateConnectionChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_UnregisterARCommands (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlatTrimChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateAutoTakeOffModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStateFlyingModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStatePlaneGearBoxChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingStatePilotingModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxAltitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxTiltChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateBankedTurnChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStateMaxThrottleChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDronePilotingSettingsStatePreferredPilotingModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxVerticalSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxRotationSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateWheelsChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxHorizontalSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSpeedSettingsStateMaxPlaneModeRotationSpeedChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductMotorsVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateProductInertialVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneSettingsStateCutOutModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneFloodControlStateFloodControlChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateLightStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateClawStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneUsbAccessoryStateGunStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDronePositionCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDroneSpeedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDroneAltitudeCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneNavigationDataStateDroneQuaternionCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStatePowerModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateProductSerialChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStatePictureChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateVideoStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneMinicamStateMassStorageFormatChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneVideoSettingsStateAutorecordChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneVideoSettingsStateElectricFrequencyChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneVideoSettingsStateVideoResolutionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetMiniDroneRemoteControllerStateConnectionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlatTrim (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingFlatTrim</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlatTrim command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingFlatTrim(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTakeOff (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingTakeOff</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TakeOff command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPCMD (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t flag, int8_t roll, int8_t pitch, int8_t yaw, int8_t gaz, uint32_t timestamp)
{
    // -- Send a command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, roll, pitch, yaw, gaz, timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMD (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _flag, int8_t _roll, int8_t _pitch, int8_t _yaw, int8_t _gaz, uint32_t _timestamp)
{
    // -- Set the parameter for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
        feature->privatePart->PilotingPCMDParameters->roll = _roll;
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;
        feature->privatePart->PilotingPCMDParameters->timestamp = _timestamp;

            ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_MiniDrone_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_MiniDrone_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PilotingPCMD</code> in project <code>MiniDrone</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->PilotingPCMDParameters->flag, feature->privatePart->PilotingPCMDParameters->roll, feature->privatePart->PilotingPCMDParameters->pitch, feature->privatePart->PilotingPCMDParameters->yaw, feature->privatePart->PilotingPCMDParameters->gaz, feature->privatePart->PilotingPCMDParameters->timestamp);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;

        ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDRoll (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _roll)
{
    // -- Set the roll for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->roll = _roll;

        ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDPitch (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _pitch)
{
    // -- Set the pitch for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->pitch = _pitch;

        ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDYaw (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _yaw)
{
    // -- Set the yaw for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->yaw = _yaw;

        ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDGaz (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int8_t _gaz)
{
    // -- Set the gaz for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->gaz = _gaz;

        ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetPilotingPCMDTimestamp (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint32_t _timestamp)
{
    // -- Set the timestamp for the command <code>PilotingPCMD</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->timestamp = _timestamp;

        ARCONTROLLER_NAckCbs_MiniDronePilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingLanding (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingLanding</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Landing command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingLanding(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingEmergency (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingEmergency</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Emergency command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingEmergency(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_HIGH_PRIORITY, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingAutoTakeOffMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingAutoTakeOffMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AutoTakeOffMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingAutoTakeOffMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingFlyingMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTING_FLYINGMODE_MODE mode)
{
    // -- Send a command <code>PilotingFlyingMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send FlyingMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingFlyingMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingPlaneGearBox (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTING_PLANEGEARBOX_STATE state)
{
    // -- Send a command <code>PilotingPlaneGearBox</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PlaneGearBox command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingPlaneGearBox(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingTogglePilotingMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>PilotingTogglePilotingMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send TogglePilotingMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingTogglePilotingMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsFlip (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_ANIMATIONS_FLIP_DIRECTION direction)
{
    // -- Send a command <code>AnimationsFlip</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Flip command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneAnimationsFlip(cmdBuffer, sizeof(cmdBuffer), &cmdSize, direction);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendAnimationsCap (ARCONTROLLER_FEATURE_MiniDrone_t *feature, int16_t offset)
{
    // -- Send a command <code>AnimationsCap</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Cap command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneAnimationsCap(cmdBuffer, sizeof(cmdBuffer), &cmdSize, offset);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPicture (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t mass_storage_id)
{
    // -- Send a command <code>MediaRecordPicture</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMediaRecordPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mass_storage_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>MediaRecordPictureV2</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxAltitude (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxAltitude</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxAltitude command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsMaxAltitude(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxTilt (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>PilotingSettingsMaxTilt</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxTilt command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsMaxTilt(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsBankedTurn (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t value)
{
    // -- Send a command <code>PilotingSettingsBankedTurn</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send BankedTurn command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsBankedTurn(cmdBuffer, sizeof(cmdBuffer), &cmdSize, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsMaxThrottle (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float max)
{
    // -- Send a command <code>PilotingSettingsMaxThrottle</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxThrottle command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsMaxThrottle(cmdBuffer, sizeof(cmdBuffer), &cmdSize, max);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendPilotingSettingsPreferredPilotingMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSETTINGS_PREFERREDPILOTINGMODE_MODE mode)
{
    // -- Send a command <code>PilotingSettingsPreferredPilotingMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PreferredPilotingMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDronePilotingSettingsPreferredPilotingMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxVerticalSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxVerticalSpeed</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxVerticalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxVerticalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxRotationSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxRotationSpeed</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsWheels (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t present)
{
    // -- Send a command <code>SpeedSettingsWheels</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Wheels command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsWheels(cmdBuffer, sizeof(cmdBuffer), &cmdSize, present);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxHorizontalSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxHorizontalSpeed</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxHorizontalSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxHorizontalSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSpeedSettingsMaxPlaneModeRotationSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float current)
{
    // -- Send a command <code>SpeedSettingsMaxPlaneModeRotationSpeed</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MaxPlaneModeRotationSpeed command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSpeedSettingsMaxPlaneModeRotationSpeed(cmdBuffer, sizeof(cmdBuffer), &cmdSize, current);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendSettingsCutOutMode (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t enable)
{
    // -- Send a command <code>SettingsCutOutMode</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send CutOutMode command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneSettingsCutOutMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLatitudeForRun (ARCONTROLLER_FEATURE_MiniDrone_t *feature, double latitude)
{
    // -- Send a command <code>GPSControllerLatitudeForRun</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerLatitudeForRun command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneGPSControllerLatitudeForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, latitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendGPSControllerLongitudeForRun (ARCONTROLLER_FEATURE_MiniDrone_t *feature, double longitude)
{
    // -- Send a command <code>GPSControllerLongitudeForRun</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerLongitudeForRun command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneGPSControllerLongitudeForRun(cmdBuffer, sizeof(cmdBuffer), &cmdSize, longitude);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerType (ARCONTROLLER_FEATURE_MiniDrone_t *feature, char * type)
{
    // -- Send a command <code>ConfigurationControllerType</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerType command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneConfigurationControllerType(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendConfigurationControllerName (ARCONTROLLER_FEATURE_MiniDrone_t *feature, char * name)
{
    // -- Send a command <code>ConfigurationControllerName</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ControllerName command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneConfigurationControllerName(cmdBuffer, sizeof(cmdBuffer), &cmdSize, name);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryLightControl (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t id, eARCOMMANDS_MINIDRONE_USBACCESSORY_LIGHTCONTROL_MODE mode, uint8_t intensity)
{
    // -- Send a command <code>UsbAccessoryLightControl</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send LightControl command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryLightControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, mode, intensity);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryClawControl (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t id, eARCOMMANDS_MINIDRONE_USBACCESSORY_CLAWCONTROL_ACTION action)
{
    // -- Send a command <code>UsbAccessoryClawControl</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ClawControl command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryClawControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, action);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendUsbAccessoryGunControl (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t id, eARCOMMANDS_MINIDRONE_USBACCESSORY_GUNCONTROL_ACTION action)
{
    // -- Send a command <code>UsbAccessoryGunControl</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GunControl command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneUsbAccessoryGunControl(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id, action);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendRemoteControllerSetPairedRemote (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint16_t msb_mac, uint16_t mid_mac, uint16_t lsb_mac)
{
    // -- Send a command <code>RemoteControllerSetPairedRemote</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetPairedRemote command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneRemoteControllerSetPairedRemote(cmdBuffer, sizeof(cmdBuffer), &cmdSize, msb_mac, mid_mac, lsb_mac);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendVideoSettingsAutorecord (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t enable)
{
    // -- Send a command <code>VideoSettingsAutorecord</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Autorecord command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneVideoSettingsAutorecord(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendVideoSettingsElectricFrequency (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_VIDEOSETTINGS_ELECTRICFREQUENCY_FREQUENCY frequency)
{
    // -- Send a command <code>VideoSettingsElectricFrequency</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ElectricFrequency command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneVideoSettingsElectricFrequency(cmdBuffer, sizeof(cmdBuffer), &cmdSize, frequency);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendVideoSettingsVideoResolution (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_VIDEOSETTINGS_VIDEORESOLUTION_TYPE type)
{
    // -- Send a command <code>VideoSettingsVideoResolution</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoResolution command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneVideoSettingsVideoResolution(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMinicamPicture (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>MinicamPicture</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Picture command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMinicamPicture(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMinicamVideo (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MINICAM_VIDEO_RECORD record)
{
    // -- Send a command <code>MinicamVideo</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Video command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMinicamVideo(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SendMinicamMassStorageFormat (ARCONTROLLER_FEATURE_MiniDrone_t *feature)
{
    // -- Send a command <code>MinicamMassStorageFormat</code> in project <code>MiniDrone</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MassStorageFormat command
        cmdError = ARCOMMANDS_Generator_GenerateMiniDroneMinicamMassStorageFormat(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlatTrimChangedCallback (void *customData)
{
    // -- callback used when the command <code>PilotingStateFlatTrimChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLATTRIMCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlatTrimChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAlertStateChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAlertStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAlertStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateAutoTakeOffModeChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAutoTakeOffModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAutoTakeOffModeChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStateFlyingModeChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStatePlaneGearBoxChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStatePlaneGearBoxChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStatePlaneGearBoxChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingStatePilotingModeChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PILOTINGMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PilotingStatePilotingModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_PILOTINGMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingStatePilotingModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedCallback (uint8_t _state, uint8_t _mass_storage_id, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChanged (feature,  _state,  _mass_storage_id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventPictureEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordEventPictureEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxAltitudeChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxTiltChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxTiltChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxTiltChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateBankedTurnChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateBankedTurnChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateBankedTurnChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStateMaxThrottleChangedCallback (float _max, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateMaxThrottleChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTHROTTLECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxThrottleChanged (feature,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_PilotingSettingsStatePreferredPilotingModeChangedCallback (eARCOMMANDS_MINIDRONE_PILOTINGSETTINGSSTATE_PREFERREDPILOTINGMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStatePreferredPilotingModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_PREFERREDPILOTINGMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStatePreferredPilotingModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxVerticalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxVerticalSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxRotationSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateWheelsChangedCallback (uint8_t _present, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateWheelsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateWheelsChanged (feature,  _present, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxHorizontalSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxHorizontalSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxHorizontalSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SpeedSettingsStateMaxPlaneModeRotationSpeedChangedCallback (float _current, float _min, float _max, void *customData)
{
    // -- callback used when the command <code>SpeedSettingsStateMaxPlaneModeRotationSpeedChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXPLANEMODEROTATIONSPEEDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxPlaneModeRotationSpeedChanged (feature,  _current,  _min,  _max, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductMotorsVersionChangedCallback (uint8_t _motor, const char * _type, const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductMotorsVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductMotorsVersionChanged (feature,  _motor,  _type,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateProductInertialVersionChangedCallback (const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductInertialVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductInertialVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_SettingsStateCutOutModeChangedCallback (uint8_t _enable, void *customData)
{
    // -- callback used when the command <code>SettingsStateCutOutModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateCutOutModeChanged (feature,  _enable, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_FloodControlStateFloodControlChangedCallback (uint16_t _delay, void *customData)
{
    // -- callback used when the command <code>FloodControlStateFloodControlChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementFloodControlStateFloodControlChanged (feature,  _delay, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateLightStateCallback (uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE _state, uint8_t _intensity, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>UsbAccessoryStateLightState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateLightState (feature, _id,  _state,  _intensity,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateClawStateCallback (uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE _state, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>UsbAccessoryStateClawState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateClawState (feature, _id,  _state,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_UsbAccessoryStateGunStateCallback (uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE _state, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>UsbAccessoryStateGunState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateGunState (feature, _id,  _state,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDronePositionCallback (float _posx, float _posy, int16_t _posz, int16_t _psi, int16_t _ts, void *customData)
{
    // -- callback used when the command <code>NavigationDataStateDronePosition</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDronePosition (feature,  _posx,  _posy,  _posz,  _psi,  _ts, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDroneSpeedCallback (float _speed_x, float _speed_y, float _speed_z, uint16_t _ts, void *customData)
{
    // -- callback used when the command <code>NavigationDataStateDroneSpeed</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDroneSpeed (feature,  _speed_x,  _speed_y,  _speed_z,  _ts, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDroneAltitudeCallback (float _altitude, uint16_t _ts, void *customData)
{
    // -- callback used when the command <code>NavigationDataStateDroneAltitude</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEALTITUDE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDroneAltitude (feature,  _altitude,  _ts, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_NavigationDataStateDroneQuaternionCallback (float _q_w, float _q_x, float _q_y, float _q_z, uint16_t _ts, void *customData)
{
    // -- callback used when the command <code>NavigationDataStateDroneQuaternion</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDroneQuaternion (feature,  _q_w,  _q_x,  _q_y,  _q_z,  _ts, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MinicamStatePowerModeChangedCallback (eARCOMMANDS_MINIDRONE_MINICAMSTATE_POWERMODECHANGED_POWER_MODE _power_mode, void *customData)
{
    // -- callback used when the command <code>MinicamStatePowerModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_POWERMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMinicamStatePowerModeChanged (feature,  _power_mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MinicamStateProductSerialChangedCallback (const char * _serial_number, void *customData)
{
    // -- callback used when the command <code>MinicamStateProductSerialChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PRODUCTSERIALCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateProductSerialChanged (feature,  _serial_number, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MinicamStateStateChangedCallback (eARCOMMANDS_MINIDRONE_MINICAMSTATE_STATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>MinicamStateStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_STATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MinicamStateVersionChangedCallback (const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>MinicamStateVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MinicamStatePictureChangedCallback (eARCOMMANDS_MINIDRONE_MINICAMSTATE_PICTURECHANGED_STATE _state, eARCOMMANDS_MINIDRONE_MINICAMSTATE_PICTURECHANGED_RESULT _result, void *customData)
{
    // -- callback used when the command <code>MinicamStatePictureChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PICTURECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMinicamStatePictureChanged (feature,  _state,  _result, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MinicamStateVideoStateChangedCallback (eARCOMMANDS_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_STATE _state, eARCOMMANDS_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MinicamStateVideoStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateVideoStateChanged (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_MinicamStateMassStorageFormatChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>MinicamStateMassStorageFormatChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_MASSSTORAGEFORMATCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateMassStorageFormatChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_VideoSettingsStateAutorecordChangedCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>VideoSettingsStateAutorecordChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_AUTORECORDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementVideoSettingsStateAutorecordChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_VideoSettingsStateElectricFrequencyChangedCallback (eARCOMMANDS_MINIDRONE_VIDEOSETTINGSSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency, void *customData)
{
    // -- callback used when the command <code>VideoSettingsStateElectricFrequencyChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_ELECTRICFREQUENCYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementVideoSettingsStateElectricFrequencyChanged (feature,  _frequency, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_VideoSettingsStateVideoResolutionChangedCallback (eARCOMMANDS_MINIDRONE_VIDEOSETTINGSSTATE_VIDEORESOLUTIONCHANGED_TYPE _type, void *customData)
{
    // -- callback used when the command <code>VideoSettingsStateVideoResolutionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_VIDEORESOLUTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementVideoSettingsStateVideoResolutionChanged (feature,  _type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_MiniDrone_RemoteControllerStateConnectionChangedCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>RemoteControllerStateConnectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_MiniDrone_t *feature = (ARCONTROLLER_FEATURE_MiniDrone_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_REMOTECONTROLLERSTATE_CONNECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_MiniDrone_NewCmdElementRemoteControllerStateConnectionChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlatTrimChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlatTrimChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAlertStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAlertStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateAutoTakeOffModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAutoTakeOffModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_AUTOTAKEOFFMODECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStateFlyingModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_FLYINGMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStatePlaneGearBoxChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStatePlaneGearBoxChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_PLANEGEARBOXCHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingStatePilotingModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSTATE_PILOTINGMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStatePilotingModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSTATE_PILOTINGMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _state, uint8_t _mass_storage_id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGED_MASS_STORAGE_ID;
            argDictNewElement->value.U8 = _mass_storage_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordStatePictureStateChangedV2 (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMediaRecordEventPictureEventChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventPictureEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxAltitudeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXALTITUDECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxTiltChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxTiltChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTILTCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateBankedTurnChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateBankedTurnChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_BANKEDTURNCHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStateMaxThrottleChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateMaxThrottleChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_MAXTHROTTLECHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementPilotingSettingsStatePreferredPilotingModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_PILOTINGSETTINGSSTATE_PREFERREDPILOTINGMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStatePreferredPilotingModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_PILOTINGSETTINGSSTATE_PREFERREDPILOTINGMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxVerticalSpeedChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxVerticalSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXVERTICALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxRotationSpeedChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxRotationSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateWheelsChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _present, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateWheelsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_WHEELSCHANGED_PRESENT;
            argDictNewElement->value.U8 = _present;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxHorizontalSpeedChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxHorizontalSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXHORIZONTALSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSpeedSettingsStateMaxPlaneModeRotationSpeedChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _current, float _min, float _max, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SpeedSettingsStateMaxPlaneModeRotationSpeedChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXPLANEMODEROTATIONSPEEDCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXPLANEMODEROTATIONSPEEDCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SPEEDSETTINGSSTATE_MAXPLANEMODEROTATIONSPEEDCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductMotorsVersionChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _motor, const char * _type, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductMotorsVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_MOTOR;
            argDictNewElement->value.U8 = _motor;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_TYPE;
            strLength = strlen (_type);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _type, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTMOTORSVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateProductInertialVersionChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductInertialVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_PRODUCTINERTIALVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementSettingsStateCutOutModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _enable, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateCutOutModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_SETTINGSSTATE_CUTOUTMODECHANGED_ENABLE;
            argDictNewElement->value.U8 = _enable;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementFloodControlStateFloodControlChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint16_t _delay, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event FloodControlStateFloodControlChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_FLOODCONTROLSTATE_FLOODCONTROLCHANGED_DELAY;
            argDictNewElement->value.U16 = _delay;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateLightState (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE _state, uint8_t _intensity, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event UsbAccessoryStateLightState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_LIGHTSTATE_INTENSITY;
            argDictNewElement->value.U8 = _intensity;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateClawState (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE _state, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event UsbAccessoryStateClawState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_CLAWSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementUsbAccessoryStateGunState (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _id, eARCOMMANDS_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE _state, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event UsbAccessoryStateGunState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_USBACCESSORYSTATE_GUNSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDronePosition (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _posx, float _posy, int16_t _posz, int16_t _psi, int16_t _ts, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NavigationDataStateDronePosition -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_POSX;
            argDictNewElement->value.Float = _posx;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_POSY;
            argDictNewElement->value.Float = _posy;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_POSZ;
            argDictNewElement->value.I16 = _posz;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_PSI;
            argDictNewElement->value.I16 = _psi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEPOSITION_TS;
            argDictNewElement->value.I16 = _ts;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDroneSpeed (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _speed_x, float _speed_y, float _speed_z, uint16_t _ts, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NavigationDataStateDroneSpeed -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_SPEED_X;
            argDictNewElement->value.Float = _speed_x;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_SPEED_Y;
            argDictNewElement->value.Float = _speed_y;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_SPEED_Z;
            argDictNewElement->value.Float = _speed_z;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONESPEED_TS;
            argDictNewElement->value.U16 = _ts;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDroneAltitude (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _altitude, uint16_t _ts, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NavigationDataStateDroneAltitude -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEALTITUDE_ALTITUDE;
            argDictNewElement->value.Float = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEALTITUDE_TS;
            argDictNewElement->value.U16 = _ts;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementNavigationDataStateDroneQuaternion (ARCONTROLLER_FEATURE_MiniDrone_t *feature, float _q_w, float _q_x, float _q_y, float _q_z, uint16_t _ts, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NavigationDataStateDroneQuaternion -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_W;
            argDictNewElement->value.Float = _q_w;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_X;
            argDictNewElement->value.Float = _q_x;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_Y;
            argDictNewElement->value.Float = _q_y;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_Q_Z;
            argDictNewElement->value.Float = _q_z;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_NAVIGATIONDATASTATE_DRONEQUATERNION_TS;
            argDictNewElement->value.U16 = _ts;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMinicamStatePowerModeChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MINICAMSTATE_POWERMODECHANGED_POWER_MODE _power_mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MinicamStatePowerModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_POWERMODECHANGED_POWER_MODE;
            argDictNewElement->value.I32 = _power_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateProductSerialChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, const char * _serial_number, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MinicamStateProductSerialChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PRODUCTSERIALCHANGED_SERIAL_NUMBER;
            strLength = strlen (_serial_number);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serial_number, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MINICAMSTATE_STATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MinicamStateStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_STATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateVersionChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MinicamStateVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMinicamStatePictureChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MINICAMSTATE_PICTURECHANGED_STATE _state, eARCOMMANDS_MINIDRONE_MINICAMSTATE_PICTURECHANGED_RESULT _result, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MinicamStatePictureChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PICTURECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_PICTURECHANGED_RESULT;
            argDictNewElement->value.I32 = _result;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateVideoStateChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_STATE _state, eARCOMMANDS_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MinicamStateVideoStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_VIDEOSTATECHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementMinicamStateMassStorageFormatChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MinicamStateMassStorageFormatChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_MINICAMSTATE_MASSSTORAGEFORMATCHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementVideoSettingsStateAutorecordChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VideoSettingsStateAutorecordChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementVideoSettingsStateElectricFrequencyChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_VIDEOSETTINGSSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY _frequency, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VideoSettingsStateElectricFrequencyChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_ELECTRICFREQUENCYCHANGED_FREQUENCY;
            argDictNewElement->value.I32 = _frequency;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementVideoSettingsStateVideoResolutionChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCOMMANDS_MINIDRONE_VIDEOSETTINGSSTATE_VIDEORESOLUTIONCHANGED_TYPE _type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VideoSettingsStateVideoResolutionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_VIDEOSETTINGSSTATE_VIDEORESOLUTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_NewCmdElementRemoteControllerStateConnectionChanged (ARCONTROLLER_FEATURE_MiniDrone_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RemoteControllerStateConnectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_MINIDRONE_REMOTECONTROLLERSTATE_CONNECTIONCHANGED_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_MiniDrone_SetNetworkController (ARCONTROLLER_FEATURE_MiniDrone_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_MiniDrone_GetCommandElements (ARCONTROLLER_FEATURE_MiniDrone_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE powerup --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE = "arcontroller_dictionary_key_powerup_pilotingstate_alertstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE = "arcontroller_dictionary_key_powerup_pilotingstate_flyingstatechanged_state";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE = "arcontroller_dictionary_key_powerup_pilotingstate_motormodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ATTITUDECHANGED_ROLL = "arcontroller_dictionary_key_powerup_pilotingstate_attitudechanged_roll";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ATTITUDECHANGED_PITCH = "arcontroller_dictionary_key_powerup_pilotingstate_attitudechanged_pitch";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ATTITUDECHANGED_YAW = "arcontroller_dictionary_key_powerup_pilotingstate_attitudechanged_yaw";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE = "arcontroller_dictionary_key_powerup_pilotingstate_altitudechanged_altitude";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING = "arcontroller_dictionary_key_powerup_pilotingsettingsstate_settingchanged_setting";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_CURRENT = "arcontroller_dictionary_key_powerup_pilotingsettingsstate_settingchanged_current";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_MIN = "arcontroller_dictionary_key_powerup_pilotingsettingsstate_settingchanged_min";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_MAX = "arcontroller_dictionary_key_powerup_pilotingsettingsstate_settingchanged_max";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE = "arcontroller_dictionary_key_powerup_mediarecordstate_picturestatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_powerup_mediarecordstate_picturestatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE = "arcontroller_dictionary_key_powerup_mediarecordstate_videostatechangedv2_state";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR = "arcontroller_dictionary_key_powerup_mediarecordstate_videostatechangedv2_error";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT = "arcontroller_dictionary_key_powerup_mediarecordevent_pictureeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR = "arcontroller_dictionary_key_powerup_mediarecordevent_pictureeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT = "arcontroller_dictionary_key_powerup_mediarecordevent_videoeventchanged_event";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR = "arcontroller_dictionary_key_powerup_mediarecordevent_videoeventchanged_error";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_powerup_networksettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_powerup_networksettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_powerup_networksettingsstate_wifiselectionchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_SSID = "arcontroller_dictionary_key_powerup_networkstate_wifiscanlistchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI = "arcontroller_dictionary_key_powerup_networkstate_wifiscanlistchanged_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND = "arcontroller_dictionary_key_powerup_networkstate_wifiscanlistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_powerup_networkstate_wifiscanlistchanged_channel";


const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_powerup_networkstate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_powerup_networkstate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_powerup_networkstate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY = "arcontroller_dictionary_key_powerup_networkstate_linkqualitychanged_quality";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED = "arcontroller_dictionary_key_powerup_mediastreamingstate_videoenablechanged_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED = "arcontroller_dictionary_key_powerup_videosettingsstate_autorecordchanged_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE = "arcontroller_dictionary_key_powerup_videosettingsstate_videomodechanged_mode";

const char *ARCONTROLLER_DICTIONARY_KEY_POWERUP_SOUNDSSTATE_BUZZCHANGED_ENABLED = "arcontroller_dictionary_key_powerup_soundsstate_buzzchanged_enabled";

ARCONTROLLER_FEATURE_Powerup_t *ARCONTROLLER_FEATURE_Powerup_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Powerup_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Powerup_t));
        if (featureController != NULL)
        {
            featureController->sendPilotingPCMD = ARCONTROLLER_FEATURE_Powerup_SendPilotingPCMD;
            featureController->setPilotingPCMD = ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMD;
            featureController->setPilotingPCMDFlag = ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMDFlag;
            featureController->setPilotingPCMDThrottle = ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMDThrottle;
            featureController->setPilotingPCMDRoll = ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMDRoll;
            featureController->sendPilotingUserTakeOff = ARCONTROLLER_FEATURE_Powerup_SendPilotingUserTakeOff;
            featureController->sendPilotingMotorMode = ARCONTROLLER_FEATURE_Powerup_SendPilotingMotorMode;
            featureController->sendPilotingSettingsSet = ARCONTROLLER_FEATURE_Powerup_SendPilotingSettingsSet;
            featureController->sendMediaRecordPictureV2 = ARCONTROLLER_FEATURE_Powerup_SendMediaRecordPictureV2;
            featureController->sendMediaRecordVideoV2 = ARCONTROLLER_FEATURE_Powerup_SendMediaRecordVideoV2;
            featureController->sendNetworkSettingsWifiSelection = ARCONTROLLER_FEATURE_Powerup_SendNetworkSettingsWifiSelection;
            featureController->sendNetworkWifiScan = ARCONTROLLER_FEATURE_Powerup_SendNetworkWifiScan;
            featureController->sendNetworkWifiAuthChannel = ARCONTROLLER_FEATURE_Powerup_SendNetworkWifiAuthChannel;
            featureController->sendMediaStreamingVideoEnable = ARCONTROLLER_FEATURE_Powerup_SendMediaStreamingVideoEnable;
            featureController->sendVideoSettingsAutorecord = ARCONTROLLER_FEATURE_Powerup_SendVideoSettingsAutorecord;
            featureController->sendVideoSettingsVideoMode = ARCONTROLLER_FEATURE_Powerup_SendVideoSettingsVideoMode;
            featureController->sendSoundsBuzz = ARCONTROLLER_FEATURE_Powerup_SendSoundsBuzz;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Powerup_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            featureController->privatePart->PilotingPCMDParameters = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        featureController->privatePart->PilotingPCMDParameters = calloc (1, sizeof (ARCONTROLLER_Powerup_PilotingPCMDParameters_t));
        if (featureController->privatePart->PilotingPCMDParameters == NULL)
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 

    if (localError == ARCONTROLLER_OK)
    {
        localError = ARCONTROLLER_NAckCbs_PowerupPilotingPCMDInit (featureController);
    }

    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Powerup_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Powerup_Delete (ARCONTROLLER_FEATURE_Powerup_t **feature)
{
    // -- Delete the powerup feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                if ((*feature)->privatePart->PilotingPCMDParameters != NULL)
                {
                    ARCONTROLLER_NAckCbs_PowerupPilotingPCMDDeInit (*feature);

                    free ((*feature)->privatePart->PilotingPCMDParameters);
                    (*feature)->privatePart->PilotingPCMDParameters = NULL;
                }
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Powerup_GetDictionary (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the powerup Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_AddCallback (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Powerup</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_RemoveCallback (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Powerup</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_RegisterARCommands (ARCONTROLLER_FEATURE_Powerup_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetPowerupPilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_PilotingStateAlertStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateFlyingStateChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_PilotingStateFlyingStateChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateMotorModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_PilotingStateMotorModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateAttitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_PilotingStateAttitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateAltitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_PilotingStateAltitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupPilotingSettingsStateSettingChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_PilotingSettingsStateSettingChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_MediaRecordStatePictureStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordStateVideoStateChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_MediaRecordStateVideoStateChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_MediaRecordEventPictureEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordEventVideoEventChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_MediaRecordEventVideoEventChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupNetworkSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_NetworkSettingsStateWifiSelectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiScanListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_NetworkStateWifiScanListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiScanChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_NetworkStateAllWifiScanChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_NetworkStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_NetworkStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateLinkQualityChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_NetworkStateLinkQualityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupMediaStreamingStateVideoEnableChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_MediaStreamingStateVideoEnableChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateAutorecordChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_VideoSettingsStateAutorecordChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateVideoModeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_VideoSettingsStateVideoModeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetPowerupSoundsStateBuzzChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Powerup_SoundsStateBuzzChangedCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_UnregisterARCommands (ARCONTROLLER_FEATURE_Powerup_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetPowerupPilotingStateAlertStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateFlyingStateChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateMotorModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateAttitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupPilotingStateAltitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupPilotingSettingsStateSettingChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordStatePictureStateChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordStateVideoStateChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordEventPictureEventChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupMediaRecordEventVideoEventChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupNetworkSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiScanListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiScanChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupNetworkStateLinkQualityChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupMediaStreamingStateVideoEnableChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateAutorecordChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupVideoSettingsStateVideoModeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetPowerupSoundsStateBuzzChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendPilotingPCMD (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t flag, uint8_t throttle, int8_t roll)
{
    // -- Send a command <code>PilotingPCMD</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupPilotingPCMD(cmdBuffer, sizeof(cmdBuffer), &cmdSize, flag, throttle, roll);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMD (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t _flag, uint8_t _throttle, int8_t _roll)
{
    // -- Set the parameter for the command <code>PilotingPCMD</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;
        feature->privatePart->PilotingPCMDParameters->throttle = _throttle;
        feature->privatePart->PilotingPCMDParameters->roll = _roll;

            ARCONTROLLER_NAckCbs_PowerupPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_Powerup_SendPilotingPCMDStruct (ARCONTROLLER_FEATURE_Powerup_t *feature, u_int8_t *cmdBuffer, int32_t cmdBufferSize)
{
    // -- Send the a command <code>PilotingPCMD</code> in project <code>Powerup</code> with the parame set beforehand  --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    int32_t cmdSize = 0;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL) ||
       (cmdBuffer == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PCMD command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupPilotingPCMD(cmdBuffer, cmdBufferSize, &cmdSize, feature->privatePart->PilotingPCMDParameters->flag, feature->privatePart->PilotingPCMDParameters->throttle, feature->privatePart->PilotingPCMDParameters->roll);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_NOT_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
        if (netError != ARNETWORK_OK)
        {
            ARSAL_PRINT(ARSAL_PRINT_ERROR, ARCONTROLLER_FEATURE_TAG, "Network sending error : %s", ARNETWORK_Error_ToString (netError));
        }
        
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMDFlag (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t _flag)
{
    // -- Set the flag for the command <code>PilotingPCMD</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->flag = _flag;

        ARCONTROLLER_NAckCbs_PowerupPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMDThrottle (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t _throttle)
{
    // -- Set the throttle for the command <code>PilotingPCMD</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->throttle = _throttle;

        ARCONTROLLER_NAckCbs_PowerupPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SetPilotingPCMDRoll (ARCONTROLLER_FEATURE_Powerup_t *feature, int8_t _roll)
{
    // -- Set the roll for the command <code>PilotingPCMD</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) ||
       (feature->privatePart == NULL) ||
       (feature->privatePart->PilotingPCMDParameters == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->PilotingPCMDParameters->roll = _roll;

        ARCONTROLLER_NAckCbs_PowerupPilotingPCMDChanged (feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendPilotingUserTakeOff (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t state)
{
    // -- Send a command <code>PilotingUserTakeOff</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UserTakeOff command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupPilotingUserTakeOff(cmdBuffer, sizeof(cmdBuffer), &cmdSize, state);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendPilotingMotorMode (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_PILOTING_MOTORMODE_MODE mode)
{
    // -- Send a command <code>PilotingMotorMode</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MotorMode command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupPilotingMotorMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendPilotingSettingsSet (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_PILOTINGSETTINGS_SET_SETTING setting, float value)
{
    // -- Send a command <code>PilotingSettingsSet</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Set command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupPilotingSettingsSet(cmdBuffer, sizeof(cmdBuffer), &cmdSize, setting, value);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendMediaRecordPictureV2 (ARCONTROLLER_FEATURE_Powerup_t *feature)
{
    // -- Send a command <code>MediaRecordPictureV2</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send PictureV2 command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupMediaRecordPictureV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendMediaRecordVideoV2 (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_MEDIARECORD_VIDEOV2_RECORD record)
{
    // -- Send a command <code>MediaRecordVideoV2</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoV2 command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupMediaRecordVideoV2(cmdBuffer, sizeof(cmdBuffer), &cmdSize, record);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendNetworkSettingsWifiSelection (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_POWERUP_NETWORKSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>NetworkSettingsWifiSelection</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupNetworkSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendNetworkWifiScan (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_NETWORK_WIFISCAN_BAND band)
{
    // -- Send a command <code>NetworkWifiScan</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiScan command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupNetworkWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendNetworkWifiAuthChannel (ARCONTROLLER_FEATURE_Powerup_t *feature)
{
    // -- Send a command <code>NetworkWifiAuthChannel</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupNetworkWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendMediaStreamingVideoEnable (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t enable)
{
    // -- Send a command <code>MediaStreamingVideoEnable</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoEnable command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupMediaStreamingVideoEnable(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendVideoSettingsAutorecord (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t enable)
{
    // -- Send a command <code>VideoSettingsAutorecord</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Autorecord command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupVideoSettingsAutorecord(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendVideoSettingsVideoMode (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_VIDEOSETTINGS_VIDEOMODE_MODE mode)
{
    // -- Send a command <code>VideoSettingsVideoMode</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send VideoMode command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupVideoSettingsVideoMode(cmdBuffer, sizeof(cmdBuffer), &cmdSize, mode);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SendSoundsBuzz (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t enable)
{
    // -- Send a command <code>SoundsBuzz</code> in project <code>Powerup</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Buzz command
        cmdError = ARCOMMANDS_Generator_GeneratePowerupSoundsBuzz(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Powerup_PilotingStateAlertStateChangedCallback (eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateAlertStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementPilotingStateAlertStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_PilotingStateFlyingStateChangedCallback (eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, void *customData)
{
    // -- callback used when the command <code>PilotingStateFlyingStateChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementPilotingStateFlyingStateChanged (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_PilotingStateMotorModeChangedCallback (eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>PilotingStateMotorModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_MOTORMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementPilotingStateMotorModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_PilotingStateAttitudeChangedCallback (float _roll, float _pitch, float _yaw, void *customData)
{
    // -- callback used when the command <code>PilotingStateAttitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ATTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementPilotingStateAttitudeChanged (feature,  _roll,  _pitch,  _yaw, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_PilotingStateAltitudeChangedCallback (float _altitude, void *customData)
{
    // -- callback used when the command <code>PilotingStateAltitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ALTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementPilotingStateAltitudeChanged (feature,  _altitude, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_PilotingSettingsStateSettingChangedCallback (eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING _setting, float _current, float _min, float _max, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>PilotingSettingsStateSettingChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%d", _setting);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%d", _setting);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Powerup_NewCmdElementPilotingSettingsStateSettingChanged (feature, _setting,  _current,  _min,  _max,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_MediaRecordStatePictureStateChangedV2Callback (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStatePictureStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementMediaRecordStatePictureStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_MediaRecordStateVideoStateChangedV2Callback (eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordStateVideoStateChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementMediaRecordStateVideoStateChangedV2 (feature,  _state,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_MediaRecordEventPictureEventChangedCallback (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventPictureEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementMediaRecordEventPictureEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_MediaRecordEventVideoEventChangedCallback (eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, void *customData)
{
    // -- callback used when the command <code>MediaRecordEventVideoEventChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementMediaRecordEventVideoEventChanged (feature,  _event,  _error, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_NetworkSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkSettingsStateWifiSelectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementNetworkSettingsStateWifiSelectionChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_NetworkStateWifiScanListChangedCallback (const char * _ssid, int16_t _rssi, eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiScanListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementNetworkStateWifiScanListChanged (feature,  _ssid,  _rssi,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_NetworkStateAllWifiScanChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiScanChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_ALLWIFISCANCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementNetworkStateAllWifiScanChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_NetworkStateWifiAuthChannelListChangedCallback (eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>NetworkStateWifiAuthChannelListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementNetworkStateWifiAuthChannelListChanged (feature,  _band,  _channel,  _in_or_out, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_NetworkStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>NetworkStateAllWifiAuthChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_ALLWIFIAUTHCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementNetworkStateAllWifiAuthChannelChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_NetworkStateLinkQualityChangedCallback (uint8_t _quality, void *customData)
{
    // -- callback used when the command <code>NetworkStateLinkQualityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_LINKQUALITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementNetworkStateLinkQualityChanged (feature,  _quality, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_MediaStreamingStateVideoEnableChangedCallback (eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, void *customData)
{
    // -- callback used when the command <code>MediaStreamingStateVideoEnableChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementMediaStreamingStateVideoEnableChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_VideoSettingsStateAutorecordChangedCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>VideoSettingsStateAutorecordChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_VIDEOSETTINGSSTATE_AUTORECORDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementVideoSettingsStateAutorecordChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_VideoSettingsStateVideoModeChangedCallback (eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE _mode, void *customData)
{
    // -- callback used when the command <code>VideoSettingsStateVideoModeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementVideoSettingsStateVideoModeChanged (feature,  _mode, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Powerup_SoundsStateBuzzChangedCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>SoundsStateBuzzChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Powerup_t *feature = (ARCONTROLLER_FEATURE_Powerup_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_POWERUP_SOUNDSSTATE_BUZZCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Powerup_NewCmdElementSoundsStateBuzzChanged (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementPilotingStateAlertStateChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAlertStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ALERTSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementPilotingStateFlyingStateChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateFlyingStateChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_FLYINGSTATECHANGED_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementPilotingStateMotorModeChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateMotorModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_MOTORMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementPilotingStateAttitudeChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, float _roll, float _pitch, float _yaw, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAttitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ATTITUDECHANGED_ROLL;
            argDictNewElement->value.Float = _roll;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ATTITUDECHANGED_PITCH;
            argDictNewElement->value.Float = _pitch;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ATTITUDECHANGED_YAW;
            argDictNewElement->value.Float = _yaw;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementPilotingStateAltitudeChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, float _altitude, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingStateAltitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSTATE_ALTITUDECHANGED_ALTITUDE;
            argDictNewElement->value.Float = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementPilotingSettingsStateSettingChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING _setting, float _current, float _min, float _max, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event PilotingSettingsStateSettingChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _setting);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _setting);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_SETTING;
            argDictNewElement->value.I32 = _setting;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_CURRENT;
            argDictNewElement->value.Float = _current;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_MIN;
            argDictNewElement->value.Float = _min;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_PILOTINGSETTINGSSTATE_SETTINGCHANGED_MAX;
            argDictNewElement->value.Float = _max;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementMediaRecordStatePictureStateChangedV2 (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE _state, eARCOMMANDS_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStatePictureStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_PICTURESTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementMediaRecordStateVideoStateChangedV2 (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE _state, eARCOMMANDS_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordStateVideoStateChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDSTATE_VIDEOSTATECHANGEDV2_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementMediaRecordEventPictureEventChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT _event, eARCOMMANDS_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventPictureEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_PICTUREEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementMediaRecordEventVideoEventChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT _event, eARCOMMANDS_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR _error, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaRecordEventVideoEventChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_EVENT;
            argDictNewElement->value.I32 = _event;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIARECORDEVENT_VIDEOEVENTCHANGED_ERROR;
            argDictNewElement->value.I32 = _error;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementNetworkSettingsStateWifiSelectionChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkSettingsStateWifiSelectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementNetworkStateWifiScanListChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, const char * _ssid, int16_t _rssi, eARCOMMANDS_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiScanListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFISCANLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementNetworkStateAllWifiScanChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiScanChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementNetworkStateWifiAuthChannelListChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateWifiAuthChannelListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementNetworkStateAllWifiAuthChannelChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateAllWifiAuthChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementNetworkStateLinkQualityChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t _quality, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event NetworkStateLinkQualityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_NETWORKSTATE_LINKQUALITYCHANGED_QUALITY;
            argDictNewElement->value.U8 = _quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementMediaStreamingStateVideoEnableChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event MediaStreamingStateVideoEnableChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_MEDIASTREAMINGSTATE_VIDEOENABLECHANGED_ENABLED;
            argDictNewElement->value.I32 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementVideoSettingsStateAutorecordChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VideoSettingsStateAutorecordChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_VIDEOSETTINGSSTATE_AUTORECORDCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementVideoSettingsStateVideoModeChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCOMMANDS_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE _mode, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event VideoSettingsStateVideoModeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_VIDEOSETTINGSSTATE_VIDEOMODECHANGED_MODE;
            argDictNewElement->value.I32 = _mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_NewCmdElementSoundsStateBuzzChanged (ARCONTROLLER_FEATURE_Powerup_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SoundsStateBuzzChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_POWERUP_SOUNDSSTATE_BUZZCHANGED_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Powerup_SetNetworkController (ARCONTROLLER_FEATURE_Powerup_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Powerup_GetCommandElements (ARCONTROLLER_FEATURE_Powerup_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE rc --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_RC_RECEIVERSTATE_STATE = "arcontroller_dictionary_key_rc_receiverstate_state";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_RECEIVERSTATE_PROTOCOL = "arcontroller_dictionary_key_rc_receiverstate_protocol";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_RECEIVERSTATE_ENABLED = "arcontroller_dictionary_key_rc_receiverstate_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELSMONITORSTATE_STATE = "arcontroller_dictionary_key_rc_channelsmonitorstate_state";

const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELVALUE_ID = "arcontroller_dictionary_key_rc_channelvalue_id";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELVALUE_ACTION = "arcontroller_dictionary_key_rc_channelvalue_action";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELVALUE_VALUE = "arcontroller_dictionary_key_rc_channelvalue_value";

const char *ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_CALIBRATION_TYPE = "arcontroller_dictionary_key_rc_calibrationstate_calibration_type";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_CHANNEL_ACTION = "arcontroller_dictionary_key_rc_calibrationstate_channel_action";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_REQUIRED = "arcontroller_dictionary_key_rc_calibrationstate_required";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_CALIBRATED = "arcontroller_dictionary_key_rc_calibrationstate_calibrated";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_NEUTRAL_CALIBRATED = "arcontroller_dictionary_key_rc_calibrationstate_neutral_calibrated";

const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_ACTION = "arcontroller_dictionary_key_rc_channelactionitem_action";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_SUPPORTED_TYPE = "arcontroller_dictionary_key_rc_channelactionitem_supported_type";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_CALIBRATED_TYPE = "arcontroller_dictionary_key_rc_channelactionitem_calibrated_type";
const char *ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_INVERTED = "arcontroller_dictionary_key_rc_channelactionitem_inverted";

ARCONTROLLER_FEATURE_Rc_t *ARCONTROLLER_FEATURE_Rc_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Rc_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Rc_t));
        if (featureController != NULL)
        {
            featureController->sendMonitorChannels = ARCONTROLLER_FEATURE_Rc_SendMonitorChannels;
            featureController->sendStartCalibration = ARCONTROLLER_FEATURE_Rc_SendStartCalibration;
            featureController->sendInvertChannel = ARCONTROLLER_FEATURE_Rc_SendInvertChannel;
            featureController->sendAbortCalibration = ARCONTROLLER_FEATURE_Rc_SendAbortCalibration;
            featureController->sendResetCalibration = ARCONTROLLER_FEATURE_Rc_SendResetCalibration;
            featureController->sendEnableReceiver = ARCONTROLLER_FEATURE_Rc_SendEnableReceiver;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Rc_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Rc_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Rc_Delete (ARCONTROLLER_FEATURE_Rc_t **feature)
{
    // -- Delete the rc feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Rc_GetDictionary (ARCONTROLLER_FEATURE_Rc_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the rc Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_AddCallback (ARCONTROLLER_FEATURE_Rc_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Rc</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_RemoveCallback (ARCONTROLLER_FEATURE_Rc_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Rc</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_RegisterARCommands (ARCONTROLLER_FEATURE_Rc_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetRcReceiverStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Rc_ReceiverStateCallback, feature);
        ARCOMMANDS_Decoder_SetRcChannelsMonitorStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Rc_ChannelsMonitorStateCallback, feature);
        ARCOMMANDS_Decoder_SetRcChannelValueCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Rc_ChannelValueCallback, feature);
        ARCOMMANDS_Decoder_SetRcCalibrationStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Rc_CalibrationStateCallback, feature);
        ARCOMMANDS_Decoder_SetRcChannelActionItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Rc_ChannelActionItemCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_UnregisterARCommands (ARCONTROLLER_FEATURE_Rc_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetRcReceiverStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetRcChannelsMonitorStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetRcChannelValueCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetRcCalibrationStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetRcChannelActionItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_SendMonitorChannels (ARCONTROLLER_FEATURE_Rc_t *feature, uint8_t enable)
{
    // -- Send a command <code>MonitorChannels</code> in project <code>Rc</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send MonitorChannels command
        cmdError = ARCOMMANDS_Generator_GenerateRcMonitorChannels(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_SendStartCalibration (ARCONTROLLER_FEATURE_Rc_t *feature, eARCOMMANDS_RC_CALIBRATION_TYPE calibration_type, eARCOMMANDS_RC_CHANNEL_ACTION channel_action, eARCOMMANDS_RC_CHANNEL_TYPE channel_type)
{
    // -- Send a command <code>StartCalibration</code> in project <code>Rc</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateRcStartCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize, calibration_type, channel_action, channel_type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_SendInvertChannel (ARCONTROLLER_FEATURE_Rc_t *feature, eARCOMMANDS_RC_CHANNEL_ACTION action, uint8_t flag)
{
    // -- Send a command <code>InvertChannel</code> in project <code>Rc</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send InvertChannel command
        cmdError = ARCOMMANDS_Generator_GenerateRcInvertChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize, action, flag);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_SendAbortCalibration (ARCONTROLLER_FEATURE_Rc_t *feature)
{
    // -- Send a command <code>AbortCalibration</code> in project <code>Rc</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AbortCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateRcAbortCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_SendResetCalibration (ARCONTROLLER_FEATURE_Rc_t *feature)
{
    // -- Send a command <code>ResetCalibration</code> in project <code>Rc</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateRcResetCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_SendEnableReceiver (ARCONTROLLER_FEATURE_Rc_t *feature, uint8_t enable)
{
    // -- Send a command <code>EnableReceiver</code> in project <code>Rc</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send EnableReceiver command
        cmdError = ARCOMMANDS_Generator_GenerateRcEnableReceiver(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Rc_ReceiverStateCallback (eARCOMMANDS_RC_RECEIVER_STATE _state, const char * _protocol, uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>ReceiverState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Rc_t *feature = (ARCONTROLLER_FEATURE_Rc_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_RC_RECEIVERSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Rc_NewCmdElementReceiverState (feature,  _state,  _protocol,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Rc_ChannelsMonitorStateCallback (uint8_t _state, void *customData)
{
    // -- callback used when the command <code>ChannelsMonitorState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Rc_t *feature = (ARCONTROLLER_FEATURE_Rc_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELSMONITORSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Rc_NewCmdElementChannelsMonitorState (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Rc_ChannelValueCallback (uint8_t _id, eARCOMMANDS_RC_CHANNEL_ACTION _action, int16_t _value, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>ChannelValue</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Rc_t *feature = (ARCONTROLLER_FEATURE_Rc_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELVALUE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Rc_NewCmdElementChannelValue (feature, _id,  _action,  _value,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Rc_CalibrationStateCallback (eARCOMMANDS_RC_CALIBRATION_TYPE _calibration_type, eARCOMMANDS_RC_CHANNEL_ACTION _channel_action, uint32_t _required, uint32_t _calibrated, uint8_t _neutral_calibrated, void *customData)
{
    // -- callback used when the command <code>CalibrationState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Rc_t *feature = (ARCONTROLLER_FEATURE_Rc_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Rc_NewCmdElementCalibrationState (feature,  _calibration_type,  _channel_action,  _required,  _calibrated,  _neutral_calibrated, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Rc_ChannelActionItemCallback (eARCOMMANDS_RC_CHANNEL_ACTION _action, uint32_t _supported_type, eARCOMMANDS_RC_CHANNEL_TYPE _calibrated_type, uint8_t _inverted, void *customData)
{
    // -- callback used when the command <code>ChannelActionItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Rc_t *feature = (ARCONTROLLER_FEATURE_Rc_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Rc_NewCmdElementChannelActionItem (feature,  _action,  _supported_type,  _calibrated_type,  _inverted, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Rc_NewCmdElementReceiverState (ARCONTROLLER_FEATURE_Rc_t *feature, eARCOMMANDS_RC_RECEIVER_STATE _state, const char * _protocol, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ReceiverState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_RECEIVERSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_RECEIVERSTATE_PROTOCOL;
            strLength = strlen (_protocol);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _protocol, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_RECEIVERSTATE_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Rc_NewCmdElementChannelsMonitorState (ARCONTROLLER_FEATURE_Rc_t *feature, uint8_t _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChannelsMonitorState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELSMONITORSTATE_STATE;
            argDictNewElement->value.U8 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Rc_NewCmdElementChannelValue (ARCONTROLLER_FEATURE_Rc_t *feature, uint8_t _id, eARCOMMANDS_RC_CHANNEL_ACTION _action, int16_t _value, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChannelValue -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELVALUE_ID;
            argDictNewElement->value.U8 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELVALUE_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELVALUE_VALUE;
            argDictNewElement->value.I16 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Rc_NewCmdElementCalibrationState (ARCONTROLLER_FEATURE_Rc_t *feature, eARCOMMANDS_RC_CALIBRATION_TYPE _calibration_type, eARCOMMANDS_RC_CHANNEL_ACTION _channel_action, uint32_t _required, uint32_t _calibrated, uint8_t _neutral_calibrated, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_CALIBRATION_TYPE;
            argDictNewElement->value.I32 = _calibration_type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_CHANNEL_ACTION;
            argDictNewElement->value.I32 = _channel_action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_REQUIRED;
            argDictNewElement->value.U32 = _required;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_CALIBRATED;
            argDictNewElement->value.U32 = _calibrated;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CALIBRATIONSTATE_NEUTRAL_CALIBRATED;
            argDictNewElement->value.U8 = _neutral_calibrated;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Rc_NewCmdElementChannelActionItem (ARCONTROLLER_FEATURE_Rc_t *feature, eARCOMMANDS_RC_CHANNEL_ACTION _action, uint32_t _supported_type, eARCOMMANDS_RC_CHANNEL_TYPE _calibrated_type, uint8_t _inverted, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ChannelActionItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", _action);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", _action);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_ACTION;
            argDictNewElement->value.I32 = _action;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_SUPPORTED_TYPE;
            argDictNewElement->value.U32 = _supported_type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_CALIBRATED_TYPE;
            argDictNewElement->value.I32 = _calibrated_type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_RC_CHANNELACTIONITEM_INVERTED;
            argDictNewElement->value.U8 = _inverted;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Rc_SetNetworkController (ARCONTROLLER_FEATURE_Rc_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Rc_GetCommandElements (ARCONTROLLER_FEATURE_Rc_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE sequoia_cam --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBSTATUS_CAM_ID = "arcontroller_dictionary_key_sequoia_cam_radiometriccalibstatus_cam_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBSTATUS_VALUE = "arcontroller_dictionary_key_sequoia_cam_radiometriccalibstatus_value";

const char *ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBRESULT_CAM_ID = "arcontroller_dictionary_key_sequoia_cam_radiometriccalibresult_cam_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBRESULT_VALUE = "arcontroller_dictionary_key_sequoia_cam_radiometriccalibresult_value";

ARCONTROLLER_FEATURE_SequoiaCam_t *ARCONTROLLER_FEATURE_SequoiaCam_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_SequoiaCam_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_SequoiaCam_t));
        if (featureController != NULL)
        {
            featureController->sendRadiometricCalibStart = ARCONTROLLER_FEATURE_SequoiaCam_SendRadiometricCalibStart;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_SequoiaCam_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_SequoiaCam_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_SequoiaCam_Delete (ARCONTROLLER_FEATURE_SequoiaCam_t **feature)
{
    // -- Delete the sequoia_cam feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_SequoiaCam_GetDictionary (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the sequoia_cam Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SequoiaCam_AddCallback (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>SequoiaCam</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SequoiaCam_RemoveCallback (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>SequoiaCam</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SequoiaCam_RegisterARCommands (ARCONTROLLER_FEATURE_SequoiaCam_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetSequoiaCamRadiometricCalibStatusCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SequoiaCam_RadiometricCalibStatusCallback, feature);
        ARCOMMANDS_Decoder_SetSequoiaCamRadiometricCalibResultCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SequoiaCam_RadiometricCalibResultCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SequoiaCam_UnregisterARCommands (ARCONTROLLER_FEATURE_SequoiaCam_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetSequoiaCamRadiometricCalibStatusCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSequoiaCamRadiometricCalibResultCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SequoiaCam_SendRadiometricCalibStart (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, uint8_t id)
{
    // -- Send a command <code>RadiometricCalibStart</code> in project <code>SequoiaCam</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RadiometricCalibStart command
        cmdError = ARCOMMANDS_Generator_GenerateSequoiaCamRadiometricCalibStart(cmdBuffer, sizeof(cmdBuffer), &cmdSize, id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_SequoiaCam_RadiometricCalibStatusCallback (uint8_t _cam_id, eARCOMMANDS_SEQUOIA_CAM_RADIOMETRIC_CALIB_STATUS_VALUE _value, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>RadiometricCalibStatus</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SequoiaCam_t *feature = (ARCONTROLLER_FEATURE_SequoiaCam_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBSTATUS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _cam_id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_SequoiaCam_NewCmdElementRadiometricCalibStatus (feature, _cam_id,  _value,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SequoiaCam_RadiometricCalibResultCallback (uint8_t _cam_id, eARCOMMANDS_SEQUOIA_CAM_RADIOMETRIC_CALIB_RESULT_VALUE _value, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>RadiometricCalibResult</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SequoiaCam_t *feature = (ARCONTROLLER_FEATURE_SequoiaCam_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBRESULT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _cam_id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_SequoiaCam_NewCmdElementRadiometricCalibResult (feature, _cam_id,  _value,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SequoiaCam_NewCmdElementRadiometricCalibStatus (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, uint8_t _cam_id, eARCOMMANDS_SEQUOIA_CAM_RADIOMETRIC_CALIB_STATUS_VALUE _value, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RadiometricCalibStatus -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _cam_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBSTATUS_CAM_ID;
            argDictNewElement->value.U8 = _cam_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBSTATUS_VALUE;
            argDictNewElement->value.I32 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SequoiaCam_NewCmdElementRadiometricCalibResult (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, uint8_t _cam_id, eARCOMMANDS_SEQUOIA_CAM_RADIOMETRIC_CALIB_RESULT_VALUE _value, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RadiometricCalibResult -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _cam_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBRESULT_CAM_ID;
            argDictNewElement->value.U8 = _cam_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SEQUOIA_CAM_RADIOMETRICCALIBRESULT_VALUE;
            argDictNewElement->value.I32 = _value;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SequoiaCam_SetNetworkController (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SequoiaCam_GetCommandElements (ARCONTROLLER_FEATURE_SequoiaCam_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE SkyController --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_BSSID = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_bssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SSID = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SECURED = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_secured";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SAVED = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_saved";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_RSSI = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_FREQUENCY = "arcontroller_dictionary_key_skycontroller_wifistate_wifilist_frequency";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_SSID = "arcontroller_dictionary_key_skycontroller_wifistate_connexionchanged_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS = "arcontroller_dictionary_key_skycontroller_wifistate_connexionchanged_status";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchanged_in_or_out";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED_LEVEL = "arcontroller_dictionary_key_skycontroller_wifistate_wifisignalchanged_level";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_BAND = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchangedv2_band";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_CHANNEL = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchangedv2_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_IN_OR_OUT = "arcontroller_dictionary_key_skycontroller_wifistate_wifiauthchannellistchangedv2_in_or_out";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFICOUNTRYCHANGED_CODE = "arcontroller_dictionary_key_skycontroller_wifistate_wificountrychanged_code";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIENVIRONMENTCHANGED_ENVIRONMENT = "arcontroller_dictionary_key_skycontroller_wifistate_wifienvironmentchanged_environment";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST_NAME = "arcontroller_dictionary_key_skycontroller_devicestate_devicelist_name";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_status";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICENAME = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_devicename";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICEPRODUCTID = "arcontroller_dictionary_key_skycontroller_devicestate_connexionchanged_deviceproductid";



const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED_SERIALNUMBER = "arcontroller_dictionary_key_skycontroller_settingsstate_productserialchanged_serialnumber";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT = "arcontroller_dictionary_key_skycontroller_settingsstate_productvariantchanged_variant";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE = "arcontroller_dictionary_key_skycontroller_settingsstate_productversionchanged_software";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE = "arcontroller_dictionary_key_skycontroller_settingsstate_productversionchanged_hardware";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_CPUID_ID = "arcontroller_dictionary_key_skycontroller_settingsstate_cpuid_id";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED_PERCENT = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_batterychanged_percent";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED_FIXED = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpsfixchanged_fixed";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LATITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_latitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LONGITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_longitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_ALTITUDE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_altitude";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_HEADING = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_gpspositionchanged_heading";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_batterystate_state";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q0 = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_attitudechanged_q0";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q1 = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_attitudechanged_q1";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q2 = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_attitudechanged_q2";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q3 = "arcontroller_dictionary_key_skycontroller_skycontrollerstate_attitudechanged_q3";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED_SSID = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_accesspointssidchanged_ssid";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_accesspointchannelchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifiselectionchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISECURITYCHANGED_SECURITY_TYPE = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifisecuritychanged_security_type";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISECURITYCHANGED_KEY = "arcontroller_dictionary_key_skycontroller_accesspointsettingsstate_wifisecuritychanged_key";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_type";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_ID = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_NAME = "arcontroller_dictionary_key_skycontroller_gamepadinfosstate_gamepadcontrol_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_KEY_ID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_currentbuttonmappings_key_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_currentbuttonmappings_mapping_uid";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_availablebuttonmappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_NAME = "arcontroller_dictionary_key_skycontroller_buttonmappingsstate_availablebuttonmappings_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_AXIS_ID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_currentaxismappings_axis_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_currentaxismappings_mapping_uid";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_MAPPING_UID = "arcontroller_dictionary_key_skycontroller_axismappingsstate_availableaxismappings_mapping_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_NAME = "arcontroller_dictionary_key_skycontroller_axismappingsstate_availableaxismappings_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_AXIS_ID = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_currentaxisfilters_axis_id";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_FILTER_UID_OR_BUILDER = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_currentaxisfilters_filter_uid_or_builder";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_FILTER_UID = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_presetaxisfilters_filter_uid";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_NAME = "arcontroller_dictionary_key_skycontroller_axisfiltersstate_presetaxisfilters_name";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE = "arcontroller_dictionary_key_skycontroller_copilotingstate_pilotingsource_source";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_status";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_X_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_x_quality";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Y_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_y_quality";
const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Z_QUALITY = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstate_z_quality";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE_ENABLED = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationqualityupdatesstate_enabled";

const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATEV2_STATE = "arcontroller_dictionary_key_skycontroller_calibrationstate_magnetocalibrationstatev2_state";


const char *ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COMMONEVENTSTATE_SHUTDOWN_REASON = "arcontroller_dictionary_key_skycontroller_commoneventstate_shutdown_reason";

ARCONTROLLER_FEATURE_SkyController_t *ARCONTROLLER_FEATURE_SkyController_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_SkyController_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_SkyController_t));
        if (featureController != NULL)
        {
            featureController->sendWifiRequestWifiList = ARCONTROLLER_FEATURE_SkyController_SendWifiRequestWifiList;
            featureController->sendWifiRequestCurrentWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiRequestCurrentWifi;
            featureController->sendWifiConnectToWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiConnectToWifi;
            featureController->sendWifiForgetWifi = ARCONTROLLER_FEATURE_SkyController_SendWifiForgetWifi;
            featureController->sendWifiWifiAuthChannel = ARCONTROLLER_FEATURE_SkyController_SendWifiWifiAuthChannel;
            featureController->sendDeviceRequestDeviceList = ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestDeviceList;
            featureController->sendDeviceRequestCurrentDevice = ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestCurrentDevice;
            featureController->sendDeviceConnectToDevice = ARCONTROLLER_FEATURE_SkyController_SendDeviceConnectToDevice;
            featureController->sendSettingsAllSettings = ARCONTROLLER_FEATURE_SkyController_SendSettingsAllSettings;
            featureController->sendSettingsReset = ARCONTROLLER_FEATURE_SkyController_SendSettingsReset;
            featureController->sendCommonAllStates = ARCONTROLLER_FEATURE_SkyController_SendCommonAllStates;
            featureController->sendAccessPointSettingsAccessPointSSID = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointSSID;
            featureController->sendAccessPointSettingsAccessPointChannel = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointChannel;
            featureController->sendAccessPointSettingsWifiSelection = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSelection;
            featureController->sendAccessPointSettingsWifiSecurity = ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSecurity;
            featureController->sendCameraResetOrientation = ARCONTROLLER_FEATURE_SkyController_SendCameraResetOrientation;
            featureController->sendGamepadInfosGetGamepadControls = ARCONTROLLER_FEATURE_SkyController_SendGamepadInfosGetGamepadControls;
            featureController->sendButtonMappingsGetCurrentButtonMappings = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetCurrentButtonMappings;
            featureController->sendButtonMappingsGetAvailableButtonMappings = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetAvailableButtonMappings;
            featureController->sendButtonMappingsSetButtonMapping = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsSetButtonMapping;
            featureController->sendButtonMappingsDefaultButtonMapping = ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsDefaultButtonMapping;
            featureController->sendAxisMappingsGetCurrentAxisMappings = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetCurrentAxisMappings;
            featureController->sendAxisMappingsGetAvailableAxisMappings = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetAvailableAxisMappings;
            featureController->sendAxisMappingsSetAxisMapping = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsSetAxisMapping;
            featureController->sendAxisMappingsDefaultAxisMapping = ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsDefaultAxisMapping;
            featureController->sendAxisFiltersGetCurrentAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetCurrentAxisFilters;
            featureController->sendAxisFiltersGetPresetAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetPresetAxisFilters;
            featureController->sendAxisFiltersSetAxisFilter = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersSetAxisFilter;
            featureController->sendAxisFiltersDefaultAxisFilters = ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersDefaultAxisFilters;
            featureController->sendCoPilotingSetPilotingSource = ARCONTROLLER_FEATURE_SkyController_SendCoPilotingSetPilotingSource;
            featureController->sendCalibrationEnableMagnetoCalibrationQualityUpdates = ARCONTROLLER_FEATURE_SkyController_SendCalibrationEnableMagnetoCalibrationQualityUpdates;
            featureController->sendCalibrationStartCalibration = ARCONTROLLER_FEATURE_SkyController_SendCalibrationStartCalibration;
            featureController->sendCalibrationAbortCalibration = ARCONTROLLER_FEATURE_SkyController_SendCalibrationAbortCalibration;
            featureController->sendFactoryReset = ARCONTROLLER_FEATURE_SkyController_SendFactoryReset;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_SkyController_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_SkyController_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_SkyController_Delete (ARCONTROLLER_FEATURE_SkyController_t **feature)
{
    // -- Delete the SkyController feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_SkyController_GetDictionary (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the SkyController Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_AddCallback (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>SkyController</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_RemoveCallback (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>SkyController</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_RegisterARCommands (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateWifiListCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateConnexionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateAllWifiAuthChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateWifiSignalChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedV2Callback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiCountryChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateWifiCountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiEnvironmentChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_WifiStateWifiEnvironmentChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_DeviceStateDeviceListCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_DeviceStateConnexionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SettingsStateAllSettingsChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SettingsStateResetChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SettingsStateProductSerialChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVariantChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SettingsStateProductVariantChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVersionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SettingsStateProductVersionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateCPUIDCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SettingsStateCPUIDCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_CommonStateAllStatesChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsFixChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsPositionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryStateCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateAttitudeChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_SkyControllerStateAttitudeChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointSSIDChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSelectionChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSecurityChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSecurityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateGamepadControlCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateAllGamepadControlsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateCurrentButtonMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllCurrentButtonMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAvailableButtonMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllAvailableButtonsMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateCurrentAxisMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllCurrentAxisMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAvailableAxisMappingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllAvailableAxisMappingsSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateCurrentAxisFiltersCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllCurrentFiltersSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisFiltersStatePresetAxisFiltersCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllPresetFiltersSentCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_CoPilotingStatePilotingSourceCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationQualityUpdatesStateCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateV2Cb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateV2Callback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerButtonEventsSettingsCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_ButtonEventsSettingsCallback, feature);
        ARCOMMANDS_Decoder_SetSkyControllerCommonEventStateShutdownCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_SkyController_CommonEventStateShutdownCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_UnregisterARCommands (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiListCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateConnexionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateAllWifiAuthChannelChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiSignalChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiAuthChannelListChangedV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiCountryChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerWifiStateWifiEnvironmentChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateDeviceListCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerDeviceStateConnexionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateAllSettingsChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateResetChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductSerialChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVariantChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateProductVersionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSettingsStateCPUIDCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCommonStateAllStatesChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsFixChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateGpsPositionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateBatteryStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerSkyControllerStateAttitudeChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointSSIDChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateAccessPointChannelChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSelectionChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAccessPointSettingsStateWifiSecurityChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateGamepadControlCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerGamepadInfosStateAllGamepadControlsSentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateCurrentButtonMappingsCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllCurrentButtonMappingsSentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAvailableButtonMappingsCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonMappingsStateAllAvailableButtonsMappingsSentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateCurrentAxisMappingsCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllCurrentAxisMappingsSentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAvailableAxisMappingsCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisMappingsStateAllAvailableAxisMappingsSentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateCurrentAxisFiltersCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllCurrentFiltersSentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStatePresetAxisFiltersCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerAxisFiltersStateAllPresetFiltersSentCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCoPilotingStatePilotingSourceCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationQualityUpdatesStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCalibrationStateMagnetoCalibrationStateV2Cb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerButtonEventsSettingsCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetSkyControllerCommonEventStateShutdownCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiRequestWifiList (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>WifiRequestWifiList</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestWifiList command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiRequestWifiList(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiRequestCurrentWifi (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>WifiRequestCurrentWifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestCurrentWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiRequestCurrentWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiConnectToWifi (ARCONTROLLER_FEATURE_SkyController_t *feature, char * bssid, char * ssid, char * passphrase)
{
    // -- Send a command <code>WifiConnectToWifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConnectToWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiConnectToWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize, bssid, ssid, passphrase);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiForgetWifi (ARCONTROLLER_FEATURE_SkyController_t *feature, char * ssid)
{
    // -- Send a command <code>WifiForgetWifi</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ForgetWifi command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiForgetWifi(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ssid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendWifiWifiAuthChannel (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>WifiWifiAuthChannel</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiAuthChannel command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerWifiWifiAuthChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestDeviceList (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>DeviceRequestDeviceList</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestDeviceList command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceRequestDeviceList(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceRequestCurrentDevice (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>DeviceRequestCurrentDevice</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send RequestCurrentDevice command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceRequestCurrentDevice(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendDeviceConnectToDevice (ARCONTROLLER_FEATURE_SkyController_t *feature, char * deviceName)
{
    // -- Send a command <code>DeviceConnectToDevice</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ConnectToDevice command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerDeviceConnectToDevice(cmdBuffer, sizeof(cmdBuffer), &cmdSize, deviceName);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendSettingsAllSettings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>SettingsAllSettings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllSettings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerSettingsAllSettings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendSettingsReset (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>SettingsReset</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerSettingsReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCommonAllStates (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>CommonAllStates</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AllStates command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCommonAllStates(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_RETRY, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointSSID (ARCONTROLLER_FEATURE_SkyController_t *feature, char * ssid)
{
    // -- Send a command <code>AccessPointSettingsAccessPointSSID</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AccessPointSSID command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsAccessPointSSID(cmdBuffer, sizeof(cmdBuffer), &cmdSize, ssid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsAccessPointChannel (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t channel)
{
    // -- Send a command <code>AccessPointSettingsAccessPointChannel</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AccessPointChannel command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsAccessPointChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSelection (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_TYPE type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISELECTION_BAND band, uint8_t channel)
{
    // -- Send a command <code>AccessPointSettingsWifiSelection</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSelection command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsWifiSelection(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAccessPointSettingsWifiSecurity (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGS_WIFISECURITY_SECURITY_TYPE security_type, char * key)
{
    // -- Send a command <code>AccessPointSettingsWifiSecurity</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send WifiSecurity command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAccessPointSettingsWifiSecurity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, security_type, key);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCameraResetOrientation (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>CameraResetOrientation</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send ResetOrientation command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCameraResetOrientation(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendGamepadInfosGetGamepadControls (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>GamepadInfosGetGamepadControls</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetGamepadControls command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerGamepadInfosGetGamepadControls(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetCurrentButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>ButtonMappingsGetCurrentButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentButtonMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsGetCurrentButtonMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsGetAvailableButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>ButtonMappingsGetAvailableButtonMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAvailableButtonMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsGetAvailableButtonMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsSetButtonMapping (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t key_id, char * mapping_uid)
{
    // -- Send a command <code>ButtonMappingsSetButtonMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetButtonMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsSetButtonMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, key_id, mapping_uid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendButtonMappingsDefaultButtonMapping (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>ButtonMappingsDefaultButtonMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultButtonMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerButtonMappingsDefaultButtonMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetCurrentAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisMappingsGetCurrentAxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentAxisMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsGetCurrentAxisMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsGetAvailableAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisMappingsGetAvailableAxisMappings</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetAvailableAxisMappings command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsGetAvailableAxisMappings(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsSetAxisMapping (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t axis_id, char * mapping_uid)
{
    // -- Send a command <code>AxisMappingsSetAxisMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAxisMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsSetAxisMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize, axis_id, mapping_uid);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisMappingsDefaultAxisMapping (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisMappingsDefaultAxisMapping</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultAxisMapping command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisMappingsDefaultAxisMapping(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetCurrentAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisFiltersGetCurrentAxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetCurrentAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersGetCurrentAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersGetPresetAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisFiltersGetPresetAxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send GetPresetAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersGetPresetAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersSetAxisFilter (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t axis_id, char * filter_uid_or_builder)
{
    // -- Send a command <code>AxisFiltersSetAxisFilter</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetAxisFilter command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersSetAxisFilter(cmdBuffer, sizeof(cmdBuffer), &cmdSize, axis_id, filter_uid_or_builder);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendAxisFiltersDefaultAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>AxisFiltersDefaultAxisFilters</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send DefaultAxisFilters command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerAxisFiltersDefaultAxisFilters(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCoPilotingSetPilotingSource (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_COPILOTING_SETPILOTINGSOURCE_SOURCE source)
{
    // -- Send a command <code>CoPilotingSetPilotingSource</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetPilotingSource command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCoPilotingSetPilotingSource(cmdBuffer, sizeof(cmdBuffer), &cmdSize, source);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCalibrationEnableMagnetoCalibrationQualityUpdates (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t enable)
{
    // -- Send a command <code>CalibrationEnableMagnetoCalibrationQualityUpdates</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send EnableMagnetoCalibrationQualityUpdates command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCalibrationEnableMagnetoCalibrationQualityUpdates(cmdBuffer, sizeof(cmdBuffer), &cmdSize, enable);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCalibrationStartCalibration (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>CalibrationStartCalibration</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send StartCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCalibrationStartCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendCalibrationAbortCalibration (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>CalibrationAbortCalibration</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send AbortCalibration command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerCalibrationAbortCalibration(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SendFactoryReset (ARCONTROLLER_FEATURE_SkyController_t *feature)
{
    // -- Send a command <code>FactoryReset</code> in project <code>SkyController</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Reset command
        cmdError = ARCOMMANDS_Generator_GenerateSkyControllerFactoryReset(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiListCallback (const char * _bssid, const char * _ssid, uint8_t _secured, uint8_t _saved, int32_t _rssi, int32_t _frequency, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiList</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiList (feature,  _bssid,  _ssid,  _secured,  _saved,  _rssi,  _frequency, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateConnexionChangedCallback (const char * _ssid, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS _status, void *customData)
{
    // -- callback used when the command <code>WifiStateConnexionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateConnexionChanged (feature,  _ssid,  _status, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedCallback (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiAuthChannelListChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiAuthChannelListChanged (feature,  _band,  _channel,  _in_or_out, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateAllWifiAuthChannelChangedCallback (void *customData)
{
    // -- callback used when the command <code>WifiStateAllWifiAuthChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_ALLWIFIAUTHCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateAllWifiAuthChannelChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiSignalChangedCallback (uint8_t _level, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiSignalChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiSignalChanged (feature,  _level, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiAuthChannelListChangedV2Callback (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_BAND _band, uint8_t _channel, uint8_t _in_or_out, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiAuthChannelListChangedV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                listIndex = HASH_COUNT (dictCmdElement->elements);
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
            
            //Create new element
            newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiAuthChannelListChangedV2 (feature, _band,  _channel,  _in_or_out,  _list_flags, listIndex, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiCountryChangedCallback (const char * _code, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiCountryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFICOUNTRYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiCountryChanged (feature,  _code, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_WifiStateWifiEnvironmentChangedCallback (eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIENVIRONMENTCHANGED_ENVIRONMENT _environment, void *customData)
{
    // -- callback used when the command <code>WifiStateWifiEnvironmentChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIENVIRONMENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiEnvironmentChanged (feature,  _environment, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_DeviceStateDeviceListCallback (const char * _name, void *customData)
{
    // -- callback used when the command <code>DeviceStateDeviceList</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementDeviceStateDeviceList (feature,  _name, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_DeviceStateConnexionChangedCallback (eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS _status, const char * _deviceName, uint16_t _deviceProductID, void *customData)
{
    // -- callback used when the command <code>DeviceStateConnexionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementDeviceStateConnexionChanged (feature,  _status,  _deviceName,  _deviceProductID, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateAllSettingsChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateAllSettingsChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_ALLSETTINGSCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateAllSettingsChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateResetChangedCallback (void *customData)
{
    // -- callback used when the command <code>SettingsStateResetChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_RESETCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateResetChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateProductSerialChangedCallback (const char * _serialNumber, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductSerialChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductSerialChanged (feature,  _serialNumber, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateProductVariantChangedCallback (eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT _variant, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductVariantChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductVariantChanged (feature,  _variant, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateProductVersionChangedCallback (const char * _software, const char * _hardware, void *customData)
{
    // -- callback used when the command <code>SettingsStateProductVersionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVERSIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductVersionChanged (feature,  _software,  _hardware, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SettingsStateCPUIDCallback (const char * _id, void *customData)
{
    // -- callback used when the command <code>SettingsStateCPUID</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_CPUID;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSettingsStateCPUID (feature,  _id, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CommonStateAllStatesChangedCallback (void *customData)
{
    // -- callback used when the command <code>CommonStateAllStatesChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COMMONSTATE_ALLSTATESCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCommonStateAllStatesChanged (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryChangedCallback (uint8_t _percent, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateBatteryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateBatteryChanged (feature,  _percent, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsFixChangedCallback (uint8_t _fixed, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateGpsFixChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsFixChanged (feature,  _fixed, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateGpsPositionChangedCallback (double _latitude, double _longitude, double _altitude, float _heading, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateGpsPositionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsPositionChanged (feature,  _latitude,  _longitude,  _altitude,  _heading, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateBatteryStateCallback (eARCOMMANDS_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE _state, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateBatteryState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateBatteryState (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_SkyControllerStateAttitudeChangedCallback (float _q0, float _q1, float _q2, float _q3, void *customData)
{
    // -- callback used when the command <code>SkyControllerStateAttitudeChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateAttitudeChanged (feature,  _q0,  _q1,  _q2,  _q3, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointSSIDChangedCallback (const char * _ssid, void *customData)
{
    // -- callback used when the command <code>AccessPointSettingsStateAccessPointSSIDChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointSSIDChanged (feature,  _ssid, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateAccessPointChannelChangedCallback (uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>AccessPointSettingsStateAccessPointChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointChannelChanged (feature,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSelectionChangedCallback (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>AccessPointSettingsStateWifiSelectionChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateWifiSelectionChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AccessPointSettingsStateWifiSecurityChangedCallback (eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISECURITYCHANGED_SECURITY_TYPE _security_type, const char * _key, void *customData)
{
    // -- callback used when the command <code>AccessPointSettingsStateWifiSecurityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISECURITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateWifiSecurityChanged (feature,  _security_type,  _key, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateGamepadControlCallback (eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE _type, int32_t _id, const char * _name, void *customData)
{
    // -- callback used when the command <code>GamepadInfosStateGamepadControl</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        listIndex = HASH_COUNT (dictCmdElement->elements);
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateGamepadControl (feature,  _type,  _id,  _name, listIndex, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_GamepadInfosStateAllGamepadControlsSentCallback (void *customData)
{
    // -- callback used when the command <code>GamepadInfosStateAllGamepadControlsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_ALLGAMEPADCONTROLSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateAllGamepadControlsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateCurrentButtonMappingsCallback (int32_t _key_id, const char * _mapping_uid, void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateCurrentButtonMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateCurrentButtonMappings (feature,  _key_id,  _mapping_uid, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllCurrentButtonMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateAllCurrentButtonMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_ALLCURRENTBUTTONMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllCurrentButtonMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAvailableButtonMappingsCallback (const char * _mapping_uid, const char * _name, void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateAvailableButtonMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAvailableButtonMappings (feature,  _mapping_uid,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonMappingsStateAllAvailableButtonsMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>ButtonMappingsStateAllAvailableButtonsMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_ALLAVAILABLEBUTTONSMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllAvailableButtonsMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateCurrentAxisMappingsCallback (int32_t _axis_id, const char * _mapping_uid, void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateCurrentAxisMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateCurrentAxisMappings (feature,  _axis_id,  _mapping_uid, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllCurrentAxisMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateAllCurrentAxisMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_ALLCURRENTAXISMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllCurrentAxisMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAvailableAxisMappingsCallback (const char * _mapping_uid, const char * _name, void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateAvailableAxisMappings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAvailableAxisMappings (feature,  _mapping_uid,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisMappingsStateAllAvailableAxisMappingsSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisMappingsStateAllAvailableAxisMappingsSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_ALLAVAILABLEAXISMAPPINGSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllAvailableAxisMappingsSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateCurrentAxisFiltersCallback (int32_t _axis_id, const char * _filter_uid_or_builder, void *customData)
{
    // -- callback used when the command <code>AxisFiltersStateCurrentAxisFilters</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateCurrentAxisFilters (feature,  _axis_id,  _filter_uid_or_builder, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllCurrentFiltersSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisFiltersStateAllCurrentFiltersSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_ALLCURRENTFILTERSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllCurrentFiltersSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStatePresetAxisFiltersCallback (const char * _filter_uid, const char * _name, void *customData)
{
    // -- callback used when the command <code>AxisFiltersStatePresetAxisFilters</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStatePresetAxisFilters (feature,  _filter_uid,  _name, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_AxisFiltersStateAllPresetFiltersSentCallback (void *customData)
{
    // -- callback used when the command <code>AxisFiltersStateAllPresetFiltersSent</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_ALLPRESETFILTERSSENT;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllPresetFiltersSent (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CoPilotingStatePilotingSourceCallback (eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE _source, void *customData)
{
    // -- callback used when the command <code>CoPilotingStatePilotingSource</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCoPilotingStatePilotingSource (feature,  _source, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateCallback (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS _status, uint8_t _X_Quality, uint8_t _Y_Quality, uint8_t _Z_Quality, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationState (feature,  _status,  _X_Quality,  _Y_Quality,  _Z_Quality, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationQualityUpdatesStateCallback (uint8_t _enabled, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationQualityUpdatesState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationQualityUpdatesState (feature,  _enabled, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CalibrationStateMagnetoCalibrationStateV2Callback (eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATEV2_STATE _state, void *customData)
{
    // -- callback used when the command <code>CalibrationStateMagnetoCalibrationStateV2</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATEV2;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationStateV2 (feature,  _state, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_ButtonEventsSettingsCallback (void *customData)
{
    // -- callback used when the command <code>ButtonEventsSettings</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONEVENTS_SETTINGS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementButtonEventsSettings (feature, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_SkyController_CommonEventStateShutdownCallback (eARCOMMANDS_SKYCONTROLLER_COMMONEVENTSTATE_SHUTDOWN_REASON _reason, void *customData)
{
    // -- callback used when the command <code>CommonEventStateShutdown</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_SkyController_t *feature = (ARCONTROLLER_FEATURE_SkyController_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COMMONEVENTSTATE_SHUTDOWN;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_SkyController_NewCmdElementCommonEventStateShutdown (feature,  _reason, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiList (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _bssid, const char * _ssid, uint8_t _secured, uint8_t _saved, int32_t _rssi, int32_t _frequency, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiList -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_bssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _bssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_BSSID;
            strLength = strlen (_bssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _bssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SECURED;
            argDictNewElement->value.U8 = _secured;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_SAVED;
            argDictNewElement->value.U8 = _saved;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_RSSI;
            argDictNewElement->value.I32 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFILIST_FREQUENCY;
            argDictNewElement->value.I32 = _frequency;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateConnexionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _ssid, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS _status, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateConnexionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_CONNEXIONCHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiAuthChannelListChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND _band, uint8_t _channel, uint8_t _in_or_out, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiAuthChannelListChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGED_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateAllWifiAuthChannelChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateAllWifiAuthChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiSignalChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _level, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiSignalChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFISIGNALCHANGED_LEVEL;
            argDictNewElement->value.U8 = _level;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiAuthChannelListChangedV2 (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_BAND _band, uint8_t _channel, uint8_t _in_or_out, uint8_t _list_flags, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiAuthChannelListChangedV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIAUTHCHANNELLISTCHANGEDV2_IN_OR_OUT;
            argDictNewElement->value.U8 = _in_or_out;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiCountryChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _code, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiCountryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFICOUNTRYCHANGED_CODE;
            strLength = strlen (_code);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _code, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementWifiStateWifiEnvironmentChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_WIFISTATE_WIFIENVIRONMENTCHANGED_ENVIRONMENT _environment, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event WifiStateWifiEnvironmentChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_WIFISTATE_WIFIENVIRONMENTCHANGED_ENVIRONMENT;
            argDictNewElement->value.I32 = _environment;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementDeviceStateDeviceList (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _name, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DeviceStateDeviceList -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_DEVICELIST_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementDeviceStateConnexionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS _status, const char * _deviceName, uint16_t _deviceProductID, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event DeviceStateConnexionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICENAME;
            strLength = strlen (_deviceName);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _deviceName, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_DEVICESTATE_CONNEXIONCHANGED_DEVICEPRODUCTID;
            argDictNewElement->value.U16 = _deviceProductID;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateAllSettingsChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateAllSettingsChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateResetChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateResetChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductSerialChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _serialNumber, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductSerialChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTSERIALCHANGED_SERIALNUMBER;
            strLength = strlen (_serialNumber);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _serialNumber, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductVariantChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT _variant, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductVariantChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVARIANTCHANGED_VARIANT;
            argDictNewElement->value.I32 = _variant;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateProductVersionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _software, const char * _hardware, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateProductVersionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVERSIONCHANGED_SOFTWARE;
            strLength = strlen (_software);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _software, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_PRODUCTVERSIONCHANGED_HARDWARE;
            strLength = strlen (_hardware);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _hardware, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSettingsStateCPUID (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _id, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SettingsStateCPUID -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SETTINGSSTATE_CPUID_ID;
            strLength = strlen (_id);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _id, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCommonStateAllStatesChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonStateAllStatesChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateBatteryChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _percent, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateBatteryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYCHANGED_PERCENT;
            argDictNewElement->value.U8 = _percent;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsFixChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _fixed, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateGpsFixChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSFIXCHANGED_FIXED;
            argDictNewElement->value.U8 = _fixed;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateGpsPositionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, double _latitude, double _longitude, double _altitude, float _heading, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateGpsPositionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LATITUDE;
            argDictNewElement->value.Double = _latitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_LONGITUDE;
            argDictNewElement->value.Double = _longitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_DOUBLE;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_ALTITUDE;
            argDictNewElement->value.Double = _altitude;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_GPSPOSITIONCHANGED_HEADING;
            argDictNewElement->value.Float = _heading;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateBatteryState (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateBatteryState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_BATTERYSTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementSkyControllerStateAttitudeChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, float _q0, float _q1, float _q2, float _q3, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SkyControllerStateAttitudeChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q0;
            argDictNewElement->value.Float = _q0;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q1;
            argDictNewElement->value.Float = _q1;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q2;
            argDictNewElement->value.Float = _q2;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_SKYCONTROLLERSTATE_ATTITUDECHANGED_Q3;
            argDictNewElement->value.Float = _q3;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointSSIDChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _ssid, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessPointSettingsStateAccessPointSSIDChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTSSIDCHANGED_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateAccessPointChannelChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessPointSettingsStateAccessPointChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_ACCESSPOINTCHANNELCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateWifiSelectionChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE _type, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessPointSettingsStateWifiSelectionChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISELECTIONCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAccessPointSettingsStateWifiSecurityChanged (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISECURITYCHANGED_SECURITY_TYPE _security_type, const char * _key, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AccessPointSettingsStateWifiSecurityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISECURITYCHANGED_SECURITY_TYPE;
            argDictNewElement->value.I32 = _security_type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_ACCESSPOINTSETTINGSSTATE_WIFISECURITYCHANGED_KEY;
            strLength = strlen (_key);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _key, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateGamepadControl (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE _type, int32_t _id, const char * _name, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GamepadInfosStateGamepadControl -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_ID;
            argDictNewElement->value.I32 = _id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_GAMEPADINFOSSTATE_GAMEPADCONTROL_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementGamepadInfosStateAllGamepadControlsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event GamepadInfosStateAllGamepadControlsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateCurrentButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t _key_id, const char * _mapping_uid, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateCurrentButtonMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _key_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _key_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_KEY_ID;
            argDictNewElement->value.I32 = _key_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_CURRENTBUTTONMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllCurrentButtonMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateAllCurrentButtonMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAvailableButtonMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _mapping_uid, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateAvailableButtonMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_mapping_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _mapping_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_BUTTONMAPPINGSSTATE_AVAILABLEBUTTONMAPPINGS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonMappingsStateAllAvailableButtonsMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonMappingsStateAllAvailableButtonsMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateCurrentAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t _axis_id, const char * _mapping_uid, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateCurrentAxisMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _axis_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _axis_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_AXIS_ID;
            argDictNewElement->value.I32 = _axis_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_CURRENTAXISMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllCurrentAxisMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateAllCurrentAxisMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAvailableAxisMappings (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _mapping_uid, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateAvailableAxisMappings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_mapping_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _mapping_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_MAPPING_UID;
            strLength = strlen (_mapping_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _mapping_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISMAPPINGSSTATE_AVAILABLEAXISMAPPINGS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisMappingsStateAllAvailableAxisMappingsSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisMappingsStateAllAvailableAxisMappingsSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateCurrentAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature, int32_t _axis_id, const char * _filter_uid_or_builder, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStateCurrentAxisFilters -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIi32, _axis_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIi32, _axis_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I32;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_AXIS_ID;
            argDictNewElement->value.I32 = _axis_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_CURRENTAXISFILTERS_FILTER_UID_OR_BUILDER;
            strLength = strlen (_filter_uid_or_builder);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filter_uid_or_builder, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllCurrentFiltersSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStateAllCurrentFiltersSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStatePresetAxisFilters (ARCONTROLLER_FEATURE_SkyController_t *feature, const char * _filter_uid, const char * _name, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStatePresetAxisFilters -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_filter_uid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _filter_uid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_FILTER_UID;
            strLength = strlen (_filter_uid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _filter_uid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_AXISFILTERSSTATE_PRESETAXISFILTERS_NAME;
            strLength = strlen (_name);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _name, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementAxisFiltersStateAllPresetFiltersSent (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AxisFiltersStateAllPresetFiltersSent -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCoPilotingStatePilotingSource (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE _source, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CoPilotingStatePilotingSource -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COPILOTINGSTATE_PILOTINGSOURCE_SOURCE;
            argDictNewElement->value.I32 = _source;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationState (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS _status, uint8_t _X_Quality, uint8_t _Y_Quality, uint8_t _Z_Quality, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_STATUS;
            argDictNewElement->value.I32 = _status;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_X_QUALITY;
            argDictNewElement->value.U8 = _X_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Y_QUALITY;
            argDictNewElement->value.U8 = _Y_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATE_Z_QUALITY;
            argDictNewElement->value.U8 = _Z_Quality;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationQualityUpdatesState (ARCONTROLLER_FEATURE_SkyController_t *feature, uint8_t _enabled, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationQualityUpdatesState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONQUALITYUPDATESSTATE_ENABLED;
            argDictNewElement->value.U8 = _enabled;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCalibrationStateMagnetoCalibrationStateV2 (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATEV2_STATE _state, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationStateMagnetoCalibrationStateV2 -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_CALIBRATIONSTATE_MAGNETOCALIBRATIONSTATEV2_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementButtonEventsSettings (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ButtonEventsSettings -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_NewCmdElementCommonEventStateShutdown (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCOMMANDS_SKYCONTROLLER_COMMONEVENTSTATE_SHUTDOWN_REASON _reason, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CommonEventStateShutdown -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_SKYCONTROLLER_COMMONEVENTSTATE_SHUTDOWN_REASON;
            argDictNewElement->value.I32 = _reason;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_SkyController_SetNetworkController (ARCONTROLLER_FEATURE_SkyController_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_SkyController_GetCommandElements (ARCONTROLLER_FEATURE_SkyController_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE thermal_cam --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CAMERASTATE_CAM_ID = "arcontroller_dictionary_key_thermal_cam_camerastate_cam_id";
const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CAMERASTATE_STATE = "arcontroller_dictionary_key_thermal_cam_camerastate_state";

const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_SENSITIVITY_CAM_ID = "arcontroller_dictionary_key_thermal_cam_sensitivity_cam_id";
const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_SENSITIVITY_CURRENT_RANGE = "arcontroller_dictionary_key_thermal_cam_sensitivity_current_range";
const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_SENSITIVITY_AVAILABLE_RANGES = "arcontroller_dictionary_key_thermal_cam_sensitivity_available_ranges";

const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_CAM_ID = "arcontroller_dictionary_key_thermal_cam_calibrationinfos_cam_id";
const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_ROLL = "arcontroller_dictionary_key_thermal_cam_calibrationinfos_roll";
const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_PITCH = "arcontroller_dictionary_key_thermal_cam_calibrationinfos_pitch";
const char *ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_YAW = "arcontroller_dictionary_key_thermal_cam_calibrationinfos_yaw";

ARCONTROLLER_FEATURE_ThermalCam_t *ARCONTROLLER_FEATURE_ThermalCam_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_ThermalCam_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_ThermalCam_t));
        if (featureController != NULL)
        {
            featureController->sendActivate = ARCONTROLLER_FEATURE_ThermalCam_SendActivate;
            featureController->sendDeactivate = ARCONTROLLER_FEATURE_ThermalCam_SendDeactivate;
            featureController->sendSetSensitivity = ARCONTROLLER_FEATURE_ThermalCam_SendSetSensitivity;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_ThermalCam_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_ThermalCam_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_ThermalCam_Delete (ARCONTROLLER_FEATURE_ThermalCam_t **feature)
{
    // -- Delete the thermal_cam feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_ThermalCam_GetDictionary (ARCONTROLLER_FEATURE_ThermalCam_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the thermal_cam Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_AddCallback (ARCONTROLLER_FEATURE_ThermalCam_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>ThermalCam</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_RemoveCallback (ARCONTROLLER_FEATURE_ThermalCam_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>ThermalCam</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_RegisterARCommands (ARCONTROLLER_FEATURE_ThermalCam_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetThermalCamCameraStateCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ThermalCam_CameraStateCallback, feature);
        ARCOMMANDS_Decoder_SetThermalCamSensitivityCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ThermalCam_SensitivityCallback, feature);
        ARCOMMANDS_Decoder_SetThermalCamCalibrationInfosCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_ThermalCam_CalibrationInfosCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_UnregisterARCommands (ARCONTROLLER_FEATURE_ThermalCam_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetThermalCamCameraStateCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetThermalCamSensitivityCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetThermalCamCalibrationInfosCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_SendActivate (ARCONTROLLER_FEATURE_ThermalCam_t *feature, uint8_t cam_id)
{
    // -- Send a command <code>Activate</code> in project <code>ThermalCam</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Activate command
        cmdError = ARCOMMANDS_Generator_GenerateThermalCamActivate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, cam_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_SendDeactivate (ARCONTROLLER_FEATURE_ThermalCam_t *feature, uint8_t cam_id)
{
    // -- Send a command <code>Deactivate</code> in project <code>ThermalCam</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Deactivate command
        cmdError = ARCOMMANDS_Generator_GenerateThermalCamDeactivate(cmdBuffer, sizeof(cmdBuffer), &cmdSize, cam_id);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_SendSetSensitivity (ARCONTROLLER_FEATURE_ThermalCam_t *feature, uint8_t cam_id, eARCOMMANDS_THERMAL_CAM_RANGE range)
{
    // -- Send a command <code>SetSensitivity</code> in project <code>ThermalCam</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetSensitivity command
        cmdError = ARCOMMANDS_Generator_GenerateThermalCamSetSensitivity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, cam_id, range);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_ThermalCam_CameraStateCallback (uint8_t _cam_id, eARCOMMANDS_THERMAL_CAM_STATE _state, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>CameraState</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ThermalCam_t *feature = (ARCONTROLLER_FEATURE_ThermalCam_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CAMERASTATE;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _cam_id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_ThermalCam_NewCmdElementCameraState (feature, _cam_id,  _state,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ThermalCam_SensitivityCallback (uint8_t _cam_id, eARCOMMANDS_THERMAL_CAM_RANGE _current_range, uint8_t _available_ranges, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>Sensitivity</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ThermalCam_t *feature = (ARCONTROLLER_FEATURE_ThermalCam_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_SENSITIVITY;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _cam_id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_ThermalCam_NewCmdElementSensitivity (feature, _cam_id,  _current_range,  _available_ranges,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_ThermalCam_CalibrationInfosCallback (uint8_t _cam_id, float _roll, float _pitch, float _yaw, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>CalibrationInfos</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_ThermalCam_t *feature = (ARCONTROLLER_FEATURE_ThermalCam_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    int elementKeyLength = 0;
    char *elementKey = NULL;

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
            elementKey = malloc (elementKeyLength + 1);
            if (elementKey != NULL)
            {
                snprintf (elementKey, (elementKeyLength + 1), "%"PRIu8, _cam_id);
                HASH_FIND_STR (dictCmdElement->elements, elementKey, dictElement);
            }
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            /* cleanup */
            free (elementKey);
            elementKey = NULL;

            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_ThermalCam_NewCmdElementCalibrationInfos (feature, _cam_id,  _roll,  _pitch,  _yaw,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ThermalCam_NewCmdElementCameraState (ARCONTROLLER_FEATURE_ThermalCam_t *feature, uint8_t _cam_id, eARCOMMANDS_THERMAL_CAM_STATE _state, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CameraState -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _cam_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CAMERASTATE_CAM_ID;
            argDictNewElement->value.U8 = _cam_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CAMERASTATE_STATE;
            argDictNewElement->value.I32 = _state;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ThermalCam_NewCmdElementSensitivity (ARCONTROLLER_FEATURE_ThermalCam_t *feature, uint8_t _cam_id, eARCOMMANDS_THERMAL_CAM_RANGE _current_range, uint8_t _available_ranges, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event Sensitivity -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _cam_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_SENSITIVITY_CAM_ID;
            argDictNewElement->value.U8 = _cam_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_SENSITIVITY_CURRENT_RANGE;
            argDictNewElement->value.I32 = _current_range;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_SENSITIVITY_AVAILABLE_RANGES;
            argDictNewElement->value.U8 = _available_ranges;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ThermalCam_NewCmdElementCalibrationInfos (ARCONTROLLER_FEATURE_ThermalCam_t *feature, uint8_t _cam_id, float _roll, float _pitch, float _yaw, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CalibrationInfos -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%"PRIu8, _cam_id);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%"PRIu8, _cam_id);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_CAM_ID;
            argDictNewElement->value.U8 = _cam_id;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_ROLL;
            argDictNewElement->value.Float = _roll;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_PITCH;
            argDictNewElement->value.Float = _pitch;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_FLOAT;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_THERMAL_CAM_CALIBRATIONINFOS_YAW;
            argDictNewElement->value.Float = _yaw;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_ThermalCam_SetNetworkController (ARCONTROLLER_FEATURE_ThermalCam_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_ThermalCam_GetCommandElements (ARCONTROLLER_FEATURE_ThermalCam_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
/*******************************
 * --- FEATURE wifi --- 
 ******************************/

/*************************
 * Private header
 *************************/

/*************************
 * Implementation
 *************************/

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_SSID = "arcontroller_dictionary_key_wifi_scanneditem_ssid";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_RSSI = "arcontroller_dictionary_key_wifi_scanneditem_rssi";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_BAND = "arcontroller_dictionary_key_wifi_scanneditem_band";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_CHANNEL = "arcontroller_dictionary_key_wifi_scanneditem_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_BAND = "arcontroller_dictionary_key_wifi_authorizedchannel_band";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_CHANNEL = "arcontroller_dictionary_key_wifi_authorizedchannel_channel";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_ENVIRONMENT = "arcontroller_dictionary_key_wifi_authorizedchannel_environment";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_TYPE = "arcontroller_dictionary_key_wifi_apchannelchanged_type";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_BAND = "arcontroller_dictionary_key_wifi_apchannelchanged_band";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_CHANNEL = "arcontroller_dictionary_key_wifi_apchannelchanged_channel";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY = "arcontroller_dictionary_key_wifi_securitychanged_key";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY_TYPE = "arcontroller_dictionary_key_wifi_securitychanged_key_type";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_SELECTION_MODE = "arcontroller_dictionary_key_wifi_countrychanged_selection_mode";
const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_CODE = "arcontroller_dictionary_key_wifi_countrychanged_code";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_ENVIRONMENTCHANGED_ENVIRONMENT = "arcontroller_dictionary_key_wifi_environmentchanged_environment";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_RSSICHANGED_RSSI = "arcontroller_dictionary_key_wifi_rssichanged_rssi";

const char *ARCONTROLLER_DICTIONARY_KEY_WIFI_SUPPORTEDCOUNTRIES_COUNTRIES = "arcontroller_dictionary_key_wifi_supportedcountries_countries";

ARCONTROLLER_FEATURE_Wifi_t *ARCONTROLLER_FEATURE_Wifi_New (ARCONTROLLER_Network_t *networkController, eARCONTROLLER_ERROR *error)
{
    // -- Create a new Feature Controller --
    
    //local declarations
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
   ARCONTROLLER_FEATURE_Wifi_t *featureController =  NULL;
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller
        featureController = malloc (sizeof (ARCONTROLLER_FEATURE_Wifi_t));
        if (featureController != NULL)
        {
            featureController->sendScan = ARCONTROLLER_FEATURE_Wifi_SendScan;
            featureController->sendUpdateAuthorizedChannels = ARCONTROLLER_FEATURE_Wifi_SendUpdateAuthorizedChannels;
            featureController->sendSetApChannel = ARCONTROLLER_FEATURE_Wifi_SendSetApChannel;
            featureController->sendSetSecurity = ARCONTROLLER_FEATURE_Wifi_SendSetSecurity;
            featureController->sendSetCountry = ARCONTROLLER_FEATURE_Wifi_SendSetCountry;
            featureController->sendSetEnvironment = ARCONTROLLER_FEATURE_Wifi_SendSetEnvironment;
            
            featureController->privatePart = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    if (localError == ARCONTROLLER_OK)
    {
        // Create the Feature Controller private part
        featureController->privatePart = malloc (sizeof (ARCONTROLLER_FEATURE_Wifi_Private_t));
        if (featureController->privatePart != NULL)
        {
            featureController->privatePart->networkController = networkController;
            featureController->privatePart->dictionary = NULL;
            featureController->privatePart->commandCallbacks = NULL;
            // Create the mutex 
            if (ARSAL_Mutex_Init (&(featureController->privatePart->mutex)) != 0)
            {
                localError = ARCONTROLLER_ERROR_INIT_MUTEX;
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    // No else: skipped by an error 
    
    // delete the feature Controller if an error occurred
    if (localError != ARCONTROLLER_OK)
    {
        ARCONTROLLER_FEATURE_Wifi_Delete (&featureController);
    }
    // No else: skipped no error 
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return featureController;
}

void ARCONTROLLER_FEATURE_Wifi_Delete (ARCONTROLLER_FEATURE_Wifi_t **feature)
{
    // -- Delete the wifi feature Controller --
    
    if (feature != NULL)
    {
        if ((*feature) != NULL)
        {
            if ((*feature)->privatePart != NULL)
            {
                ARSAL_Mutex_Destroy (&((*feature)->privatePart->mutex));
                
                if ((*feature)->privatePart->dictionary != NULL)
                {
                    ARCONTROLLER_Feature_DeleteCommandsDictionary (&((*feature)->privatePart->dictionary));
                }
                
                if ((*feature)->privatePart->commandCallbacks != NULL)
                {
                    // Free the hash table contents the command callback
                    ARCONTROLLER_Dictionary_DeleteDictionary (&((*feature)->privatePart->commandCallbacks));
                }
                
                free ((*feature)->privatePart);
                (*feature)->privatePart = NULL;
            }
            
            free (*feature);
            (*feature) = NULL;
        }
    }
}

ARCONTROLLER_DICTIONARY_COMMANDS_t *ARCONTROLLER_FEATURE_Wifi_GetDictionary (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_ERROR *error)
{
    // -- Get the dictionary of the wifi Feature Controller --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictionary = NULL;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        dictionary = feature->privatePart->dictionary;
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return dictionary;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_AddCallback (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Add a callback to use when a command in project <code>Wifi</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_AddDictionaryElement (&(feature->privatePart->commandCallbacks), commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_RemoveCallback (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, ARCONTROLLER_DICTIONARY_CALLBACK_t callback, void *customData)
{
    // -- Remove a callback to use when a command in project <code>Wifi</code> is received --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Dictionary_RemoveDictionaryElement (feature->privatePart->commandCallbacks, commandKey, callback, customData);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_RegisterARCommands (ARCONTROLLER_FEATURE_Wifi_t *feature)
{
    // -- Register the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetWifiScannedItemCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_ScannedItemCallback, feature);
        ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_AuthorizedChannelCallback, feature);
        ARCOMMANDS_Decoder_SetWifiApChannelChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_ApChannelChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiSecurityChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_SecurityChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiCountryChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_CountryChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_EnvironmentChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiRssiChangedCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_RssiChangedCallback, feature);
        ARCOMMANDS_Decoder_SetWifiSupportedCountriesCb (feature->privatePart->networkController->decoder, &ARCONTROLLER_FEATURE_Wifi_SupportedCountriesCallback, feature);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_UnregisterARCommands (ARCONTROLLER_FEATURE_Wifi_t *feature)
{
    // -- Unregister the feature controller to be called when the commands are decoded. -- 
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL) || (feature->privatePart->networkController == NULL) || (feature->privatePart->networkController->decoder == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        ARCOMMANDS_Decoder_SetWifiScannedItemCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiAuthorizedChannelCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiApChannelChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiSecurityChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiCountryChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiEnvironmentChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiRssiChangedCb (feature->privatePart->networkController->decoder, NULL, NULL);
        ARCOMMANDS_Decoder_SetWifiSupportedCountriesCb (feature->privatePart->networkController->decoder, NULL, NULL);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendScan (ARCONTROLLER_FEATURE_Wifi_t *feature, uint8_t band)
{
    // -- Send a command <code>Scan</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send Scan command
        cmdError = ARCOMMANDS_Generator_GenerateWifiScan(cmdBuffer, sizeof(cmdBuffer), &cmdSize, band);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendUpdateAuthorizedChannels (ARCONTROLLER_FEATURE_Wifi_t *feature)
{
    // -- Send a command <code>UpdateAuthorizedChannels</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send UpdateAuthorizedChannels command
        cmdError = ARCOMMANDS_Generator_GenerateWifiUpdateAuthorizedChannels(cmdBuffer, sizeof(cmdBuffer), &cmdSize);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetApChannel (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_SELECTION_TYPE type, eARCOMMANDS_WIFI_BAND band, uint8_t channel)
{
    // -- Send a command <code>SetApChannel</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetApChannel command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetApChannel(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, band, channel);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetSecurity (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_SECURITY_TYPE type, char * key, eARCOMMANDS_WIFI_SECURITY_KEY_TYPE key_type)
{
    // -- Send a command <code>SetSecurity</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetSecurity command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetSecurity(cmdBuffer, sizeof(cmdBuffer), &cmdSize, type, key, key_type);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetCountry (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_COUNTRY_SELECTION selection_mode, char * code)
{
    // -- Send a command <code>SetCountry</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetCountry command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetCountry(cmdBuffer, sizeof(cmdBuffer), &cmdSize, selection_mode, code);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SendSetEnvironment (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_ENVIRONMENT environment)
{
    // -- Send a command <code>SetEnvironment</code> in project <code>Wifi</code> --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    u_int8_t cmdBuffer[512];
    int32_t cmdSize = 0;
    eARCOMMANDS_GENERATOR_ERROR cmdError = ARCOMMANDS_GENERATOR_OK;
    eARNETWORK_ERROR netError = ARNETWORK_OK;
    
    // Check parameters
    if (feature == NULL)
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Send SetEnvironment command
        cmdError = ARCOMMANDS_Generator_GenerateWifiSetEnvironment(cmdBuffer, sizeof(cmdBuffer), &cmdSize, environment);
        if (cmdError != ARCOMMANDS_GENERATOR_OK)
        {
            error = ARCONTROLLER_ERROR_COMMAND_GENERATING;
        }
    }
    
    if (error == ARCONTROLLER_OK)
    {
        error = ARCONTROLLER_Network_SendData (feature->privatePart->networkController, cmdBuffer, cmdSize, ARCONTROLLER_NETWORK_SENDING_DATA_TYPE_ACK, ARNETWORK_MANAGER_CALLBACK_RETURN_DATA_POP, &netError);
    }
    
    return error;
}

void ARCONTROLLER_FEATURE_Wifi_ScannedItemCallback (const char * _ssid, int16_t _rssi, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>ScannedItem</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int remove = (_list_flags & ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE);
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    ARCONTROLLER_DICTIONARY_ELEMENT_t *dictElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if ((remove) && (dictCmdElement != NULL))
        {
            //remove element
            ARSAL_Mutex_Lock (&(feature->privatePart->mutex));

            HASH_FIND_STR (dictCmdElement->elements, _ssid, dictElement);
            if (dictElement != NULL)
            {
                HASH_DEL (dictCmdElement->elements, dictElement);
                ARCONTROLLER_Feature_DeleteElement (&dictElement);
            }
            ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            // force notifying when removing because the Mambo does not send last when removing a usbAccessory
            notify = 1;
        }

        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            //Create new element
            newElement = ARCONTROLLER_Wifi_NewCmdElementScannedItem (feature, _ssid,  _rssi,  _band,  _channel,  _list_flags, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_AuthorizedChannelCallback (eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _environment, uint8_t _list_flags, void *customData)
{
    // -- callback used when the command <code>AuthorizedChannel</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int listIndex = 0;
    int clear = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_FIRST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int notify = (_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_LAST | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));
    int add = !(_list_flags & (ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_REMOVE | ARCOMMANDS_FLAG_GENERIC_LIST_FLAGS_EMPTY));

    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if ((error == ARCONTROLLER_OK) && (dictCmdElement != NULL) && (clear))
    {
        //Delete the command
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_DEL (feature->privatePart->dictionary, dictCmdElement);
        ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        if (add)
        {
            if (dictCmdElement == NULL)
            {
                // New command element
                isANewCommandElement = 1;
                dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
            }
            // No Else ; commandElement already exists.
            
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                listIndex = HASH_COUNT (dictCmdElement->elements);
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
            
            //Create new element
            newElement = ARCONTROLLER_Wifi_NewCmdElementAuthorizedChannel (feature, _band,  _channel,  _environment,  _list_flags, listIndex, &error);
            
            //Set new element in CommandElements 
            if (error == ARCONTROLLER_OK)
            {
                ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
                
                ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
                
                //Add new commandElement if necessary
                if (isANewCommandElement)
                {
                    HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
                }
                
                elementAdded = 1;
                
                ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
            }
        }
    }
    
    if ((error == ARCONTROLLER_OK) && (notify))
    {
        // Notification Callback
        if (dictCmdElement != NULL) {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
        } else {
            error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, commandKey, NULL);
        }
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_ApChannelChangedCallback (eARCOMMANDS_WIFI_SELECTION_TYPE _type, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, void *customData)
{
    // -- callback used when the command <code>ApChannelChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementApChannelChanged (feature,  _type,  _band,  _channel, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_SecurityChangedCallback (const char * _key, eARCOMMANDS_WIFI_SECURITY_TYPE _key_type, void *customData)
{
    // -- callback used when the command <code>SecurityChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementSecurityChanged (feature,  _key,  _key_type, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_CountryChangedCallback (eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode, const char * _code, void *customData)
{
    // -- callback used when the command <code>CountryChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementCountryChanged (feature,  _selection_mode,  _code, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_EnvironmentChangedCallback (eARCOMMANDS_WIFI_ENVIRONMENT _environment, void *customData)
{
    // -- callback used when the command <code>EnvironmentChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_ENVIRONMENTCHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementEnvironmentChanged (feature,  _environment, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_RssiChangedCallback (int16_t _rssi, void *customData)
{
    // -- callback used when the command <code>RssiChanged</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_RSSICHANGED;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementRssiChanged (feature,  _rssi, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

void ARCONTROLLER_FEATURE_Wifi_SupportedCountriesCallback (const char * _countries, void *customData)
{
    // -- callback used when the command <code>SupportedCountries</code> is decoded -- 
    
    ARCONTROLLER_FEATURE_Wifi_t *feature = (ARCONTROLLER_FEATURE_Wifi_t *)customData;
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    int commandKey = ARCONTROLLER_DICTIONARY_KEY_WIFI_SUPPORTEDCOUNTRIES;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *dictCmdElement = NULL;
    int isANewCommandElement = 0;
    int elementAdded = 0;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        // Find command elements
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        HASH_FIND_INT (feature->privatePart->dictionary, &commandKey, dictCmdElement);
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (dictCmdElement == NULL)
        {
            // New command element
            isANewCommandElement = 1;
            dictCmdElement = ARCONTROLLER_Feature_NewCommandsElement (commandKey, &error);
        }
        // No Else ; commandElement already exists.
        
    }
    
    if (error == ARCONTROLLER_OK)
    {
        //Create new element
        newElement = ARCONTROLLER_Wifi_NewCmdElementSupportedCountries (feature,  _countries, &error);
    }
    
    //Set new element in CommandElements 
    if (error == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        ARCONTROLLER_Feature_AddElement (&(dictCmdElement->elements), newElement);
        
        //Add new commandElement if necessary
        if (isANewCommandElement)
        {
            HASH_ADD_INT (feature->privatePart->dictionary, command, dictCmdElement);
        }
        
        elementAdded = 1;
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    if (error == ARCONTROLLER_OK)
    {
        // Notification Callback
        error = ARCONTROLLER_Dictionary_Notify (feature->privatePart->commandCallbacks, dictCmdElement->command, dictCmdElement->elements);
    }
    
    // if an error occurred 
    if (error != ARCONTROLLER_OK)
    {
        // cleanup
        if ((dictCmdElement != NULL) && (isANewCommandElement))
        {
            ARCONTROLLER_Feature_DeleteCommandsElement(&dictCmdElement);
        }
        
        if ((newElement != NULL) && (!elementAdded ))
        {
            ARCONTROLLER_Feature_DeleteElement (&newElement);
        }
        
    }
    
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementScannedItem (ARCONTROLLER_FEATURE_Wifi_t *feature, const char * _ssid, int16_t _rssi, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _list_flags, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ScannedItem -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (_ssid);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, _ssid, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_SSID;
            strLength = strlen (_ssid);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _ssid, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SCANNEDITEM_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementAuthorizedChannel (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, uint8_t _environment, uint8_t _list_flags, int listIndex, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event AuthorizedChannel -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        //Alloc Element Key
        elementKeyLength = snprintf (NULL, 0, "%d", listIndex);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            snprintf (newElement->key, (elementKeyLength + 1), "%d", listIndex);
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_AUTHORIZEDCHANNEL_ENVIRONMENT;
            argDictNewElement->value.U8 = _environment;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementApChannelChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_SELECTION_TYPE _type, eARCOMMANDS_WIFI_BAND _band, uint8_t _channel, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event ApChannelChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_TYPE;
            argDictNewElement->value.I32 = _type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_BAND;
            argDictNewElement->value.I32 = _band;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_U8;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_APCHANNELCHANGED_CHANNEL;
            argDictNewElement->value.U8 = _channel;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementSecurityChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, const char * _key, eARCOMMANDS_WIFI_SECURITY_TYPE _key_type, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SecurityChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY;
            strLength = strlen (_key);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _key, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SECURITYCHANGED_KEY_TYPE;
            argDictNewElement->value.I32 = _key_type;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementCountryChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_COUNTRY_SELECTION _selection_mode, const char * _code, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event CountryChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_SELECTION_MODE;
            argDictNewElement->value.I32 = _selection_mode;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_COUNTRYCHANGED_CODE;
            strLength = strlen (_code);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _code, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementEnvironmentChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCOMMANDS_WIFI_ENVIRONMENT _environment, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event EnvironmentChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_ENUM;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_ENVIRONMENTCHANGED_ENVIRONMENT;
            argDictNewElement->value.I32 = _environment;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementRssiChanged (ARCONTROLLER_FEATURE_Wifi_t *feature, int16_t _rssi, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event RssiChanged -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_I16;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_RSSICHANGED_RSSI;
            argDictNewElement->value.I16 = _rssi;
            
            HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_NewCmdElementSupportedCountries (ARCONTROLLER_FEATURE_Wifi_t *feature, const char * _countries, eARCONTROLLER_ERROR *error)
{
    // -- Create element of an event SupportedCountries -- 
    
    ARCONTROLLER_DICTIONARY_ELEMENT_t *newElement = NULL;
    int elementKeyLength = 0;
    ARCONTROLLER_DICTIONARY_ARG_t *argDictNewElement = NULL;
    int strLength = 0;
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    //Create Element Dictionary
    if (localError == ARCONTROLLER_OK)
    {
        // New element
        newElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ELEMENT_t));
        if (newElement != NULL)
        {
            newElement->key = NULL;
            newElement->arguments = NULL;
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    if (localError == ARCONTROLLER_OK)
    {
        //Alloc Element Key
        elementKeyLength = strlen (ARCONTROLLER_DICTIONARY_SINGLE_KEY);
        newElement->key = malloc (elementKeyLength + 1);
        if (newElement->key != NULL)
        {
            strncpy (newElement->key, ARCONTROLLER_DICTIONARY_SINGLE_KEY, (elementKeyLength + 1));
            newElement->key[elementKeyLength] = '\0';
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    //Create argument Dictionary
    //Add argument To the element
    if (localError == ARCONTROLLER_OK)
    {
        // New argument element
        argDictNewElement = malloc (sizeof(ARCONTROLLER_DICTIONARY_ARG_t));
        if (argDictNewElement != NULL)
        {
            argDictNewElement->valueType = ARCONTROLLER_DICTIONARY_VALUE_TYPE_STRING;
            argDictNewElement->argument = ARCONTROLLER_DICTIONARY_KEY_WIFI_SUPPORTEDCOUNTRIES_COUNTRIES;
            strLength = strlen (_countries);
            argDictNewElement->value.String = malloc (strLength + 1);
            if (argDictNewElement->value.String != NULL)
            {
                strncpy (argDictNewElement->value.String, _countries, strLength);
                argDictNewElement->value.String[strLength] = '\0';
            }
            else
            {
                localError = ARCONTROLLER_ERROR_ALLOC;
            }
            
            if (localError == ARCONTROLLER_OK)
            {
                HASH_ADD_KEYPTR (hh, newElement->arguments, argDictNewElement->argument, strlen(argDictNewElement->argument), argDictNewElement);
            }
        }
        else
        {
            localError = ARCONTROLLER_ERROR_ALLOC;
        }
    }
    
    // If an error occurred 
    if (localError != ARCONTROLLER_OK)
    {
        // cleanup
        if (newElement != NULL)
        {
            if (newElement->arguments != NULL)
            {
                if (newElement->arguments->value.String != NULL)
                {
                    free(newElement->arguments->value.String);
                    newElement->arguments->value.String = NULL;
                }
                
                free (newElement->arguments);
                newElement->arguments = NULL;
            }
            
            if (newElement->key != NULL)
            {
                free (newElement->key);
                newElement->key = NULL;
            }
            
            free (newElement);
            newElement = NULL;
        }

        free (argDictNewElement);
        argDictNewElement = NULL;
    }
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return newElement;
}

eARCONTROLLER_ERROR ARCONTROLLER_FEATURE_Wifi_SetNetworkController (ARCONTROLLER_FEATURE_Wifi_t *feature, ARCONTROLLER_Network_t *networkController)
{
    // -- Set a NetworkController to use to send commands. --
    
    eARCONTROLLER_ERROR error = ARCONTROLLER_OK;
    
    // Check parameters
    if ((feature == NULL) || (feature->privatePart == NULL))
    {
        error = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets error to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (error == ARCONTROLLER_OK)
    {
        feature->privatePart->networkController = networkController;
    }
    
    return error;
}

ARCONTROLLER_DICTIONARY_ELEMENT_t *ARCONTROLLER_Wifi_GetCommandElements (ARCONTROLLER_FEATURE_Wifi_t *feature, eARCONTROLLER_DICTIONARY_KEY commandKey, eARCONTROLLER_ERROR *error)
{
    // -- Get Command Arguments --
    
    eARCONTROLLER_ERROR localError = ARCONTROLLER_OK;
    ARCONTROLLER_DICTIONARY_COMMANDS_t *commandDic = NULL;
    ARCONTROLLER_DICTIONARY_ELEMENT_t *elements = NULL;
    
    // Check parameters
    if ((feature == NULL) ||
        (feature->privatePart == NULL))
    {
        localError = ARCONTROLLER_ERROR_BAD_PARAMETER;
    }
    // No Else: the checking parameters sets localError to ARNETWORK_ERROR_BAD_PARAMETER and stop the processing
    
    if (localError == ARCONTROLLER_OK)
    {
        ARSAL_Mutex_Lock (&(feature->privatePart->mutex));
        
        // Find elements
        HASH_FIND_INT (feature->privatePart->dictionary, &(commandKey), commandDic);
        if (commandDic != NULL)
        {
            elements = commandDic->elements;
        }
        // NO Else ; Command not found 
        
        ARSAL_Mutex_Unlock (&(feature->privatePart->mutex));
        
        if (elements == NULL)
        {
            localError = ARCONTROLLER_ERROR_NO_ELEMENT;
        }
    }
    
    // Return the error
    if (error != NULL)
    {
        *error = localError;
    }
    // No else: error is not returned 
    
    return elements;
}

/************************
 * Private Implementation
 *************************/
